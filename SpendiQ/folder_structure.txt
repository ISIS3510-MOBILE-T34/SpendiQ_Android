# Folder structure for `app`

- proguard-rules.pro
    ```
    # Add project specific ProGuard rules here.
    # You can control the set of applied configuration files using the
    # proguardFiles setting in build.gradle.
    #
    # For more details, see
    #   http://developer.android.com/guide/developing/tools/proguard.html
    
    # If your project uses WebView with JS, uncomment the following
    # and specify the fully qualified class name to the JavaScript interface
    # class:
    #-keepclassmembers class fqcn.of.javascript.interface.for.webview {
    #   public *;
    #}
    
    # Uncomment this to preserve the line number information for
    # debugging stack traces.
    #-keepattributes SourceFile,LineNumberTable
    
    # If you keep the line number information, uncomment this to
    # hide the original source file name.
    #-renamesourcefileattribute SourceFile    ```
- .gitignore
    ```
    /build    ```
- build.gradle.kts
    ```
    plugins {
        alias(libs.plugins.android.application)
        alias(libs.plugins.kotlin.android)
        id("com.google.gms.google-services")
        id("com.google.firebase.crashlytics")
    }
    
    android {
        namespace = "com.isis3510.spendiq"
        compileSdk = 34
    
        defaultConfig {
            applicationId = "com.isis3510.spendiq"
            minSdk = 24
            targetSdk = 34
            versionCode = 1
            versionName = "1.0"
    
            testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
            vectorDrawables {
                useSupportLibrary = true
            }
        }
    
        buildTypes {
            release {
                isMinifyEnabled = false
                proguardFiles(
                    getDefaultProguardFile("proguard-android-optimize.txt"),
                    "proguard-rules.pro"
                )
            }
        }
        compileOptions {
            sourceCompatibility = JavaVersion.VERSION_1_8
            targetCompatibility = JavaVersion.VERSION_1_8
        }
        kotlinOptions {
            jvmTarget = "1.8"
        }
        buildFeatures {
            compose = true
            viewBinding = true
        }
        composeOptions {
            kotlinCompilerExtensionVersion = "1.5.1"
        }
        packaging {
            resources {
                excludes += "/META-INF/{AL2.0,LGPL2.1}"
            }
        }
    }
    
    dependencies {
        // Firebase
        implementation(platform("com.google.firebase:firebase-bom:32.7.0"))
        implementation("com.google.firebase:firebase-crashlytics-ktx")
        implementation("com.google.firebase:firebase-analytics-ktx")
        implementation("com.google.firebase:firebase-auth-ktx")
        implementation("com.google.firebase:firebase-firestore-ktx")
        implementation("com.google.firebase:firebase-storage-ktx")
        implementation("com.google.firebase:firebase-analytics-ktx")
        implementation("com.google.maps.android:maps-compose:2.4.0")
    
        // Coil for image loading
        implementation("io.coil-kt:coil-compose:2.4.0")
    
        // AndroidX and Compose
        implementation(libs.androidx.core.ktx)
        implementation(libs.androidx.lifecycle.runtime.ktx)
        implementation(libs.androidx.activity.compose)
        implementation(platform(libs.androidx.compose.bom))
        implementation(libs.androidx.ui)
        implementation(libs.androidx.ui.graphics)
        implementation(libs.androidx.ui.tooling.preview)
        implementation(libs.androidx.material3)
        implementation(libs.androidx.biometric)
        implementation(libs.androidx.security.crypto)
    
        // Navigation and ViewModel
        implementation("androidx.navigation:navigation-compose:2.7.6")
        implementation("androidx.lifecycle:lifecycle-viewmodel-compose:2.6.2")
        implementation("androidx.compose.runtime:runtime-livedata:1.5.4")
    
        // Image Loading
        implementation("io.coil-kt:coil-compose:2.4.0")
        implementation("io.coil-kt.coil3:coil-compose:3.0.0-rc01")
    
        // Location Services
        implementation("com.google.android.gms:play-services-location:21.0.1")
        implementation("com.google.android.gms:play-services-auth:20.5.0")
        implementation(libs.firebase.crashlytics.buildtools)
        implementation(libs.play.services.maps)
        implementation(libs.androidx.espresso.core)
    
        // Testing
        testImplementation(libs.junit)
        androidTestImplementation(libs.androidx.junit)
        androidTestImplementation(libs.androidx.espresso.core)
        androidTestImplementation(platform(libs.androidx.compose.bom))
        androidTestImplementation(libs.androidx.ui.test.junit4)
        debugImplementation(libs.androidx.ui.tooling)
        debugImplementation(libs.androidx.ui.test.manifest)
    
        // Retrofit and OkHttp
        implementation("com.squareup.retrofit2:retrofit:2.9.0") // Retrofit library
        implementation("com.squareup.retrofit2:converter-gson:2.9.0") // Gson converter for Retrofit
        implementation("com.squareup.okhttp3:okhttp:4.11.0") // OkHttp for networking
    
        // Graphs
        implementation("io.github.ehsannarmani:compose-charts:0.0.14")
    }    ```
- google-services.json
    ```
    {
      "project_info": {
        "project_number": "684669295151",
        "firebase_url": "https://spendiq-e31f0-default-rtdb.firebaseio.com",
        "project_id": "spendiq-e31f0",
        "storage_bucket": "spendiq-e31f0.appspot.com"
      },
      "client": [
        {
          "client_info": {
            "mobilesdk_app_id": "1:684669295151:android:a71dd269e2bffd470d84da",
            "android_client_info": {
              "package_name": "com.isis3510.spendiq"
            }
          },
          "oauth_client": [],
          "api_key": [
            {
              "current_key": "AIzaSyDioSCFcZivQpHJUXb-GNAdE8Spm-bOSPM"
            }
          ],
          "services": {
            "appinvite_service": {
              "other_platform_oauth_client": []
            }
          }
        },
        {
          "client_info": {
            "mobilesdk_app_id": "1:684669295151:android:72976c99dbc376780d84da",
            "android_client_info": {
              "package_name": "s.s.s"
            }
          },
          "oauth_client": [],
          "api_key": [
            {
              "current_key": "AIzaSyDioSCFcZivQpHJUXb-GNAdE8Spm-bOSPM"
            }
          ],
          "services": {
            "appinvite_service": {
              "other_platform_oauth_client": []
            }
          }
        },
        {
          "client_info": {
            "mobilesdk_app_id": "1:684669295151:android:d89eda12c69a8c740d84da",
            "android_client_info": {
              "package_name": "sdf.sdf.sdf"
            }
          },
          "oauth_client": [],
          "api_key": [
            {
              "current_key": "AIzaSyDioSCFcZivQpHJUXb-GNAdE8Spm-bOSPM"
            }
          ],
          "services": {
            "appinvite_service": {
              "other_platform_oauth_client": []
            }
          }
        }
      ],
      "configuration_version": "1"
    }    ```
- **.idea/**
    - migrations.xml
        ```
        <?xml version="1.0" encoding="UTF-8"?>
        <project version="4">
          <component name="ProjectMigrations">
            <option name="MigrateToGradleLocalJavaHome">
              <set>
                <option value="$PROJECT_DIR$" />
              </set>
            </option>
          </component>
        </project>        ```
    - gradle.xml
        ```
        <?xml version="1.0" encoding="UTF-8"?>
        <project version="4">
          <component name="GradleSettings">
            <option name="linkedExternalProjectsSettings">
              <GradleProjectSettings>
                <option name="externalProjectPath" value="$PROJECT_DIR$" />
                <option name="gradleJvm" value="#GRADLE_LOCAL_JAVA_HOME" />
                <option name="resolveExternalAnnotations" value="false" />
              </GradleProjectSettings>
            </option>
          </component>
        </project>        ```
    - vcs.xml
        ```
        <?xml version="1.0" encoding="UTF-8"?>
        <project version="4">
          <component name="VcsDirectoryMappings">
            <mapping directory="$PROJECT_DIR$/../.." vcs="Git" />
          </component>
        </project>        ```
    - workspace.xml
        ```
        <?xml version="1.0" encoding="UTF-8"?>
        <project version="4">
          <component name="AutoImportSettings">
            <option name="autoReloadType" value="NONE" />
          </component>
          <component name="ChangeListManager">
            <list default="true" id="227b5e8e-4964-4551-a9b7-59996885aab5" name="Changes" comment="">
              <change afterPath="$PROJECT_DIR$/google-services.json" afterDir="false" />
              <change beforePath="$PROJECT_DIR$/../.idea/gradle.xml" beforeDir="false" afterPath="$PROJECT_DIR$/../.idea/gradle.xml" afterDir="false" />
              <change beforePath="$PROJECT_DIR$/../.idea/misc.xml" beforeDir="false" afterPath="$PROJECT_DIR$/../.idea/misc.xml" afterDir="false" />
              <change beforePath="$PROJECT_DIR$/../build.gradle.kts" beforeDir="false" afterPath="$PROJECT_DIR$/../build.gradle.kts" afterDir="false" />
            </list>
            <option name="SHOW_DIALOG" value="false" />
            <option name="HIGHLIGHT_CONFLICTS" value="true" />
            <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
            <option name="LAST_RESOLUTION" value="IGNORE" />
          </component>
          <component name="ClangdSettings">
            <option name="formatViaClangd" value="false" />
          </component>
          <component name="ProjectColorInfo"><![CDATA[{
          "associatedIndex": 2
        }]]></component>
          <component name="ProjectId" id="2mqTTVy9FZepOiYTbhXlJLRmJfs" />
          <component name="ProjectViewState">
            <option name="hideEmptyMiddlePackages" value="true" />
            <option name="showLibraryContents" value="true" />
          </component>
          <component name="PropertiesComponent"><![CDATA[{
          "keyToString": {
            "RunOnceActivity.ShowReadmeOnStart": "true",
            "RunOnceActivity.cidr.known.project.marker": "true",
            "RunOnceActivity.readMode.enableVisualFormatting": "true",
            "android.gradle.sync.needed": "true",
            "cf.first.check.clang-format": "false",
            "cidr.known.project.marker": "true",
            "kotlin-language-version-configured": "true"
          }
        }]]></component>
          <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="application-level" UseSingleDictionary="true" transferred="true" />
          <component name="TaskManager">
            <task active="true" id="Default" summary="Default task">
              <changelist id="227b5e8e-4964-4551-a9b7-59996885aab5" name="Changes" comment="" />
              <created>1727803114577</created>
              <option name="number" value="Default" />
              <option name="presentableId" value="Default" />
              <updated>1727803114577</updated>
            </task>
            <servers />
          </component>
        </project>        ```
    - misc.xml
        ```
        <?xml version="1.0" encoding="UTF-8"?>
        <project version="4">
          <component name="ExternalStorageConfigurationManager" enabled="true" />
          <component name="ProjectRootManager">
            <output url="file://$PROJECT_DIR$/build/classes" />
          </component>
          <component name="ProjectType">
            <option name="id" value="Android" />
          </component>
        </project>        ```
    - **caches/**
        - deviceStreaming.xml
            ```
            <?xml version="1.0" encoding="UTF-8"?>
            <project version="4">
              <component name="DeviceStreaming">
                <option name="deviceSelectionList">
                  <list>
                    <PersistentDeviceSelectionData>
                      <option name="api" value="27" />
                      <option name="brand" value="DOCOMO" />
                      <option name="codename" value="F01L" />
                      <option name="id" value="F01L" />
                      <option name="manufacturer" value="FUJITSU" />
                      <option name="name" value="F-01L" />
                      <option name="screenDensity" value="360" />
                      <option name="screenX" value="720" />
                      <option name="screenY" value="1280" />
                    </PersistentDeviceSelectionData>
                    <PersistentDeviceSelectionData>
                      <option name="api" value="28" />
                      <option name="brand" value="DOCOMO" />
                      <option name="codename" value="SH-01L" />
                      <option name="id" value="SH-01L" />
                      <option name="manufacturer" value="SHARP" />
                      <option name="name" value="AQUOS sense2 SH-01L" />
                      <option name="screenDensity" value="480" />
                      <option name="screenX" value="1080" />
                      <option name="screenY" value="2160" />
                    </PersistentDeviceSelectionData>
                    <PersistentDeviceSelectionData>
                      <option name="api" value="34" />
                      <option name="brand" value="Lenovo" />
                      <option name="codename" value="TB370FU" />
                      <option name="id" value="TB370FU" />
                      <option name="manufacturer" value="Lenovo" />
                      <option name="name" value="Tab P12" />
                      <option name="screenDensity" value="340" />
                      <option name="screenX" value="1840" />
                      <option name="screenY" value="2944" />
                    </PersistentDeviceSelectionData>
                    <PersistentDeviceSelectionData>
                      <option name="api" value="31" />
                      <option name="brand" value="samsung" />
                      <option name="codename" value="a51" />
                      <option name="id" value="a51" />
                      <option name="manufacturer" value="Samsung" />
                      <option name="name" value="Galaxy A51" />
                      <option name="screenDensity" value="420" />
                      <option name="screenX" value="1080" />
                      <option name="screenY" value="2400" />
                    </PersistentDeviceSelectionData>
                    <PersistentDeviceSelectionData>
                      <option name="api" value="34" />
                      <option name="brand" value="google" />
                      <option name="codename" value="akita" />
                      <option name="id" value="akita" />
                      <option name="manufacturer" value="Google" />
                      <option name="name" value="Pixel 8a" />
                      <option name="screenDensity" value="420" />
                      <option name="screenX" value="1080" />
                      <option name="screenY" value="2400" />
                    </PersistentDeviceSelectionData>
                    <PersistentDeviceSelectionData>
                      <option name="api" value="33" />
                      <option name="brand" value="samsung" />
                      <option name="codename" value="b0q" />
                      <option name="id" value="b0q" />
                      <option name="manufacturer" value="Samsung" />
                      <option name="name" value="Galaxy S22 Ultra" />
                      <option name="screenDensity" value="600" />
                      <option name="screenX" value="1440" />
                      <option name="screenY" value="3088" />
                    </PersistentDeviceSelectionData>
                    <PersistentDeviceSelectionData>
                      <option name="api" value="32" />
                      <option name="brand" value="google" />
                      <option name="codename" value="bluejay" />
                      <option name="id" value="bluejay" />
                      <option name="manufacturer" value="Google" />
                      <option name="name" value="Pixel 6a" />
                      <option name="screenDensity" value="420" />
                      <option name="screenX" value="1080" />
                      <option name="screenY" value="2400" />
                    </PersistentDeviceSelectionData>
                    <PersistentDeviceSelectionData>
                      <option name="api" value="34" />
                      <option name="brand" value="google" />
                      <option name="codename" value="caiman" />
                      <option name="id" value="caiman" />
                      <option name="manufacturer" value="Google" />
                      <option name="name" value="Pixel 9 Pro" />
                      <option name="screenDensity" value="360" />
                      <option name="screenX" value="960" />
                      <option name="screenY" value="2142" />
                    </PersistentDeviceSelectionData>
                    <PersistentDeviceSelectionData>
                      <option name="api" value="34" />
                      <option name="brand" value="google" />
                      <option name="codename" value="comet" />
                      <option name="id" value="comet" />
                      <option name="manufacturer" value="Google" />
                      <option name="name" value="Pixel 9 Pro Fold" />
                      <option name="screenDensity" value="390" />
                      <option name="screenX" value="2076" />
                      <option name="screenY" value="2152" />
                    </PersistentDeviceSelectionData>
                    <PersistentDeviceSelectionData>
                      <option name="api" value="29" />
                      <option name="brand" value="samsung" />
                      <option name="codename" value="crownqlteue" />
                      <option name="id" value="crownqlteue" />
                      <option name="manufacturer" value="Samsung" />
                      <option name="name" value="Galaxy Note9" />
                      <option name="screenDensity" value="420" />
                      <option name="screenX" value="2220" />
                      <option name="screenY" value="1080" />
                    </PersistentDeviceSelectionData>
                    <PersistentDeviceSelectionData>
                      <option name="api" value="34" />
                      <option name="brand" value="samsung" />
                      <option name="codename" value="dm3q" />
                      <option name="id" value="dm3q" />
                      <option name="manufacturer" value="Samsung" />
                      <option name="name" value="Galaxy S23 Ultra" />
                      <option name="screenDensity" value="600" />
                      <option name="screenX" value="1440" />
                      <option name="screenY" value="3088" />
                    </PersistentDeviceSelectionData>
                    <PersistentDeviceSelectionData>
                      <option name="api" value="34" />
                      <option name="brand" value="samsung" />
                      <option name="codename" value="e1q" />
                      <option name="id" value="e1q" />
                      <option name="manufacturer" value="Samsung" />
                      <option name="name" value="Galaxy S24" />
                      <option name="screenDensity" value="480" />
                      <option name="screenX" value="1080" />
                      <option name="screenY" value="2340" />
                    </PersistentDeviceSelectionData>
                    <PersistentDeviceSelectionData>
                      <option name="api" value="33" />
                      <option name="brand" value="google" />
                      <option name="codename" value="felix" />
                      <option name="id" value="felix" />
                      <option name="manufacturer" value="Google" />
                      <option name="name" value="Pixel Fold" />
                      <option name="screenDensity" value="420" />
                      <option name="screenX" value="2208" />
                      <option name="screenY" value="1840" />
                    </PersistentDeviceSelectionData>
                    <PersistentDeviceSelectionData>
                      <option name="api" value="34" />
                      <option name="brand" value="google" />
                      <option name="codename" value="felix" />
                      <option name="id" value="felix" />
                      <option name="manufacturer" value="Google" />
                      <option name="name" value="Pixel Fold" />
                      <option name="screenDensity" value="420" />
                      <option name="screenX" value="2208" />
                      <option name="screenY" value="1840" />
                    </PersistentDeviceSelectionData>
                    <PersistentDeviceSelectionData>
                      <option name="api" value="33" />
                      <option name="brand" value="google" />
                      <option name="codename" value="felix_camera" />
                      <option name="id" value="felix_camera" />
                      <option name="manufacturer" value="Google" />
                      <option name="name" value="Pixel Fold (Camera-enabled)" />
                      <option name="screenDensity" value="420" />
                      <option name="screenX" value="2208" />
                      <option name="screenY" value="1840" />
                    </PersistentDeviceSelectionData>
                    <PersistentDeviceSelectionData>
                      <option name="api" value="33" />
                      <option name="brand" value="samsung" />
                      <option name="codename" value="gts8uwifi" />
                      <option name="id" value="gts8uwifi" />
                      <option name="manufacturer" value="Samsung" />
                      <option name="name" value="Galaxy Tab S8 Ultra" />
                      <option name="screenDensity" value="320" />
                      <option name="screenX" value="1848" />
                      <option name="screenY" value="2960" />
                    </PersistentDeviceSelectionData>
                    <PersistentDeviceSelectionData>
                      <option name="api" value="34" />
                      <option name="brand" value="google" />
                      <option name="codename" value="husky" />
                      <option name="id" value="husky" />
                      <option name="manufacturer" value="Google" />
                      <option name="name" value="Pixel 8 Pro" />
                      <option name="screenDensity" value="390" />
                      <option name="screenX" value="1008" />
                      <option name="screenY" value="2244" />
                    </PersistentDeviceSelectionData>
                    <PersistentDeviceSelectionData>
                      <option name="api" value="30" />
                      <option name="brand" value="motorola" />
                      <option name="codename" value="java" />
                      <option name="id" value="java" />
                      <option name="manufacturer" value="Motorola" />
                      <option name="name" value="G20" />
                      <option name="screenDensity" value="280" />
                      <option name="screenX" value="720" />
                      <option name="screenY" value="1600" />
                    </PersistentDeviceSelectionData>
                    <PersistentDeviceSelectionData>
                      <option name="api" value="34" />
                      <option name="brand" value="google" />
                      <option name="codename" value="komodo" />
                      <option name="id" value="komodo" />
                      <option name="manufacturer" value="Google" />
                      <option name="name" value="Pixel 9 Pro XL" />
                      <option name="screenDensity" value="360" />
                      <option name="screenX" value="1008" />
                      <option name="screenY" value="2244" />
                    </PersistentDeviceSelectionData>
                    <PersistentDeviceSelectionData>
                      <option name="api" value="33" />
                      <option name="brand" value="google" />
                      <option name="codename" value="lynx" />
                      <option name="id" value="lynx" />
                      <option name="manufacturer" value="Google" />
                      <option name="name" value="Pixel 7a" />
                      <option name="screenDensity" value="420" />
                      <option name="screenX" value="1080" />
                      <option name="screenY" value="2400" />
                    </PersistentDeviceSelectionData>
                    <PersistentDeviceSelectionData>
                      <option name="api" value="31" />
                      <option name="brand" value="google" />
                      <option name="codename" value="oriole" />
                      <option name="id" value="oriole" />
                      <option name="manufacturer" value="Google" />
                      <option name="name" value="Pixel 6" />
                      <option name="screenDensity" value="420" />
                      <option name="screenX" value="1080" />
                      <option name="screenY" value="2400" />
                    </PersistentDeviceSelectionData>
                    <PersistentDeviceSelectionData>
                      <option name="api" value="33" />
                      <option name="brand" value="google" />
                      <option name="codename" value="panther" />
                      <option name="id" value="panther" />
                      <option name="manufacturer" value="Google" />
                      <option name="name" value="Pixel 7" />
                      <option name="screenDensity" value="420" />
                      <option name="screenX" value="1080" />
                      <option name="screenY" value="2400" />
                    </PersistentDeviceSelectionData>
                    <PersistentDeviceSelectionData>
                      <option name="api" value="34" />
                      <option name="brand" value="samsung" />
                      <option name="codename" value="q5q" />
                      <option name="id" value="q5q" />
                      <option name="manufacturer" value="Samsung" />
                      <option name="name" value="Galaxy Z Fold5" />
                      <option name="screenDensity" value="420" />
                      <option name="screenX" value="1812" />
                      <option name="screenY" value="2176" />
                    </PersistentDeviceSelectionData>
                    <PersistentDeviceSelectionData>
                      <option name="api" value="30" />
                      <option name="brand" value="google" />
                      <option name="codename" value="r11" />
                      <option name="id" value="r11" />
                      <option name="manufacturer" value="Google" />
                      <option name="name" value="Pixel Watch" />
                      <option name="screenDensity" value="320" />
                      <option name="screenX" value="384" />
                      <option name="screenY" value="384" />
                      <option name="type" value="WEAR_OS" />
                    </PersistentDeviceSelectionData>
                    <PersistentDeviceSelectionData>
                      <option name="api" value="30" />
                      <option name="brand" value="google" />
                      <option name="codename" value="redfin" />
                      <option name="id" value="redfin" />
                      <option name="manufacturer" value="Google" />
                      <option name="name" value="Pixel 5" />
                      <option name="screenDensity" value="440" />
                      <option name="screenX" value="1080" />
                      <option name="screenY" value="2340" />
                    </PersistentDeviceSelectionData>
                    <PersistentDeviceSelectionData>
                      <option name="api" value="34" />
                      <option name="brand" value="google" />
                      <option name="codename" value="shiba" />
                      <option name="id" value="shiba" />
                      <option name="manufacturer" value="Google" />
                      <option name="name" value="Pixel 8" />
                      <option name="screenDensity" value="420" />
                      <option name="screenX" value="1080" />
                      <option name="screenY" value="2400" />
                    </PersistentDeviceSelectionData>
                    <PersistentDeviceSelectionData>
                      <option name="api" value="33" />
                      <option name="brand" value="google" />
                      <option name="codename" value="tangorpro" />
                      <option name="id" value="tangorpro" />
                      <option name="manufacturer" value="Google" />
                      <option name="name" value="Pixel Tablet" />
                      <option name="screenDensity" value="320" />
                      <option name="screenX" value="1600" />
                      <option name="screenY" value="2560" />
                    </PersistentDeviceSelectionData>
                    <PersistentDeviceSelectionData>
                      <option name="api" value="34" />
                      <option name="brand" value="google" />
                      <option name="codename" value="tokay" />
                      <option name="id" value="tokay" />
                      <option name="manufacturer" value="Google" />
                      <option name="name" value="Pixel 9" />
                      <option name="screenDensity" value="420" />
                      <option name="screenX" value="1080" />
                      <option name="screenY" value="2424" />
                    </PersistentDeviceSelectionData>
                    <PersistentDeviceSelectionData>
                      <option name="api" value="29" />
                      <option name="brand" value="samsung" />
                      <option name="codename" value="x1q" />
                      <option name="id" value="x1q" />
                      <option name="manufacturer" value="Samsung" />
                      <option name="name" value="Galaxy S20" />
                      <option name="screenDensity" value="480" />
                      <option name="screenX" value="1440" />
                      <option name="screenY" value="3200" />
                    </PersistentDeviceSelectionData>
                  </list>
                </option>
              </component>
            </project>            ```
- **src/**
    - **androidTest/**
        - **java/**
            - **com/**
                - **isis3510/**
                    - **spendiq/**
                        - ExampleInstrumentedTest.kt
                            ```
                            package com.isis3510.spendiq
                            
                            import androidx.test.platform.app.InstrumentationRegistry
                            import androidx.test.ext.junit.runners.AndroidJUnit4
                            
                            import org.junit.Test
                            import org.junit.runner.RunWith
                            
                            import org.junit.Assert.*
                            
                            /**
                             * Instrumented test, which will execute on an Android device.
                             *
                             * See [testing documentation](http://d.android.com/tools/testing).
                             */
                            @RunWith(AndroidJUnit4::class)
                            class ExampleInstrumentedTest {
                                @Test
                                fun useAppContext() {
                                    // Context of the app under test.
                                    val appContext = InstrumentationRegistry.getInstrumentation().targetContext
                                    assertEquals("com.isis3510.spendiq", appContext.packageName)
                                }
                            }                            ```
    - **test/**
        - **java/**
            - **com/**
                - **isis3510/**
                    - **spendiq/**
                        - ExampleUnitTest.kt
                            ```
                            package com.isis3510.spendiq
                            
                            import org.junit.Test
                            
                            import org.junit.Assert.*
                            
                            /**
                             * Example local unit test, which will execute on the development machine (host).
                             *
                             * See [testing documentation](http://d.android.com/tools/testing).
                             */
                            class ExampleUnitTest {
                                @Test
                                fun addition_isCorrect() {
                                    assertEquals(4, 2 + 2)
                                }
                            }                            ```
    - **main/**
        - **res/**
            - **mipmap-mdpi/**
                - ic_launcher.webp
                    ```
                    Error reading file: 'utf-8' codec can't decode byte 0xc0 in position 22: invalid start byte
                - ic_launcher_round.webp
                    ```
                    Error reading file: 'utf-8' codec can't decode byte 0xaa in position 4: invalid start byte
                - ic_launcher_foreground.webp
                    ```
                    Error reading file: 'utf-8' codec can't decode byte 0xfa in position 4: invalid start byte
            - **mipmap-hdpi/**
                - ic_launcher.webp
                    ```
                    Error reading file: 'utf-8' codec can't decode byte 0xc0 in position 22: invalid start byte
                - ic_launcher_round.webp
                    ```
                    Error reading file: 'utf-8' codec can't decode byte 0xb2 in position 4: invalid start byte
                - ic_launcher_foreground.webp
                    ```
                    Error reading file: 'utf-8' codec can't decode byte 0xa1 in position 21: invalid start byte
            - **drawable/**
                - arrowup24.xml
                    ```
                    <vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#000000" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
                          
                        <path android:fillColor="@android:color/white" android:pathData="M7,14l5,-5 5,5z"/>
                        
                    </vector>
                    ```
                - round_star_24.xml
                    ```
                    <vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
                          
                        <path android:fillColor="@android:color/white" android:pathData="M19.65,9.04l-4.84,-0.42 -1.89,-4.45c-0.34,-0.81 -1.5,-0.81 -1.84,0L9.19,8.63l-4.83,0.41c-0.88,0.07 -1.24,1.17 -0.57,1.75l3.67,3.18 -1.1,4.72c-0.2,0.86 0.73,1.54 1.49,1.08l4.15,-2.5 4.15,2.51c0.76,0.46 1.69,-0.22 1.49,-1.08l-1.1,-4.73 3.67,-3.18c0.67,-0.58 0.32,-1.68 -0.56,-1.75zM12,15.4l-3.76,2.27 1,-4.28 -3.32,-2.88 4.38,-0.38L12,6.1l1.71,4.04 4.38,0.38 -3.32,2.88 1,4.28L12,15.4z"/>
                        
                    </vector>
                    ```
                - round_equalizer_24.xml
                    ```
                    <vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
                          
                        <path android:fillColor="@android:color/white" android:pathData="M12,20c1.1,0 2,-0.9 2,-2L14,6c0,-1.1 -0.9,-2 -2,-2s-2,0.9 -2,2v12c0,1.1 0.9,2 2,2zM6,20c1.1,0 2,-0.9 2,-2v-4c0,-1.1 -0.9,-2 -2,-2s-2,0.9 -2,2v4c0,1.1 0.9,2 2,2zM16,11v7c0,1.1 0.9,2 2,2s2,-0.9 2,-2v-7c0,-1.1 -0.9,-2 -2,-2s-2,0.9 -2,2z"/>
                        
                    </vector>
                    ```
                - baseline_notifications_24.xml
                    ```
                    <vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
                          
                        <path android:fillColor="@android:color/white" android:pathData="M12,22c1.1,0 2,-0.9 2,-2h-4c0,1.1 0.89,2 2,2zM18,16v-5c0,-3.07 -1.64,-5.64 -4.5,-6.32L13.5,4c0,-0.83 -0.67,-1.5 -1.5,-1.5s-1.5,0.67 -1.5,1.5v0.68C7.63,5.36 6,7.92 6,11v5l-2,2v1h16v-1l-2,-2z"/>
                        
                    </vector>
                    ```
                - logogroupstart.png
                    ```
                    Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
                - calendar24.xml
                    ```
                    <vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#000000" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
                          
                        <path android:fillColor="@android:color/white" android:pathData="M19,4h-1V2h-2v2H8V2H6v2H5C3.89,4 3.01,4.9 3.01,6L3,20c0,1.1 0.89,2 2,2h14c1.1,0 2,-0.9 2,-2V6C21,4.9 20.1,4 19,4zM19,20H5V10h14V20zM9,14H7v-2h2V14zM13,14h-2v-2h2V14zM17,14h-2v-2h2V14zM9,18H7v-2h2V18zM13,18h-2v-2h2V18zM17,18h-2v-2h2V18z"/>
                        
                    </vector>
                    ```
                - round_money_24.xml
                    ```
                    <vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
                          
                        <path android:fillColor="@android:color/white" android:pathData="M11.8,10.9c-2.27,-0.59 -3,-1.2 -3,-2.15 0,-1.09 1.01,-1.85 2.7,-1.85 1.42,0 2.13,0.54 2.39,1.4 0.12,0.4 0.45,0.7 0.87,0.7h0.3c0.66,0 1.13,-0.65 0.9,-1.27 -0.42,-1.18 -1.4,-2.16 -2.96,-2.54V4.5c0,-0.83 -0.67,-1.5 -1.5,-1.5S10,3.67 10,4.5v0.66c-1.94,0.42 -3.5,1.68 -3.5,3.61 0,2.31 1.91,3.46 4.7,4.13 2.5,0.6 3,1.48 3,2.41 0,0.69 -0.49,1.79 -2.7,1.79 -1.65,0 -2.5,-0.59 -2.83,-1.43 -0.15,-0.39 -0.49,-0.67 -0.9,-0.67h-0.28c-0.67,0 -1.14,0.68 -0.89,1.3 0.57,1.39 1.9,2.21 3.4,2.53v0.67c0,0.83 0.67,1.5 1.5,1.5s1.5,-0.67 1.5,-1.5v-0.65c1.95,-0.37 3.5,-1.5 3.5,-3.55 0,-2.84 -2.43,-3.81 -4.7,-4.4z"/>
                        
                    </vector>
                    ```
                - round_arrow_forward_ios_24.xml
                    ```
                    <vector xmlns:android="http://schemas.android.com/apk/res/android" android:autoMirrored="true" android:height="24dp" android:tint="#000000" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
                          
                        <path android:fillColor="@android:color/white" android:pathData="M7.38,21.01c0.49,0.49 1.28,0.49 1.77,0l8.31,-8.31c0.39,-0.39 0.39,-1.02 0,-1.41L9.15,2.98c-0.49,-0.49 -1.28,-0.49 -1.77,0s-0.49,1.28 0,1.77L14.62,12l-7.25,7.25c-0.48,0.48 -0.48,1.28 0.01,1.76z"/>
                        
                    </vector>
                    ```
                - phone24.xml
                    ```
                    <vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#000000" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
                          
                        <path android:fillColor="@android:color/white" android:pathData="M6.62,10.79c1.44,2.83 3.76,5.14 6.59,6.59l2.2,-2.2c0.27,-0.27 0.67,-0.36 1.02,-0.24 1.12,0.37 2.33,0.57 3.57,0.57 0.55,0 1,0.45 1,1V20c0,0.55 -0.45,1 -1,1 -9.39,0 -17,-7.61 -17,-17 0,-0.55 0.45,-1 1,-1h3.5c0.55,0 1,0.45 1,1 0,1.25 0.2,2.45 0.57,3.57 0.11,0.35 0.03,0.74 -0.25,1.02l-2.2,2.2z"/>
                        
                    </vector>
                    ```
                - email24.xml
                    ```
                    <vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#000000" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
                          
                        <path android:fillColor="@android:color/white" android:pathData="M20,4L4,4c-1.1,0 -1.99,0.9 -1.99,2L2,18c0,1.1 0.9,2 2,2h16c1.1,0 2,-0.9 2,-2L22,6c0,-1.1 -0.9,-2 -2,-2zM20,8l-8,5 -8,-5L4,6l8,5 8,-5v2z"/>
                        
                    </vector>
                    ```
                - leftactionable.png
                    ```
                    Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
                - outline_question_mark_24.xml
                    ```
                    <vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
                          
                        <path android:fillColor="@android:color/white" android:pathData="M11.07,12.85c0.77,-1.39 2.25,-2.21 3.11,-3.44c0.91,-1.29 0.4,-3.7 -2.18,-3.7c-1.69,0 -2.52,1.28 -2.87,2.34L6.54,6.96C7.25,4.83 9.18,3 11.99,3c2.35,0 3.96,1.07 4.78,2.41c0.7,1.15 1.11,3.3 0.03,4.9c-1.2,1.77 -2.35,2.31 -2.97,3.45c-0.25,0.46 -0.35,0.76 -0.35,2.24h-2.89C10.58,15.22 10.46,13.95 11.07,12.85zM14,20c0,1.1 -0.9,2 -2,2s-2,-0.9 -2,-2c0,-1.1 0.9,-2 2,-2S14,18.9 14,20z"/>
                        
                    </vector>
                    ```
                - rounded_gifts_24.xml
                    ```
                    <vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="960" android:viewportWidth="960" android:width="24dp">
                          
                        <path android:fillColor="@android:color/white" android:pathData="M160,800L160,440L160,440Q127,440 103.5,416.5Q80,393 80,360L80,280Q80,247 103.5,223.5Q127,200 160,200L288,200Q283,191 281.5,181Q280,171 280,160Q280,110 315,75Q350,40 400,40Q423,40 443,48.5Q463,57 480,72Q497,56 517,48Q537,40 560,40Q610,40 645,75Q680,110 680,160Q680,171 678,180.5Q676,190 672,200L800,200Q833,200 856.5,223.5Q880,247 880,280L880,360Q880,393 856.5,416.5Q833,440 800,440L800,440L800,800Q800,833 776.5,856.5Q753,880 720,880L240,880Q207,880 183.5,856.5Q160,833 160,800ZM560,120Q543,120 531.5,131.5Q520,143 520,160Q520,177 531.5,188.5Q543,200 560,200Q577,200 588.5,188.5Q600,177 600,160Q600,143 588.5,131.5Q577,120 560,120ZM360,160Q360,177 371.5,188.5Q383,200 400,200Q417,200 428.5,188.5Q440,177 440,160Q440,143 428.5,131.5Q417,120 400,120Q383,120 371.5,131.5Q360,143 360,160ZM160,280L160,360L440,360L440,280L160,280ZM440,800L440,440L240,440L240,800Q240,800 240,800Q240,800 240,800L440,800ZM520,800L720,800Q720,800 720,800Q720,800 720,800L720,440L520,440L520,800ZM800,360L800,280L520,280L520,360L800,360Z"/>
                        
                    </vector>
                    ```
                - round_lightbulb_24.xml
                    ```
                    <vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
                          
                        <path android:fillColor="@android:color/white" android:pathData="M9,21c0,0.55 0.45,1 1,1h4c0.55,0 1,-0.45 1,-1v-1L9,20v1zM12,2C8.14,2 5,5.14 5,9c0,2.38 1.19,4.47 3,5.74L8,17c0,0.55 0.45,1 1,1h6c0.55,0 1,-0.45 1,-1v-2.26c1.81,-1.27 3,-3.36 3,-5.74 0,-3.86 -3.14,-7 -7,-7zM14.85,13.1l-0.85,0.6L14,16h-4v-2.3l-0.85,-0.6C7.8,12.16 7,10.63 7,9c0,-2.76 2.24,-5 5,-5s5,2.24 5,5c0,1.63 -0.8,3.16 -2.15,4.1z"/>
                        
                    </vector>
                    ```
                - ic_launcher_foreground.xml
                    ```
                    <vector xmlns:android="http://schemas.android.com/apk/res/android"
                        xmlns:aapt="http://schemas.android.com/aapt"
                        android:width="108dp"
                        android:height="108dp"
                        android:viewportWidth="108"
                        android:viewportHeight="108">
                        <path android:pathData="M31,63.928c0,0 6.4,-11 12.1,-13.1c7.2,-2.6 26,-1.4 26,-1.4l38.1,38.1L107,108.928l-32,-1L31,63.928z">
                            <aapt:attr name="android:fillColor">
                                <gradient
                                    android:endX="85.84757"
                                    android:endY="92.4963"
                                    android:startX="42.9492"
                                    android:startY="49.59793"
                                    android:type="linear">
                                    <item
                                        android:color="#44000000"
                                        android:offset="0.0" />
                                    <item
                                        android:color="#00000000"
                                        android:offset="1.0" />
                                </gradient>
                            </aapt:attr>
                        </path>
                        <path
                            android:fillColor="#FFFFFF"
                            android:fillType="nonZero"
                            android:pathData="M65.3,45.828l3.8,-6.6c0.2,-0.4 0.1,-0.9 -0.3,-1.1c-0.4,-0.2 -0.9,-0.1 -1.1,0.3l-3.9,6.7c-6.3,-2.8 -13.4,-2.8 -19.7,0l-3.9,-6.7c-0.2,-0.4 -0.7,-0.5 -1.1,-0.3C38.8,38.328 38.7,38.828 38.9,39.228l3.8,6.6C36.2,49.428 31.7,56.028 31,63.928h46C76.3,56.028 71.8,49.428 65.3,45.828zM43.4,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2c-0.3,-0.7 -0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C45.3,56.528 44.5,57.328 43.4,57.328L43.4,57.328zM64.6,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2s-0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C66.5,56.528 65.6,57.328 64.6,57.328L64.6,57.328z"
                            android:strokeWidth="1"
                            android:strokeColor="#00000000" />
                    </vector>                    ```
                - round_visibility_24.xml
                    ```
                    <vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
                          
                        <path android:fillColor="@android:color/white" android:pathData="M12,4C7,4 2.73,7.11 1,11.5 2.73,15.89 7,19 12,19s9.27,-3.11 11,-7.5C21.27,7.11 17,4 12,4zM12,16.5c-2.76,0 -5,-2.24 -5,-5s2.24,-5 5,-5 5,2.24 5,5 -2.24,5 -5,5zM12,8.5c-1.66,0 -3,1.34 -3,3s1.34,3 3,3 3,-1.34 3,-3 -1.34,-3 -3,-3z"/>
                        
                    </vector>
                    ```
                - arrowdown24.xml
                    ```
                    <vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#000000" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
                          
                        <path android:fillColor="@android:color/white" android:pathData="M7,10l5,5 5,-5z"/>
                        
                    </vector>
                    ```
                - logoup.png
                    ```
                    Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
                - logo_log_in.png
                    ```
                    Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
                - fingerprint.png
                    ```
                    Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
                - logodown.png
                    ```
                    Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
                - baseline_edit_24.xml
                    ```
                    <vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
                          
                        <path android:fillColor="@android:color/white" android:pathData="M3,17.25V21h3.75L17.81,9.94l-3.75,-3.75L3,17.25zM20.71,7.04c0.39,-0.39 0.39,-1.02 0,-1.41l-2.34,-2.34c-0.39,-0.39 -1.02,-0.39 -1.41,0l-1.83,1.83 3.75,3.75 1.83,-1.83z"/>
                        
                    </vector>
                    ```
                - baseline_shield_24.xml
                    ```
                    <vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
                          
                        <path android:fillColor="@android:color/white" android:pathData="M12,1L3,5v6c0,5.55 3.84,10.74 9,12 5.16,-1.26 9,-6.45 9,-12V5l-9,-4z"/>
                        
                    </vector>
                    ```
                - person24.xml
                    ```
                    <vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
                          
                        <path android:fillColor="@android:color/white" android:pathData="M12,12c2.21,0 4,-1.79 4,-4s-1.79,-4 -4,-4 -4,1.79 -4,4 1.79,4 4,4zM12,14c-2.67,0 -8,1.34 -8,4v2h16v-2c0,-2.66 -5.33,-4 -8,-4z"/>
                        
                    </vector>
                    ```
                - round_arrow_back_ios_24.xml
                    ```
                    <vector xmlns:android="http://schemas.android.com/apk/res/android" android:autoMirrored="true" android:height="24dp" android:tint="#000000" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
                          
                        <path android:fillColor="@android:color/white" android:pathData="M16.62,2.99c-0.49,-0.49 -1.28,-0.49 -1.77,0L6.54,11.3c-0.39,0.39 -0.39,1.02 0,1.41l8.31,8.31c0.49,0.49 1.28,0.49 1.77,0s0.49,-1.28 0,-1.77L9.38,12l7.25,-7.25c0.48,-0.48 0.48,-1.28 -0.01,-1.76z"/>
                        
                    </vector>
                    ```
                - baseline_adjust_24.xml
                    ```
                    <vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
                          
                        <path android:fillColor="@android:color/white" android:pathData="M12,2C6.49,2 2,6.49 2,12s4.49,10 10,10 10,-4.49 10,-10S17.51,2 12,2zM12,20c-4.41,0 -8,-3.59 -8,-8s3.59,-8 8,-8 8,3.59 8,8 -3.59,8 -8,8zM15,12c0,1.66 -1.34,3 -3,3s-3,-1.34 -3,-3 1.34,-3 3,-3 3,1.34 3,3z"/>
                        
                    </vector>
                    ```
                - baseline_add_a_photo_24.xml
                    ```
                    <vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="64dp" android:tint="#000000" android:viewportHeight="24" android:viewportWidth="24" android:width="64dp">
                          
                        <path android:fillColor="@android:color/white" android:pathData="M3,4V1h2v3h3v2H5v3H3V6H0V4H3zM6,10V7h3V4h7l1.83,2H21c1.1,0 2,0.9 2,2v12c0,1.1 -0.9,2 -2,2H5c-1.1,0 -2,-0.9 -2,-2V10H6zM13,19c2.76,0 5,-2.24 5,-5s-2.24,-5 -5,-5s-5,2.24 -5,5S10.24,19 13,19zM9.8,14c0,1.77 1.43,3.2 3.2,3.2s3.2,-1.43 3.2,-3.2s-1.43,-3.2 -3.2,-3.2S9.8,12.23 9.8,14z"/>
                        
                    </vector>
                    ```
                - outline_giftcard_24.xml
                    ```
                    <vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
                          
                        <path android:fillColor="@android:color/white" android:pathData="M20,6h-2.18c0.11,-0.31 0.18,-0.65 0.18,-1 0,-1.66 -1.34,-3 -3,-3 -1.05,0 -1.96,0.54 -2.5,1.35l-0.5,0.67 -0.5,-0.68C10.96,2.54 10.05,2 9,2 7.34,2 6,3.34 6,5c0,0.35 0.07,0.69 0.18,1L4,6c-1.11,0 -1.99,0.89 -1.99,2L2,19c0,1.11 0.89,2 2,2h16c1.11,0 2,-0.89 2,-2L22,8c0,-1.11 -0.89,-2 -2,-2zM15,4c0.55,0 1,0.45 1,1s-0.45,1 -1,1 -1,-0.45 -1,-1 0.45,-1 1,-1zM9,4c0.55,0 1,0.45 1,1s-0.45,1 -1,1 -1,-0.45 -1,-1 0.45,-1 1,-1zM20,19L4,19v-2h16v2zM20,14L4,14L4,8h5.08L7,10.83 8.62,12 12,7.4l3.38,4.6L17,10.83 14.92,8L20,8v6z"/>
                        
                    </vector>
                    ```
                - location.xml
                    ```
                    <?xml version="1.0" encoding="utf-8"?>
                    <selector xmlns:android="http://schemas.android.com/apk/res/android">
                        <svg width="14" height="19" viewBox="0 0 14 19" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M6.2806 18.2901C0.983281 10.6105 0 9.82235 0 7C0 3.134 3.13399 0 7 0C10.866 0 14 3.134 14 7C14 9.82235 13.0167 10.6105 7.7194 18.2901C7.37177 18.7922 6.6282 18.7922 6.2806 18.2901ZM7 9.91667C8.61084 9.91667 9.91667 8.61084 9.91667 7C9.91667 5.38916 8.61084 4.08333 7 4.08333C5.38916 4.08333 4.08333 5.38916 4.08333 7C4.08333 8.61084 5.38916 9.91667 7 9.91667Z" fill="#868686"/>
                        </svg>
                    
                    </selector>                    ```
                - home24.xml
                    ```
                    <vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#000000" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
                          
                        <path android:fillColor="@android:color/white" android:pathData="M10,20v-6h4v6h5v-8h3L12,3 2,12h3v8z"/>
                        
                    </vector>
                    ```
                - add24.xml
                    ```
                    <vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#000000" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
                          
                        <path android:fillColor="@android:color/white" android:pathData="M19,13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
                        
                    </vector>
                    ```
                - baseline_location_pin_24.xml
                    ```
                    <vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#868686" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
                          
                        <path android:fillColor="@android:color/white" android:pathData="M12,2L12,2C8.13,2 5,5.13 5,9c0,1.74 0.5,3.37 1.41,4.84c0.95,1.54 2.2,2.86 3.16,4.4c0.47,0.75 0.81,1.45 1.17,2.26C11,21.05 11.21,22 12,22h0c0.79,0 1,-0.95 1.25,-1.5c0.37,-0.81 0.7,-1.51 1.17,-2.26c0.96,-1.53 2.21,-2.85 3.16,-4.4C18.5,12.37 19,10.74 19,9C19,5.13 15.87,2 12,2zM12,11.75c-1.38,0 -2.5,-1.12 -2.5,-2.5s1.12,-2.5 2.5,-2.5s2.5,1.12 2.5,2.5S13.38,11.75 12,11.75z"/>
                        
                    </vector>
                    ```
                - baseline_map_24.xml
                    ```
                    <vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#000000" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
                          
                        <path android:fillColor="@android:color/white" android:pathData="M20.5,3l-0.16,0.03L15,5.1 9,3 3.36,4.9c-0.21,0.07 -0.36,0.25 -0.36,0.48V20.5c0,0.28 0.22,0.5 0.5,0.5l0.16,-0.03L9,18.9l6,2.1 5.64,-1.9c0.21,-0.07 0.36,-0.25 0.36,-0.48V3.5c0,-0.28 -0.22,-0.5 -0.5,-0.5zM15,19l-6,-2.11V5l6,2.11V19z"/>
                        
                    </vector>
                    ```
                - gift24.xml
                    ```
                    <vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#000000" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
                          
                        <path android:fillColor="@android:color/white" android:pathData="M20,6h-2.18c0.11,-0.31 0.18,-0.65 0.18,-1 0,-1.66 -1.34,-3 -3,-3 -1.05,0 -1.96,0.54 -2.5,1.35l-0.5,0.67 -0.5,-0.68C10.96,2.54 10.05,2 9,2 7.34,2 6,3.34 6,5c0,0.35 0.07,0.69 0.18,1L4,6c-1.11,0 -1.99,0.89 -1.99,2L2,19c0,1.11 0.89,2 2,2h16c1.11,0 2,-0.89 2,-2L22,8c0,-1.11 -0.89,-2 -2,-2zM15,4c0.55,0 1,0.45 1,1s-0.45,1 -1,1 -1,-0.45 -1,-1 0.45,-1 1,-1zM9,4c0.55,0 1,0.45 1,1s-0.45,1 -1,1 -1,-0.45 -1,-1 0.45,-1 1,-1zM20,19L4,19v-2h16v2zM20,14L4,14L4,8h5.08L7,10.83 8.62,12 11,8.76l1,-1.36 1,1.36L15.38,12 17,10.83 14.92,8L20,8v6z"/>
                        
                    </vector>
                    ```
                - rounded_home_24.xml
                    ```
                    <vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="960" android:viewportWidth="960" android:width="24dp">
                          
                        <path android:fillColor="@android:color/white" android:pathData="M240,760L360,760L360,560Q360,543 371.5,531.5Q383,520 400,520L560,520Q577,520 588.5,531.5Q600,543 600,560L600,760L720,760L720,400Q720,400 720,400Q720,400 720,400L480,220Q480,220 480,220Q480,220 480,220L240,400Q240,400 240,400Q240,400 240,400L240,760ZM160,760L160,400Q160,381 168.5,364Q177,347 192,336L432,156Q453,140 480,140Q507,140 528,156L768,336Q783,347 791.5,364Q800,381 800,400L800,760Q800,793 776.5,816.5Q753,840 720,840L560,840Q543,840 531.5,828.5Q520,817 520,800L520,600Q520,600 520,600Q520,600 520,600L440,600Q440,600 440,600Q440,600 440,600L440,800Q440,817 428.5,828.5Q417,840 400,840L240,840Q207,840 183.5,816.5Q160,793 160,760ZM480,490L480,490L480,490Q480,490 480,490Q480,490 480,490L480,490L480,490L480,490L480,490Q480,490 480,490Q480,490 480,490L480,490Q480,490 480,490Q480,490 480,490L480,490Z"/>
                        
                    </vector>
                    ```
                - notification.xml
                    ```
                    <vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#000000" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
                          
                        <path android:fillColor="@android:color/white" android:pathData="M12,22c1.1,0 2,-0.9 2,-2h-4c0,1.1 0.89,2 2,2zM18,16v-5c0,-3.07 -1.64,-5.64 -4.5,-6.32L13.5,4c0,-0.83 -0.67,-1.5 -1.5,-1.5s-1.5,0.67 -1.5,1.5v0.68C7.63,5.36 6,7.92 6,11v5l-2,2v1h16v-1l-2,-2z"/>
                        
                    </vector>
                    ```
                - round_calendar_today_24.xml
                    ```
                    <vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
                          
                        <path android:fillColor="@android:color/white" android:pathData="M20,3h-1L19,2c0,-0.55 -0.45,-1 -1,-1s-1,0.45 -1,1v1L7,3L7,2c0,-0.55 -0.45,-1 -1,-1s-1,0.45 -1,1v1L4,3c-1.1,0 -2,0.9 -2,2v16c0,1.1 0.9,2 2,2h16c1.1,0 2,-0.9 2,-2L22,5c0,-1.1 -0.9,-2 -2,-2zM19,21L5,21c-0.55,0 -1,-0.45 -1,-1L4,8h16v12c0,0.55 -0.45,1 -1,1z"/>
                        
                    </vector>
                    ```
                - sharp_info_outline_24.xml
                    ```
                    <vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
                          
                        <path android:fillColor="@android:color/white" android:pathData="M11,17h2v-6h-2v6zM12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM12,20c-4.41,0 -8,-3.59 -8,-8s3.59,-8 8,-8 8,3.59 8,8 -3.59,8 -8,8zM11,9h2L13,7h-2v2z"/>
                          
                        <path android:fillColor="@android:color/white" android:pathData="M11,7h2v2h-2zM11,11h2v6h-2z"/>
                          
                        <path android:fillColor="@android:color/white" android:pathData="M12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM12,20c-4.41,0 -8,-3.59 -8,-8s3.59,-8 8,-8 8,3.59 8,8 -3.59,8 -8,8z"/>
                        
                    </vector>
                    ```
                - round_clock_24.xml
                    ```
                    <vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
                    
                        <path android:fillColor="@android:color/white" android:pathData="M11.99,2C6.47,2 2,6.48 2,12s4.47,10 9.99,10C17.52,22 22,17.52 22,12S17.52,2 11.99,2zM12,20c-4.42,0 -8,-3.58 -8,-8s3.58,-8 8,-8 8,3.58 8,8 -3.58,8 -8,8zM11.78,7h-0.06c-0.4,0 -0.72,0.32 -0.72,0.72v4.72c0,0.35 0.18,0.68 0.49,0.86l4.15,2.49c0.34,0.2 0.78,0.1 0.98,-0.24 0.21,-0.34 0.1,-0.79 -0.25,-0.99l-3.87,-2.3L12.5,7.72c0,-0.4 -0.32,-0.72 -0.72,-0.72z"/>
                    
                    </vector>
                    ```
                - ic_launcher_background.xml
                    ```
                    <?xml version="1.0" encoding="utf-8"?>
                    <vector
                        android:height="108dp"
                        android:width="108dp"
                        android:viewportHeight="108"
                        android:viewportWidth="108"
                        xmlns:android="http://schemas.android.com/apk/res/android">
                        <path android:fillColor="#3DDC84"
                              android:pathData="M0,0h108v108h-108z"/>
                        <path android:fillColor="#00000000" android:pathData="M9,0L9,108"
                              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
                        <path android:fillColor="#00000000" android:pathData="M19,0L19,108"
                              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
                        <path android:fillColor="#00000000" android:pathData="M29,0L29,108"
                              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
                        <path android:fillColor="#00000000" android:pathData="M39,0L39,108"
                              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
                        <path android:fillColor="#00000000" android:pathData="M49,0L49,108"
                              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
                        <path android:fillColor="#00000000" android:pathData="M59,0L59,108"
                              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
                        <path android:fillColor="#00000000" android:pathData="M69,0L69,108"
                              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
                        <path android:fillColor="#00000000" android:pathData="M79,0L79,108"
                              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
                        <path android:fillColor="#00000000" android:pathData="M89,0L89,108"
                              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
                        <path android:fillColor="#00000000" android:pathData="M99,0L99,108"
                              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
                        <path android:fillColor="#00000000" android:pathData="M0,9L108,9"
                              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
                        <path android:fillColor="#00000000" android:pathData="M0,19L108,19"
                              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
                        <path android:fillColor="#00000000" android:pathData="M0,29L108,29"
                              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
                        <path android:fillColor="#00000000" android:pathData="M0,39L108,39"
                              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
                        <path android:fillColor="#00000000" android:pathData="M0,49L108,49"
                              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
                        <path android:fillColor="#00000000" android:pathData="M0,59L108,59"
                              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
                        <path android:fillColor="#00000000" android:pathData="M0,69L108,69"
                              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
                        <path android:fillColor="#00000000" android:pathData="M0,79L108,79"
                              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
                        <path android:fillColor="#00000000" android:pathData="M0,89L108,89"
                              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
                        <path android:fillColor="#00000000" android:pathData="M0,99L108,99"
                              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
                        <path android:fillColor="#00000000" android:pathData="M19,29L89,29"
                              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
                        <path android:fillColor="#00000000" android:pathData="M19,39L89,39"
                              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
                        <path android:fillColor="#00000000" android:pathData="M19,49L89,49"
                              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
                        <path android:fillColor="#00000000" android:pathData="M19,59L89,59"
                              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
                        <path android:fillColor="#00000000" android:pathData="M19,69L89,69"
                              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
                        <path android:fillColor="#00000000" android:pathData="M19,79L89,79"
                              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
                        <path android:fillColor="#00000000" android:pathData="M29,19L29,89"
                              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
                        <path android:fillColor="#00000000" android:pathData="M39,19L39,89"
                              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
                        <path android:fillColor="#00000000" android:pathData="M49,19L49,89"
                              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
                        <path android:fillColor="#00000000" android:pathData="M59,19L59,89"
                              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
                        <path android:fillColor="#00000000" android:pathData="M69,19L69,89"
                              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
                        <path android:fillColor="#00000000" android:pathData="M79,19L79,89"
                              android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
                    </vector>
                    ```
                - creditcard24.xml
                    ```
                    <vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#000000" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
                          
                        <path android:fillColor="@android:color/white" android:pathData="M20,4L4,4c-1.11,0 -1.99,0.89 -1.99,2L2,18c0,1.11 0.89,2 2,2h16c1.11,0 2,-0.89 2,-2L22,6c0,-1.11 -0.89,-2 -2,-2zM20,18L4,18v-6h16v6zM20,8L4,8L4,6h16v2z"/>
                        
                    </vector>
                    ```
                - baseline_visibility_off_24.xml
                    ```
                    <vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
                          
                        <path android:fillColor="@android:color/white" android:pathData="M12,7c2.76,0 5,2.24 5,5 0,0.65 -0.13,1.26 -0.36,1.83l2.92,2.92c1.51,-1.26 2.7,-2.89 3.43,-4.75 -1.73,-4.39 -6,-7.5 -11,-7.5 -1.4,0 -2.74,0.25 -3.98,0.7l2.16,2.16C10.74,7.13 11.35,7 12,7zM2,4.27l2.28,2.28 0.46,0.46C3.08,8.3 1.78,10.02 1,12c1.73,4.39 6,7.5 11,7.5 1.55,0 3.03,-0.3 4.38,-0.84l0.42,0.42L19.73,22 21,20.73 3.27,3 2,4.27zM7.53,9.8l1.55,1.55c-0.05,0.21 -0.08,0.43 -0.08,0.65 0,1.66 1.34,3 3,3 0.22,0 0.44,-0.03 0.65,-0.08l1.55,1.55c-0.67,0.33 -1.41,0.53 -2.2,0.53 -2.76,0 -5,-2.24 -5,-5 0,-0.79 0.2,-1.53 0.53,-2.2zM11.84,9.02l3.15,3.15 0.02,-0.16c0,-1.66 -1.34,-3 -3,-3l-0.17,0.01z"/>
                        
                    </vector>
                    ```
            - **mipmap-xxxhdpi/**
                - ic_launcher.webp
                    ```
                    Error reading file: 'utf-8' codec can't decode byte 0xbf in position 21: invalid start byte
                - ic_launcher_round.webp
                    ```
                    Error reading file: 'utf-8' codec can't decode byte 0xec in position 4: invalid continuation byte
                - ic_launcher_foreground.webp
                    ```
                    Error reading file: 'utf-8' codec can't decode byte 0x82 in position 4: invalid start byte
            - **mipmap-xxhdpi/**
                - ic_launcher.webp
                    ```
                    Error reading file: 'utf-8' codec can't decode byte 0xfa in position 16: invalid start byte
                - ic_launcher_round.webp
                    ```
                    Error reading file: 'utf-8' codec can't decode byte 0xff in position 16: invalid start byte
                - ic_launcher_foreground.webp
                    ```
                    Error reading file: 'utf-8' codec can't decode byte 0xc1 in position 22: invalid start byte
            - **values/**
                - colors.xml
                    ```
                    <?xml version="1.0" encoding="utf-8"?>
                    <resources>
                        <color name="purple_200">#FFBB86FC</color>
                        <color name="purple_500">#FF6200EE</color>
                        <color name="purple_700">#FF3700B3</color>
                        <color name="teal_200">#FF03DAC5</color>
                        <color name="teal_700">#FF018786</color>
                        <color name="black">#FF000000</color>
                        <color name="white">#FFFFFFFF</color>
                        <color name="lavender">#8692f7</color>
                        <color name="grey">#ff424242</color>
                        <color name="greenSpendiQ">#B3CB54</color>
                        <color name="pinkSpendiQ">#C33BA5</color>
                    </resources>                    ```
                - themes.xml
                    ```
                    <?xml version="1.0" encoding="utf-8"?>
                    <resources>
                    
                        <style name="Theme.SpendiQ" parent="android:Theme.Material.Light.NoActionBar" />
                    </resources>                    ```
                - strings.xml
                    ```
                    <resources>
                        <string name="app_name">SpendiQ</string>
                    </resources>                    ```
            - **xml/**
                - backup_rules.xml
                    ```
                    <?xml version="1.0" encoding="utf-8"?><!--
                       Sample backup rules file; uncomment and customize as necessary.
                       See https://developer.android.com/guide/topics/data/autobackup
                       for details.
                       Note: This file is ignored for devices older that API 31
                       See https://developer.android.com/about/versions/12/backup-restore
                    -->
                    <full-backup-content>
                        <!--
                       <include domain="sharedpref" path="."/>
                       <exclude domain="sharedpref" path="device.xml"/>
                    -->
                    </full-backup-content>                    ```
                - network_security_config.xml
                    ```
                    <?xml version="1.0" encoding="utf-8"?>
                    <network-security-config>
                        <domain-config cleartextTrafficPermitted="true">
                            <domain includeSubdomains="true">148.113.204.223</domain>
                        </domain-config>
                    </network-security-config>
                    ```
                - data_extraction_rules.xml
                    ```
                    <?xml version="1.0" encoding="utf-8"?><!--
                       Sample data extraction rules file; uncomment and customize as necessary.
                       See https://developer.android.com/about/versions/12/backup-restore#xml-changes
                       for details.
                    -->
                    <data-extraction-rules>
                        <cloud-backup>
                            <!-- TODO: Use <include> and <exclude> to control what is backed up.
                            <include .../>
                            <exclude .../>
                            -->
                        </cloud-backup>
                        <!--
                        <device-transfer>
                            <include .../>
                            <exclude .../>
                        </device-transfer>
                        -->
                    </data-extraction-rules>                    ```
            - **mipmap-xhdpi/**
                - ic_launcher.webp
                    ```
                    Error reading file: 'utf-8' codec can't decode byte 0xec in position 4: invalid continuation byte
                - ic_launcher_round.webp
                    ```
                    Error reading file: 'utf-8' codec can't decode byte 0x9a in position 4: invalid start byte
                - ic_launcher_foreground.webp
                    ```
                    Error reading file: 'utf-8' codec can't decode byte 0xcc in position 4: invalid continuation byte
            - **mipmap-anydpi-v26/**
                - ic_launcher.xml
                    ```
                    <?xml version="1.0" encoding="utf-8"?>
                    <adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
                        <background android:drawable="@drawable/ic_launcher_background"/>
                        <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
                    </adaptive-icon>                    ```
                - ic_launcher_round.xml
                    ```
                    <?xml version="1.0" encoding="utf-8"?>
                    <adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
                        <background android:drawable="@drawable/ic_launcher_background"/>
                        <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
                    </adaptive-icon>                    ```
        - AndroidManifest.xml
            ```
            <?xml version="1.0" encoding="utf-8"?>
            <manifest xmlns:android="http://schemas.android.com/apk/res/android"
                xmlns:tools="http://schemas.android.com/tools"
                package="com.isis3510.spendiq">
            
                <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
                <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
                <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
                <uses-permission android:name="android.permission.USE_BIOMETRIC" />
            
                <application
                    android:allowBackup="true"
                    android:dataExtractionRules="@xml/data_extraction_rules"
                    android:fullBackupContent="@xml/backup_rules"
                    android:icon="@mipmap/ic_launcher"
                    android:label="@string/app_name"
                    android:roundIcon="@mipmap/ic_launcher_round"
                    android:supportsRtl="true"
                    android:theme="@style/Theme.SpendiQ"
                    tools:targetApi="31"
                    android:networkSecurityConfig="@xml/network_security_config"> <!-- Added line -->
            
                    <!-- Google Maps API Key -->
                    <meta-data
                        android:name="com.google.android.geo.API_KEY"
                        android:value="AIzaSyAknJmX2ZYLzwoddFByZnpGXyDmmcqS8cI"/>
            
                    <!-- MainActivity -->
                    <activity
                        android:name=".views.MainActivity"
                        android:exported="true"
                        android:label="@string/app_name"
                        android:theme="@style/Theme.SpendiQ"
                        android:screenOrientation="portrait"
                        android:windowSoftInputMode="adjustPan">
                        <intent-filter>
                            <action android:name="android.intent.action.MAIN" />
                            <category android:name="android.intent.category.LAUNCHER" />
                        </intent-filter>
                    </activity>
            
            
                    <!-- Registering NotificationListenerService -->
                    <service
                        android:name=".services.NotificationListener"
                        android:permission="android.permission.BIND_NOTIFICATION_LISTENER_SERVICE"
                        android:exported="false">
                        <intent-filter>
                            <action android:name="android.service.notification.NotificationListenerService" />
                        </intent-filter>
                    </service>
            
                </application>
            
            </manifest>
            ```
        - **java/**
            - **com/**
                - **isis3510/**
                    - **spendiq/**
                        - **viewmodel/**
                            - ConnectivityViewModel.kt
                                ```
                                package com.isis3510.spendiq.viewmodel
                                
                                import android.app.Application
                                import android.content.Context
                                import android.net.ConnectivityManager
                                import android.net.Network
                                import android.net.NetworkCapabilities
                                import androidx.lifecycle.AndroidViewModel
                                import androidx.lifecycle.LiveData
                                import androidx.lifecycle.MutableLiveData
                                
                                /**
                                 * ConnectivityViewModel class
                                 *
                                 * This ViewModel monitors the network connectivity status of the application.
                                 * It utilizes the ConnectivityManager to detect network changes and provides
                                 * a LiveData object that can be observed to determine the current connection status.
                                 *
                                 * Key Features:
                                 * - Connectivity Monitoring: Uses a NetworkCallback to listen for network availability changes.
                                 * - LiveData Exposure: Provides a LiveData<Boolean> that indicates whether the device is connected to the internet.
                                 *
                                 * State Management:
                                 * - `_isConnected`: MutableLiveData<Boolean> that holds the current connectivity status.
                                 * - `isConnected`: Public LiveData<Boolean> for external observers to check the connection status.
                                 *
                                 * Initialization:
                                 * - On initialization, it checks the current network status and registers a default network callback
                                 *   to listen for changes in connectivity.
                                 */
                                class ConnectivityViewModel(application: Application) : AndroidViewModel(application) {
                                    // MutableLiveData to hold the connectivity status
                                    private val _isConnected = MutableLiveData<Boolean>()
                                
                                    // Public LiveData for observing connectivity status
                                    val isConnected: LiveData<Boolean> get() = _isConnected
                                
                                    // ConnectivityManager instance for network operations
                                    private val connectivityManager =
                                        application.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
                                
                                    init {
                                        // Check the initial connectivity status
                                        _isConnected.value = isNetworkAvailable()
                                
                                        // Register the NetworkCallback to monitor connectivity changes
                                        connectivityManager.registerDefaultNetworkCallback(object : ConnectivityManager.NetworkCallback() {
                                            override fun onAvailable(network: Network) {
                                                _isConnected.postValue(true) // Connection available
                                            }
                                
                                            override fun onLost(network: Network) {
                                                _isConnected.postValue(false) // Connection lost
                                            }
                                        })
                                    }
                                
                                    // Check if the network is available
                                    private fun isNetworkAvailable(): Boolean {
                                        val networkCapabilities = connectivityManager.getNetworkCapabilities(connectivityManager.activeNetwork)
                                        return networkCapabilities?.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET) == true
                                    }
                                }
                                ```
                            - AuthViewModel.kt
                                ```
                                package com.isis3510.spendiq.viewmodel
                                
                                import android.app.Application
                                import android.net.Uri
                                import androidx.lifecycle.AndroidViewModel
                                import androidx.lifecycle.viewModelScope
                                import com.isis3510.spendiq.model.data.User
                                import com.isis3510.spendiq.model.repository.AuthRepository
                                import com.isis3510.spendiq.utils.BiometricHelper
                                import kotlinx.coroutines.flow.MutableStateFlow
                                import kotlinx.coroutines.flow.StateFlow
                                import kotlinx.coroutines.launch
                                import java.util.Date
                                import android.util.Base64
                                import android.util.Log
                                import androidx.fragment.app.FragmentActivity
                                import kotlinx.coroutines.flow.MutableSharedFlow
                                import kotlinx.coroutines.flow.asSharedFlow
                                
                                /**
                                 * Represents the various states of authentication.
                                 */
                                sealed class AuthState {
                                    object Idle : AuthState()
                                    object Loading : AuthState()
                                    object Authenticated : AuthState()
                                    object BiometricEnabled : AuthState() // State indicating biometric login has been enabled
                                    object PasswordResetEmailSent : AuthState() // State indicating a password reset email has been sent
                                    object EmailVerificationSent : AuthState()
                                    object EmailVerified : AuthState()
                                    object EmailNotVerified : AuthState()
                                    data class Error(val message: String) : AuthState() // State indicating an error occurred
                                    object BiometricAlreadyEnabled : AuthState() // State indicating biometric login was already enabled
                                }
                                
                                /**
                                 * ViewModel for managing authentication-related operations.
                                 *
                                 * This ViewModel handles user registration, login, logout, and user data management.
                                 * It also provides methods for biometric authentication and email verification.
                                 *
                                 * @param application The application context.
                                 */
                                class AuthViewModel(application: Application) : AndroidViewModel(application) {
                                    private val authRepository = AuthRepository(application)
                                
                                    private val _authState = MutableStateFlow<AuthState>(AuthState.Idle)
                                    val authState: StateFlow<AuthState> = _authState
                                
                                    private val _user = MutableStateFlow<User?>(null)
                                    val user: StateFlow<User?> = _user
                                
                                    private val _userData = MutableStateFlow<UserDataState>(UserDataState.Idle)
                                    val userData: StateFlow<UserDataState> = _userData
                                
                                    private val biometricHelper = BiometricHelper(application)
                                
                                    private val _biometricLoginEvent = MutableSharedFlow<String>() // Event to handle the result of biometric enablement
                                    val biometricLoginEvent = _biometricLoginEvent.asSharedFlow() // Expose as SharedFlow
                                
                                    init {
                                        // Initialize user data
                                        _user.value = authRepository.getCurrentUser()
                                        if (_user.value != null) {
                                            _authState.value = AuthState.Authenticated
                                        }
                                    }
                                
                                    /**
                                     * Registers a new user with the provided information.
                                     *
                                     * @param email User's email address.
                                     * @param password User's password.
                                     * @param fullName User's full name.
                                     * @param phoneNumber User's phone number.
                                     * @param birthDate User's birth date.
                                     */
                                    fun register(email: String, password: String, fullName: String, phoneNumber: String, birthDate: String) {
                                        viewModelScope.launch {
                                            _authState.value = AuthState.Loading
                                            val userData = mapOf(
                                                "fullName" to fullName,
                                                "email" to email,
                                                "phoneNumber" to phoneNumber,
                                                "birthDate" to birthDate,
                                                "registrationDate" to Date()
                                            )
                                            authRepository.register(email, password, userData).collect { result ->
                                                _authState.value = when {
                                                    result.isSuccess -> {
                                                        _user.value = result.getOrNull()
                                                        AuthState.Authenticated
                                                    }
                                                    result.isFailure -> {
                                                        val error = result.exceptionOrNull()
                                                        AuthState.Error(error?.message ?: "Registration failed")
                                                    }
                                                    else -> AuthState.Error("Unexpected error during registration")
                                                }
                                            }
                                        }
                                    }
                                
                                    /**
                                     * Logs in a user with the provided email and password.
                                     *
                                     * @param email User's email address.
                                     * @param password User's password.
                                     */
                                    fun login(email: String, password: String) {
                                        viewModelScope.launch {
                                            _authState.value = AuthState.Loading
                                            authRepository.login(email, password).collect { result ->
                                                _authState.value = when {
                                                    result.isSuccess -> {
                                                        _user.value = result.getOrNull()
                                                        AuthState.Authenticated
                                                    }
                                                    result.isFailure -> AuthState.Error(result.exceptionOrNull()?.message ?: "Unknown error")
                                                    else -> AuthState.Error("Unexpected error")
                                                }
                                            }
                                        }
                                    }
                                
                                    /**
                                     * Logs out the current user.
                                     */
                                    fun logout() {
                                        authRepository.logout()
                                        _user.value = null
                                        _authState.value = AuthState.Idle
                                    }
                                
                                    /**
                                     * Saves user data to the repository.
                                     *
                                     * @param data User data to be saved.
                                     */
                                    fun saveUserData(data: Map<String, Any>) {
                                        viewModelScope.launch {
                                            _user.value?.let { user ->
                                                authRepository.saveUserData(user.id, data).collect { result ->
                                                    if (result.isFailure) {
                                                        _authState.value = AuthState.Error("Failed to save user data")
                                                    }
                                                }
                                            }
                                        }
                                    }
                                
                                    /**
                                     * Retrieves user data from the repository.
                                     */
                                    fun getUserData() {
                                        viewModelScope.launch {
                                            _userData.value = UserDataState.Loading
                                            _user.value?.let { user ->
                                                authRepository.getUserData(user.id).collect { result ->
                                                    _userData.value = if (result.isSuccess) {
                                                        UserDataState.Success(result.getOrNull() ?: emptyMap())
                                                    } else {
                                                        UserDataState.Error(result.exceptionOrNull()?.message ?: "Failed to get user data")
                                                    }
                                                }
                                            }
                                        }
                                    }
                                
                                    /**
                                     * Uploads the user's profile image to the repository.
                                     *
                                     * @param uri The URI of the image to upload.
                                     */
                                    fun uploadProfileImage(uri: Uri) {
                                        viewModelScope.launch {
                                            _userData.value = UserDataState.Loading
                                            authRepository.uploadProfileImage(uri).collect { result ->
                                                if (result.isSuccess) {
                                                    getUserData() // Refresh user data after successful upload
                                                } else {
                                                    _userData.value = UserDataState.Error(result.exceptionOrNull()?.message ?: "Failed to upload profile image")
                                                }
                                            }
                                        }
                                    }
                                
                                    /**
                                     * Represents the various states of user data operations.
                                     */
                                    sealed class UserDataState {
                                        object Idle : UserDataState()
                                        object Loading : UserDataState()
                                        data class Success(val data: Map<String, Any>) : UserDataState()
                                        data class Error(val message: String) : UserDataState()
                                    }
                                
                                    /**
                                     * Sends a verification email to the user's email address.
                                     */
                                    fun sendEmailVerification() {
                                        viewModelScope.launch {
                                            authRepository.sendEmailVerification().collect { result ->
                                                _authState.value = when {
                                                    result.isSuccess -> AuthState.EmailVerificationSent
                                                    result.isFailure -> AuthState.Error(result.exceptionOrNull()?.message ?: "Failed to send verification email")
                                                    else -> AuthState.Error("Unexpected error")
                                                }
                                            }
                                        }
                                    }
                                
                                    /**
                                     * Checks if the user's email is verified.
                                     */
                                    fun checkEmailVerification() {
                                        viewModelScope.launch {
                                            authRepository.reloadUser().collect { result ->
                                                if (result.isSuccess) {
                                                    if (authRepository.isEmailVerified()) {
                                                        _authState.value = AuthState.EmailVerified
                                                    } else {
                                                        _authState.value = AuthState.EmailNotVerified
                                                    }
                                                } else {
                                                    _authState.value = AuthState.Error(result.exceptionOrNull()?.message ?: "Failed to check email verification")
                                                }
                                            }
                                        }
                                    }
                                
                                    /**
                                     * Sends a password reset email to the user's email address.
                                     *
                                     * @param email User's email address.
                                     */
                                    fun sendPasswordResetEmail(email: String) {
                                        viewModelScope.launch {
                                            _authState.value = AuthState.Loading
                                            authRepository.sendPasswordResetEmail(email).collect { result ->
                                                _authState.value = when {
                                                    result.isSuccess -> AuthState.PasswordResetEmailSent
                                                    result.isFailure -> AuthState.Error(result.exceptionOrNull()?.message ?: "Unknown error")
                                                    else -> AuthState.Error("Unexpected error")
                                                }
                                            }
                                        }
                                    }
                                
                                    /**
                                     * Sets up the biometric authentication prompt.
                                     *
                                     * @param activity The FragmentActivity to show the prompt in.
                                     * @param onSuccess Callback when biometric authentication is successful.
                                     * @param onError Callback when an error occurs during biometric authentication.
                                     */
                                    fun setupBiometricPrompt(
                                        activity: FragmentActivity,
                                        onSuccess: () -> Unit,
                                        onError: (String) -> Unit
                                    ) {
                                        biometricHelper.setupBiometricPrompt(activity, onSuccess, onError)
                                    }
                                
                                    /**
                                     * Shows the biometric authentication prompt.
                                     */
                                    fun showBiometricPrompt() {
                                        biometricHelper.showBiometricPrompt()
                                    }
                                
                                    /**
                                     * Enables biometric login by storing the user's credentials.
                                     *
                                     * @param email User's email address.
                                     * @param password User's password.
                                     */
                                    fun enableBiometricLogin(email: String, password: String) {
                                        viewModelScope.launch {
                                            // Check if biometric login is already enabled
                                            if (biometricHelper.isBiometricEnabled()) {
                                                _authState.value = AuthState.BiometricAlreadyEnabled // Change state to indicate biometric already enabled
                                                return@launch // Exit the function
                                            }
                                
                                            _authState.value = AuthState.Loading
                                            authRepository.login(email, password).collect { result ->
                                                when {
                                                    result.isSuccess -> {
                                                        val user = result.getOrNull()
                                                        user?.let {
                                                            Log.d("AuthViewModel", "Login successful, storing credentials")
                                                            biometricHelper.storeCredentials(email, password)
                                                            _authState.value = AuthState.BiometricEnabled // Change state to enabled
                                                        }
                                                    }
                                                    result.isFailure -> {
                                                        _authState.value = AuthState.Error("Failed to enable biometric login")
                                                    }
                                                }
                                            }
                                        }
                                    }
                                
                                    /**
                                     * Logs in the user using stored biometric credentials.
                                     */
                                    fun loginWithBiometrics() {
                                        val (encryptedEmail, encryptedPassword) = biometricHelper.getStoredCredentials()
                                
                                        if (encryptedEmail == null || encryptedPassword == null) {
                                            _authState.value = AuthState.Error("Biometrics are not enabled. Please, enable them and try again")
                                            return
                                        }
                                
                                        try {
                                            val email = String(Base64.decode(encryptedEmail, Base64.DEFAULT))
                                            val password = String(Base64.decode(encryptedPassword, Base64.DEFAULT))
                                            login(email, password)
                                        } catch (e: Exception) {
                                            _authState.value = AuthState.Error("Error processing credentials: ${e.message}")
                                        }
                                    }
                                
                                    /**
                                     * Resets the authentication state to idle.
                                     */
                                    fun resetAuthState() {
                                        _authState.value = AuthState.Idle
                                    }
                                }
                                ```
                            - TransactionViewModel.kt
                                ```
                                package com.isis3510.spendiq.viewmodel
                                
                                import android.os.Build
                                import android.util.Log
                                import androidx.annotation.RequiresApi
                                import androidx.lifecycle.ViewModel
                                import androidx.lifecycle.viewModelScope
                                import com.isis3510.spendiq.model.data.DailyTransaction
                                import com.isis3510.spendiq.model.data.Transaction
                                import com.isis3510.spendiq.model.iterator.TransactionIterator
                                import com.isis3510.spendiq.model.repository.TransactionRepository
                                import kotlinx.coroutines.flow.MutableStateFlow
                                import kotlinx.coroutines.flow.StateFlow
                                import kotlinx.coroutines.launch
                                import java.time.Instant
                                import java.time.temporal.ChronoUnit
                                
                                /**
                                 * TransactionViewModel class
                                 *
                                 * This ViewModel manages the user's financial transactions, providing functionalities to fetch, add, update,
                                 * and delete transactions from a repository. It uses Kotlin Coroutines to handle asynchronous operations
                                 * with the data layer, specifically interfacing with Firestore or any other data source through the
                                 * TransactionRepository.
                                 *
                                 * Key Features:
                                 * - Reactive Data Management: Exposes transaction data and UI states as StateFlow objects for the UI to observe.
                                 * - CRUD Operations: Provides functions to create, read, update, and delete transactions.
                                 * - Error Handling: Manages error states and logs errors for debugging.
                                 * - Income and Expense Calculation: Offers functionality to compute total income and expenses from the transaction list.
                                 *
                                 * State Management:
                                 * - `_transactions`: MutableStateFlow containing a list of transactions.
                                 * - `transactions`: Public immutable StateFlow for observing transactions.
                                 * - `_selectedTransaction`: MutableStateFlow for managing the currently selected transaction.
                                 * - `selectedTransaction`: Public immutable StateFlow for observing the selected transaction.
                                 * - `_uiState`: MutableStateFlow for tracking the current UI state (Idle, Loading, Success, or Error).
                                 * - `uiState`: Public immutable StateFlow for observing UI state changes.
                                 *
                                 * Initialization:
                                 * - On instantiation, the ViewModel initializes the transaction repository and prepares to fetch transactions.
                                 *
                                 * Transaction Management Functions:
                                 * - `fetchTransactions(accountName: String)`: Fetches transactions for a specified account and updates the UI state.
                                 * - `getTransaction(accountId: String, transactionId: String)`: Retrieves a specific transaction and updates the selected transaction state.
                                 * - `addTransactionWithAccountCheck(transaction: Transaction)`: Adds a new transaction and refreshes the transaction list.
                                 * - `updateTransaction(accountId: String, oldTransaction: Transaction, newTransaction: Transaction)`: Updates an existing transaction.
                                 * - `deleteTransaction(accountId: String, transaction: Transaction)`: Deletes a transaction and refreshes the transaction list.
                                 * - `getIncomeAndExpenses()`: Calculates and returns the total income and expenses from the current transaction list.
                                 * - `fetchAllTransactions()`: Fetches all transactions for the authenticated user and updates the transaction list.
                                 *
                                 * UI State Management:
                                 * - Sealed class `UiState` defines the possible UI states (Idle, Loading, Success, and Error) for better state handling.
                                 *
                                 * Error Handling:
                                 * - Logs errors encountered during transaction operations for easier debugging.
                                 */
                                class TransactionViewModel(
                                    private val transactionRepository: TransactionRepository = TransactionRepository()
                                ) : ViewModel() {
                                    // MutableStateFlow for transactions
                                    private val _transactions = MutableStateFlow<List<Transaction>>(emptyList())
                                
                                    // Public immutable StateFlow for transactions
                                    val transactions: StateFlow<List<Transaction>> = _transactions
                                
                                    // MutableStateFlow for the selected transaction
                                    private val _selectedTransaction = MutableStateFlow<Transaction?>(null)
                                
                                    // Public immutable StateFlow for the selected transaction
                                    val selectedTransaction: StateFlow<Transaction?> = _selectedTransaction
                                
                                    // MutableStateFlow for the UI state
                                    private val _uiState = MutableStateFlow<UiState>(UiState.Idle)
                                
                                    // Public immutable StateFlow for the UI state
                                    val uiState: StateFlow<UiState> = _uiState
                                
                                    // Fetch transactions for a specific account
                                    fun fetchTransactions(accountName: String) {
                                        viewModelScope.launch {
                                            _uiState.value = UiState.Loading
                                            transactionRepository.getTransactions(accountName).collect { result ->
                                                _uiState.value = when {
                                                    result.isSuccess -> {
                                                        _transactions.value = result.getOrNull() ?: emptyList()
                                                        UiState.Success
                                                    }
                                                    result.isFailure -> {
                                                        UiState.Error(result.exceptionOrNull()?.message ?: "Failed to fetch transactions")
                                                    }
                                                    else -> UiState.Error("Unexpected error")
                                                }
                                            }
                                        }
                                    }
                                
                                    // Get details for a specific transaction
                                    fun getTransaction(accountId: String, transactionId: String) {
                                        viewModelScope.launch {
                                            _uiState.value = UiState.Loading
                                            transactionRepository.getTransaction(accountId, transactionId).collect { result ->
                                                when {
                                                    result.isSuccess -> {
                                                        _selectedTransaction.value = result.getOrNull()
                                                        _uiState.value = UiState.Success
                                                    }
                                                    result.isFailure -> {
                                                        _uiState.value = UiState.Error(result.exceptionOrNull()?.message ?: "Failed to get transaction")
                                                        _selectedTransaction.value = null
                                                    }
                                                }
                                            }
                                        }
                                    }
                                
                                    // Add a transaction with a check on account
                                    fun addTransactionWithAccountCheck(transaction: Transaction) {
                                        viewModelScope.launch {
                                            _uiState.value = UiState.Loading
                                            transactionRepository.addTransaction(transaction).collect { result ->
                                                _uiState.value = when {
                                                    result.isSuccess -> {
                                                        // Refresh the transactions list for the current account
                                                        fetchTransactions(transaction.accountId)
                                                        UiState.Success
                                                    }
                                                    result.isFailure -> {
                                                        UiState.Error(result.exceptionOrNull()?.message ?: "Failed to add transaction")
                                                    }
                                                    else -> UiState.Error("Unexpected error")
                                                }
                                            }
                                        }
                                    }
                                
                                    // Update a transaction
                                    fun updateTransaction(accountId: String, oldTransaction: Transaction, newTransaction: Transaction) {
                                        viewModelScope.launch {
                                            _uiState.value = UiState.Loading
                                            transactionRepository.updateTransaction(accountId, oldTransaction, newTransaction).collect { result ->
                                                _uiState.value = when {
                                                    result.isSuccess -> {
                                                        _selectedTransaction.value = newTransaction
                                                        fetchTransactions(newTransaction.accountId) // Refresh transactions list
                                                        UiState.Success
                                                    }
                                                    result.isFailure -> {
                                                        UiState.Error(result.exceptionOrNull()?.message ?: "Failed to update transaction")
                                                    }
                                                    else -> UiState.Error("Unexpected error")
                                                }
                                            }
                                        }
                                    }
                                
                                    // Delete a transaction
                                    fun deleteTransaction(accountId: String, transaction: Transaction) {
                                        viewModelScope.launch {
                                            _uiState.value = UiState.Loading
                                            transactionRepository.deleteTransaction(accountId, transaction).collect { result ->
                                                _uiState.value = when {
                                                    result.isSuccess -> {
                                                        _selectedTransaction.value = null
                                                        fetchTransactions(transaction.accountId) // Refresh transactions list
                                                        UiState.Success
                                                    }
                                                    result.isFailure -> {
                                                        UiState.Error(result.exceptionOrNull()?.message ?: "Failed to delete transaction")
                                                    }
                                                    else -> UiState.Error("Unexpected error")
                                                }
                                            }
                                        }
                                    }
                                
                                    // Calculate total income and expenses
                                    fun getIncomeAndExpenses(): Pair<Long, Long> {
                                        var totalIncome = 0L
                                        var totalExpenses = 0L
                                
                                        transactions.value.forEach { transaction ->
                                            if (transaction.transactionType == "Income") {
                                                totalIncome += transaction.amount
                                            } else if (transaction.transactionType == "Expense") {
                                                totalExpenses += transaction.amount
                                            }
                                        }
                                
                                        Log.d("TransactionViewModel", "Expenses: $totalExpenses")
                                        Log.d("TransactionViewModel", "Income: $totalIncome")
                                
                                        return Pair(totalIncome, totalExpenses)
                                    }
                                
                                    //Calculate total income and expenses in te last 30 days
                                    @RequiresApi(Build.VERSION_CODES.O)
                                    fun getIncomeAndExpensesLast30Days(): List<DailyTransaction> {
                                        val iterator = TransactionIterator(transactions.value)
                                        while (iterator.hasNext()) {
                                            iterator.next()
                                        }
                                        return iterator.getDailyTransactions()
                                    }
                                
                                    // Fetch all transactions
                                    fun fetchAllTransactions() {
                                        Log.d("TransactionViewModel", "fetchAllTransactions called")
                                        viewModelScope.launch {
                                            _uiState.value = UiState.Loading
                                            transactionRepository.getAllTransactions().collect { result ->
                                                _uiState.value = when {
                                                    result.isSuccess -> {
                                                        val transactionsList = result.getOrNull() ?: emptyList()
                                                        _transactions.value = transactionsList
                                
                                                        Log.d("TransactionViewModel", "Transactions obtained: $transactionsList")
                                
                                                        UiState.Success
                                                    }
                                                    result.isFailure -> {
                                                        Log.e("TransactionViewModel", "Error fetching transactions: ${result.exceptionOrNull()?.message}")
                                                        UiState.Error(result.exceptionOrNull()?.message ?: "Failed to fetch transactions")
                                                    }
                                                    else -> UiState.Error("Unexpected error")
                                                }
                                            }
                                        }
                                    }
                                
                                    // Clear the selected transaction
                                    fun clearSelectedTransaction() {
                                        _selectedTransaction.value = null
                                    }
                                
                                    // Sealed class for UI state management
                                    sealed class UiState {
                                        object Idle : UiState()
                                        object Loading : UiState()
                                        object Success : UiState()
                                        data class Error(val message: String) : UiState()
                                    }
                                }
                                ```
                            - ProfileViewModel.kt
                                ```
                                package com.isis3510.spendiq.viewmodel
                                
                                import android.content.Context
                                import android.net.Uri
                                import androidx.lifecycle.ViewModel
                                import kotlinx.coroutines.flow.MutableStateFlow
                                import kotlinx.coroutines.flow.StateFlow
                                
                                /**
                                 * ProfileViewModel class
                                 *
                                 * This ViewModel manages the user's profile data, including the profile image and user details.
                                 * It provides functionalities to save, load, and manage profile image URIs and user data using
                                 * Kotlin's Flow for reactive data handling.
                                 *
                                 * Key Features:
                                 * - Profile Image Management: Allows saving and retrieving the user's profile image URI.
                                 * - User Data Management: Facilitates storing and accessing user-related data in a reactive manner.
                                 *
                                 * State Management:
                                 * - `_profileImageUri`: MutableStateFlow holding the URI of the user's profile image.
                                 * - `profileImageUri`: Public immutable StateFlow for observing changes to the profile image URI.
                                 * - `_userData`: MutableStateFlow holding user data in a map format.
                                 * - `userData`: Public immutable StateFlow for observing changes to user data.
                                 *
                                 * Profile Image Functions:
                                 * - `saveProfileImage(context: Context, uri: Uri)`: Saves the provided profile image URI and updates the state.
                                 * - `loadProfileImage(context: Context)`: Loads the profile image URI from shared preferences and updates the state.
                                 *
                                 * User Data Functions:
                                 * - `setUserData(data: Map<String, Any?>)`: Updates the user data state with the provided map.
                                 *
                                 * Private Functions:
                                 * - `saveProfileImageUri(context: Context, uri: Uri)`: Saves the profile image URI to shared preferences.
                                 * - `getProfileImageUri(context: Context)`: Retrieves the profile image URI from shared preferences.
                                 */
                                class ProfileViewModel : ViewModel() {
                                
                                    // MutableStateFlow for the profile image URI
                                    private val _profileImageUri = MutableStateFlow<Uri?>(null)
                                
                                    // Public immutable StateFlow for the profile image URI
                                    val profileImageUri: StateFlow<Uri?> = _profileImageUri
                                
                                    // MutableStateFlow for user data
                                    private val _userData = MutableStateFlow<Map<String, Any?>?>(null)
                                
                                    // Public immutable StateFlow for user data
                                    val userData: StateFlow<Map<String, Any?>?> = _userData
                                
                                    // Save the profile image URI and update the state
                                    fun saveProfileImage(context: Context, uri: Uri) {
                                        saveProfileImageUri(context, uri)
                                        _profileImageUri.value = uri
                                    }
                                
                                    // Load the profile image URI from shared preferences and update the state
                                    fun loadProfileImage(context: Context) {
                                        _profileImageUri.value = getProfileImageUri(context)
                                    }
                                
                                    // Update the user data state
                                    fun setUserData(data: Map<String, Any?>) {
                                        _userData.value = data
                                    }
                                
                                    // Save the profile image URI to shared preferences
                                    private fun saveProfileImageUri(context: Context, uri: Uri) {
                                        val sharedPreferences = context.getSharedPreferences("profile_prefs", Context.MODE_PRIVATE)
                                        sharedPreferences.edit().putString("profile_image_uri", uri.toString()).apply()
                                    }
                                
                                    // Retrieve the profile image URI from shared preferences
                                    private fun getProfileImageUri(context: Context): Uri? {
                                        val sharedPreferences = context.getSharedPreferences("profile_prefs", Context.MODE_PRIVATE)
                                        val uriString = sharedPreferences.getString("profile_image_uri", null)
                                        return uriString?.let { Uri.parse(it) }
                                    }
                                }
                                ```
                            - OffersViewModel.kt
                                ```
                                package com.isis3510.spendiq.viewmodel
                                
                                import android.app.Application
                                import androidx.lifecycle.AndroidViewModel
                                import androidx.lifecycle.viewModelScope
                                import com.isis3510.spendiq.model.data.Offer
                                import com.isis3510.spendiq.model.repository.OffersRepository
                                import com.isis3510.spendiq.services.LocationBasedOfferService
                                import kotlinx.coroutines.flow.MutableStateFlow
                                import kotlinx.coroutines.flow.StateFlow
                                import kotlinx.coroutines.launch
                                
                                /**
                                 * OffersViewModel class
                                 *
                                 * This ViewModel handles the data and logic related to offers in the application.
                                 * It interacts with the OffersRepository to fetch offers and utilizes a service to manage
                                 * location-based offers.
                                 *
                                 * Key Features:
                                 * - Fetching Offers: Retrieves a list of offers from the repository and updates the UI state.
                                 * - Location-Based Monitoring: Starts monitoring for location-based offers using the LocationBasedOfferService.
                                 * - Offer Selection: Allows fetching an individual offer by its ID and maintains its state.
                                 *
                                 * State Management:
                                 * - `_offers`: MutableStateFlow holding a list of offers.
                                 * - `offers`: Public immutable StateFlow for observing the list of offers.
                                 * - `_selectedOffer`: MutableStateFlow holding the currently selected offer.
                                 * - `selectedOffer`: Public immutable StateFlow for observing the selected offer.
                                 * - `_uiState`: MutableStateFlow representing the current UI state (Idle, Loading, Success, Error).
                                 * - `uiState`: Public immutable StateFlow for observing the UI state.
                                 *
                                 * Functions:
                                 * - `fetchOffers()`: Fetches the offers from the repository and updates the UI state accordingly.
                                 * - `getOfferById(offerId: String)`: Fetches an individual offer by its ID and updates the selected offer state.
                                 *
                                 * Lifecycle Management:
                                 * - Stops location monitoring when the ViewModel is cleared.
                                 */
                                class OffersViewModel(application: Application) : AndroidViewModel(application) {
                                    // Instance of OffersRepository to interact with the data layer
                                    private val repository = OffersRepository()
                                
                                    // Instance of LocationBasedOfferService for monitoring location-based offers
                                    private val locationBasedOfferService = LocationBasedOfferService(application)
                                
                                    // MutableStateFlow to hold the list of offers
                                    private val _offers = MutableStateFlow<List<Offer>>(emptyList())
                                
                                    // Public immutable StateFlow for the list of offers
                                    val offers: StateFlow<List<Offer>> = _offers
                                
                                    // MutableStateFlow to hold the currently selected offer
                                    private val _selectedOffer = MutableStateFlow<Offer?>(null)
                                
                                    // Public immutable StateFlow for the selected offer
                                    val selectedOffer: StateFlow<Offer?> = _selectedOffer
                                
                                    // MutableStateFlow representing the current UI state
                                    private val _uiState = MutableStateFlow<UiState>(UiState.Idle)
                                
                                    // Public immutable StateFlow for the UI state
                                    val uiState: StateFlow<UiState> = _uiState
                                
                                    // Fetches offers from the repository
                                    fun fetchOffers() {
                                        viewModelScope.launch {
                                            _uiState.value = UiState.Loading
                                            repository.getOffers().collect { result ->
                                                _uiState.value = when {
                                                    result.isSuccess -> {
                                                        val offersList = result.getOrNull() ?: emptyList()
                                                        _offers.value = offersList
                                                        // Start monitoring for nearby offers
                                                        locationBasedOfferService.startMonitoring(offersList)
                                                        UiState.Success
                                                    }
                                                    result.isFailure -> {
                                                        UiState.Error(result.exceptionOrNull()?.message ?: "Failed to fetch offers")
                                                    }
                                                    else -> {
                                                        UiState.Error("Unknown error occurred")
                                                    }
                                                }
                                            }
                                        }
                                    }
                                
                                    // Fetches an offer by its ID
                                    fun getOfferById(offerId: String) {
                                        viewModelScope.launch {
                                            _uiState.value = UiState.Loading
                                            repository.getOfferById(offerId).collect { result ->
                                                _uiState.value = when {
                                                    result.isSuccess -> {
                                                        _selectedOffer.value = result.getOrNull()
                                                        UiState.Success
                                                    }
                                                    result.isFailure -> {
                                                        UiState.Error(result.exceptionOrNull()?.message ?: "Failed to fetch offer")
                                                    }
                                                    else -> {
                                                        UiState.Error("Unknown error occurred")
                                                    }
                                                }
                                            }
                                        }
                                    }
                                
                                    // Stops location monitoring when the ViewModel is cleared
                                    override fun onCleared() {
                                        super.onCleared()
                                        locationBasedOfferService.stopMonitoring()
                                    }
                                
                                    // Sealed class representing the UI state
                                    sealed class UiState {
                                        object Idle : UiState()
                                        object Loading : UiState()
                                        object Success : UiState()
                                        data class Error(val message: String) : UiState()
                                    }
                                }
                                ```
                            - AccountViewModel.kt
                                ```
                                package com.isis3510.spendiq.viewmodel
                                
                                import androidx.lifecycle.ViewModel
                                import androidx.lifecycle.viewModelScope
                                import com.isis3510.spendiq.model.data.Account
                                import com.isis3510.spendiq.model.data.Transaction
                                import com.isis3510.spendiq.model.repository.AccountRepository
                                import kotlinx.coroutines.flow.MutableStateFlow
                                import kotlinx.coroutines.flow.StateFlow
                                import kotlinx.coroutines.launch
                                
                                /**
                                 * ViewModel for managing account-related operations.
                                 *
                                 * This ViewModel handles fetching, creating, and deleting accounts, as well as managing
                                 * the current money state and associated transactions.
                                 */
                                class AccountViewModel : ViewModel() {
                                    private val accountRepository = AccountRepository()
                                
                                    // State flows
                                    private val _accounts = MutableStateFlow<List<Account>>(emptyList())
                                    val accounts: StateFlow<List<Account>> = _accounts
                                
                                    private val _transactions = MutableStateFlow<List<Transaction>>(emptyList())
                                    val transactions: StateFlow<List<Transaction>> = _transactions
                                
                                    private val _uiState = MutableStateFlow<UiState>(UiState.Idle)
                                    val uiState: StateFlow<UiState> = _uiState
                                
                                    private val _currentMoney = MutableStateFlow(0L)
                                    val currentMoney: StateFlow<Long> = _currentMoney
                                
                                    private val _selectedTransaction = MutableStateFlow<Transaction?>(null)
                                    val selectedTransaction: StateFlow<Transaction?> = _selectedTransaction
                                
                                    init {
                                        fetchAccounts() // Fetch accounts when ViewModel is initialized
                                    }
                                
                                    /**
                                     * Fetches accounts from the repository and updates the UI state.
                                     */
                                    fun fetchAccounts() {
                                        viewModelScope.launch {
                                            _uiState.value = UiState.Loading // Set loading state
                                            accountRepository.getAccounts().collect { result ->
                                                if (result.isSuccess) {
                                                    val accountList = result.getOrNull() ?: emptyList() // Get accounts
                                                    _accounts.value = accountList
                                                    _currentMoney.value = accountList.sumOf { it.amount } // Calculate current money
                                                    _uiState.value = UiState.Success // Set success state
                                                } else {
                                                    _uiState.value = UiState.Error(
                                                        result.exceptionOrNull()?.message ?: "Failed to fetch accounts" // Handle error
                                                    )
                                                }
                                            }
                                        }
                                    }
                                
                                    /**
                                     * Creates a new account of the specified type.
                                     *
                                     * @param accountType The type of account to create.
                                     */
                                    fun createAccount(accountType: String) {
                                        viewModelScope.launch {
                                            _uiState.value = UiState.Loading // Set loading state
                                            accountRepository.createAccount(accountType).collect { result ->
                                                _uiState.value = when {
                                                    result.isSuccess -> {
                                                        fetchAccounts() // Refresh accounts
                                                        UiState.Success // Set success state
                                                    }
                                                    result.isFailure -> {
                                                        UiState.Error(result.exceptionOrNull()?.message ?: "Failed to create account") // Handle error
                                                    }
                                                    else -> UiState.Error("Unexpected error") // Handle unexpected state
                                                }
                                            }
                                        }
                                    }
                                
                                    /**
                                     * Deletes an account of the specified type.
                                     *
                                     * @param accountType The type of account to delete.
                                     */
                                    fun deleteAccount(accountType: String) {
                                        viewModelScope.launch {
                                            _uiState.value = UiState.Loading // Set loading state
                                            accountRepository.deleteAccount(accountType).collect { result ->
                                                _uiState.value = when {
                                                    result.isSuccess -> {
                                                        fetchAccounts() // Refresh accounts
                                                        UiState.Success // Set success state
                                                    }
                                                    result.isFailure -> {
                                                        UiState.Error(result.exceptionOrNull()?.message ?: "Failed to delete account") // Handle error
                                                    }
                                                    else -> UiState.Error("Unexpected error") // Handle unexpected state
                                                }
                                            }
                                        }
                                    }
                                
                                    /**
                                     * Represents the various UI states for account operations.
                                     */
                                    sealed class UiState {
                                        object Idle : UiState() // Initial state
                                        object Loading : UiState() // Loading state
                                        object Success : UiState() // Success state
                                        data class Error(val message: String) : UiState() // Error state with a message
                                    }
                                }
                                ```
                            - UserViewModel.kt
                                ```
                                package com.isis3510.spendiq.viewmodel
                                
                                import androidx.lifecycle.ViewModel
                                import androidx.lifecycle.viewModelScope
                                import com.google.firebase.auth.FirebaseAuth
                                import com.google.firebase.firestore.FirebaseFirestore
                                import kotlinx.coroutines.flow.MutableStateFlow
                                import kotlinx.coroutines.flow.StateFlow
                                import kotlinx.coroutines.launch
                                
                                /**
                                 * UserViewModel class
                                 *
                                 * This ViewModel is responsible for managing the user's data and loading it from Firebase Firestore.
                                 * It utilizes Firebase Authentication to retrieve the current user's ID and fetch their related data from Firestore.
                                 * The user data is stored in a StateFlow which allows the UI to reactively observe changes.
                                 *
                                 * Key Features:
                                 * - Reactive User Data Management: Exposes user data as a StateFlow to allow UI components to subscribe and react to changes.
                                 * - Firebase Integration: Fetches user data from Firebase Firestore using the authenticated user's ID.
                                 * - Error Handling: Provides basic error handling for data retrieval failures.
                                 *
                                 * Initialization:
                                 * - On initialization, the ViewModel fetches the user data by calling `loadUserDataFromFirebase`.
                                 *
                                 * State Management:
                                 * - `_userData`: A private MutableStateFlow that holds the user's data.
                                 * - `userData`: A public immutable StateFlow that exposes user data to the UI.
                                 *
                                 * Firebase Interaction:
                                 * - Uses FirebaseAuth to obtain the current user's ID.
                                 * - Queries the Firestore database to fetch the user's document using the user ID.
                                 * - Updates the `_userData` state when data is successfully retrieved.
                                 *
                                 * Error Handling:
                                 * - Logs errors encountered during data retrieval to the console.
                                 * - Handles the case where no authenticated user exists.
                                 */
                                class UserViewModel : ViewModel() {
                                    // Private mutable state flow for user data
                                    private val _userData = MutableStateFlow<Map<String, Any?>>(emptyMap())
                                
                                    // Public immutable state flow for user data
                                    val userData: StateFlow<Map<String, Any?>> = _userData
                                
                                    // Initializing the ViewModel and loading user data from Firebase
                                    init {
                                        loadUserDataFromFirebase()
                                    }
                                
                                    // Function to load user data from Firebase Firestore
                                    private fun loadUserDataFromFirebase() {
                                        // Get the current user
                                        val currentUser = FirebaseAuth.getInstance().currentUser
                                        val userId = currentUser?.uid
                                        if (userId != null) {
                                            viewModelScope.launch {
                                                val firestore = FirebaseFirestore.getInstance()
                                                val userDocument = firestore.collection("users").document(userId)
                                
                                                // Retrieve user document from Firestore
                                                userDocument.get()
                                                    .addOnSuccessListener { document ->
                                                        if (document != null && document.exists()) {
                                                            // Extract only the necessary fields
                                                            _userData.value = mapOf(
                                                                "fullName" to document.getString("fullName"),
                                                                "email" to document.getString("email"),
                                                                "phoneNumber" to document.getString("phoneNumber"),
                                                                "birthDate" to document.getString("birthDate")
                                                            )
                                                        }
                                                    }
                                                    .addOnFailureListener { exception ->
                                                        // Handle the error
                                                        println("Error retrieving user data: $exception")
                                                    }
                                            }
                                        } else {
                                            // Handle the case where no authenticated user exists
                                            println("No authenticated user found.")
                                        }
                                    }
                                }
                                ```
                            - LimitsViewModel.kt
                                ```
                                package com.isis3510.spendiq.viewmodel
                                
                                // data class LimitsViewModel()
                                ```
                            - FinantialStatisticsViewModel.kt
                                ```
                                // viewmodel/FinancialStatisticsViewModel.kt
                                ```
                        - **utils/**
                            - BiometricHelper.kt
                                ```
                                package com.isis3510.spendiq.utils
                                
                                import android.content.Context
                                import androidx.fragment.app.FragmentActivity
                                import com.isis3510.spendiq.model.facade.ExternalServicesFacade
                                import com.isis3510.spendiq.model.facade.LDServicesFacade
                                
                                /**
                                 * BiometricHelper is a utility class that handles biometric authentication
                                 * operations and the storage of user credentials.
                                 *
                                 * It interacts with external services for setting up biometric prompts and
                                 * securely storing user credentials such as email and password.
                                 *
                                 * @param context The application context to access services.
                                 */
                                class BiometricHelper(private val context: Context) {
                                    private val externalServicesFacade = ExternalServicesFacade(context) // Facade for external services
                                    private val ldServicesFacade = LDServicesFacade(context) // Facade for local data services
                                
                                    /**
                                     * Sets up the biometric prompt for authentication.
                                     *
                                     * @param activity The FragmentActivity where the biometric prompt will be displayed.
                                     * @param onSuccess Callback function to be executed on successful biometric authentication.
                                     * @param onError Callback function to handle errors during biometric authentication.
                                     */
                                    fun setupBiometricPrompt(activity: FragmentActivity, onSuccess: () -> Unit, onError: (String) -> Unit) {
                                        externalServicesFacade.setupBiometricPrompt(activity, onSuccess, onError) // Delegate to the facade
                                    }
                                
                                    /**
                                     * Displays the biometric prompt to the user for authentication.
                                     */
                                    fun showBiometricPrompt() {
                                        externalServicesFacade.showBiometricPrompt() // Delegate to the facade to show the prompt
                                    }
                                
                                    /**
                                     * Stores the user's credentials securely.
                                     *
                                     * @param email The user's email to be stored.
                                     * @param password The user's password to be stored.
                                     */
                                    fun storeCredentials(email: String, password: String) {
                                        ldServicesFacade.storeCredentials(email, password) // Use the local data service to store credentials
                                    }
                                
                                    /**
                                     * Retrieves the stored user credentials.
                                     *
                                     * @return A pair containing the encrypted email and password.
                                     *         Both values may be null if no credentials are stored.
                                     */
                                    fun getStoredCredentials(): Pair<String?, String?> {
                                        val encryptedEmail = ldServicesFacade.getEncryptedEmail() // Get the stored encrypted email
                                        val encryptedPassword = ldServicesFacade.getEncryptedPassword() // Get the stored encrypted password
                                
                                        return Pair(
                                            encryptedEmail,
                                            encryptedPassword
                                        ) // Return the credentials as a pair
                                    }
                                
                                    /**
                                     * Checks if biometric authentication is enabled by verifying
                                     * if the user credentials are stored.
                                     *
                                     * @return True if biometric authentication can be used,
                                     *         false otherwise.
                                     */
                                    fun isBiometricEnabled(): Boolean {
                                        // Check if the credentials are stored
                                        val encryptedEmail = ldServicesFacade.getEncryptedEmail() // Retrieve the encrypted email
                                        val encryptedPassword = ldServicesFacade.getEncryptedPassword() // Retrieve the encrypted password
                                        return encryptedEmail != null && encryptedPassword != null // Return true if both are present
                                    }
                                }
                                ```
                        - **model/**
                            - **repository/**
                                - AccountRepository.kt
                                    ```
                                    package com.isis3510.spendiq.model.repository
                                    
                                    import android.util.Log
                                    import androidx.compose.ui.graphics.Color
                                    import com.isis3510.spendiq.model.data.Account
                                    import com.isis3510.spendiq.model.singleton.FirebaseManager
                                    import kotlinx.coroutines.flow.Flow
                                    import kotlinx.coroutines.flow.flow
                                    import kotlinx.coroutines.tasks.await
                                    
                                    /**
                                     * Repository class for managing accounts in the application.
                                     * This class interacts with Firebase Firestore to perform CRUD operations
                                     * on user accounts and provides access to account data through coroutines.
                                     */
                                    class AccountRepository {
                                        // Firebase Firestore and Authentication instances
                                        private val firestore = FirebaseManager.firestore
                                        private val auth = FirebaseManager.auth
                                    
                                        /**
                                         * Retrieves all accounts associated with the currently authenticated user.
                                         * Emits a Result containing a list of Account objects.
                                         */
                                        fun getAccounts(): Flow<Result<List<Account>>> = flow {
                                            try {
                                                // Retrieve the current user's ID
                                                val userId = auth.currentUser?.uid ?: throw Exception("User not authenticated")
                                                // Fetch account documents from Firestore
                                                val snapshot = firestore.collection("accounts")
                                                    .whereEqualTo("user_id", userId)
                                                    .get()
                                                    .await()
                                    
                                                // Map Firestore documents to Account objects
                                                val accounts = snapshot.documents.mapNotNull { doc ->
                                                    Account(
                                                        id = doc.id,
                                                        name = doc.getString("name") ?: return@mapNotNull null,
                                                        type = "Debit",
                                                        amount = doc.getLong("amount") ?: 0L,
                                                        color = getColorForAccount(doc.getString("name") ?: "")
                                                    )
                                                }
                                                // Emit the successful result
                                                emit(Result.success(accounts))
                                            } catch (e: Exception) {
                                                Log.e("AccountRepository", "Error fetching accounts", e)
                                                // Emit failure result on exception
                                                emit(Result.failure(e))
                                            }
                                        }
                                    
                                        /**
                                         * Creates a new account for the currently authenticated user.
                                         * Emits a Result indicating the success or failure of the operation.
                                         *
                                         * @param accountType The type/name of the account to create.
                                         */
                                        fun createAccount(accountType: String): Flow<Result<Unit>> = flow {
                                            try {
                                                val userId = auth.currentUser?.uid ?: throw Exception("User not authenticated")
                                                // Add a new account document to Firestore
                                                firestore.collection("accounts").add(
                                                    mapOf(
                                                        "name" to accountType,
                                                        "amount" to 0L,
                                                        "user_id" to userId
                                                    )
                                                ).await()
                                                // Emit success result
                                                emit(Result.success(Unit))
                                            } catch (e: Exception) {
                                                Log.e("AccountRepository", "Error creating account", e)
                                                // Emit failure result on exception
                                                emit(Result.failure(e))
                                            }
                                        }
                                    
                                        /**
                                         * Deletes an account and its associated transactions from Firestore.
                                         * Emits a Result indicating the success or failure of the operation.
                                         *
                                         * @param accountId The ID of the account to delete.
                                         */
                                        fun deleteAccount(accountId: String): Flow<Result<Unit>> = flow {
                                            try {
                                                // Reference to the account document
                                                val accountRef = firestore.collection("accounts").document(accountId)
                                                // Fetch transactions associated with the account
                                                val transactionsSnapshot = accountRef.collection("transactions").get().await()
                                    
                                                // Perform a Firestore transaction to delete the account and its transactions
                                                firestore.runTransaction { transaction ->
                                                    for (transactionDoc in transactionsSnapshot.documents) {
                                                        transaction.delete(transactionDoc.reference)
                                                    }
                                                    transaction.delete(accountRef)
                                                }.await()
                                    
                                                // Emit success result
                                                emit(Result.success(Unit))
                                            } catch (e: Exception) {
                                                Log.e("AccountRepository", "Error deleting account", e)
                                                // Emit failure result on exception
                                                emit(Result.failure(e))
                                            }
                                        }
                                    
                                        /**
                                         * Updates the balance of a specified account.
                                         *
                                         * @param accountId The ID of the account to update.
                                         * @param amountDelta The change in amount (can be positive or negative).
                                         */
                                        suspend fun updateAccountBalance(accountId: String, amountDelta: Long) {
                                            // Reference to the account document
                                            val accountRef = firestore.collection("accounts").document(accountId)
                                    
                                            // Perform a Firestore transaction to update the account balance
                                            firestore.runTransaction { transactionObj ->
                                                val account = transactionObj.get(accountRef)
                                                val currentBalance = account.getLong("amount") ?: 0L
                                                transactionObj.update(accountRef, "amount", currentBalance + amountDelta)
                                            }.await()
                                        }
                                    
                                        /**
                                         * Returns a Color associated with an account name.
                                         *
                                         * @param accountName The name of the account.
                                         * @return The corresponding Color for the account.
                                         */
                                        private fun getColorForAccount(accountName: String): Color {
                                            return when (accountName) {
                                                "Nu" -> Color(0xFF9747FF)
                                                "Bancolombia" -> Color(0xFFFFCC00)
                                                "Nequi" -> Color(0xFF8B2F87)
                                                "Lulo" -> Color(0xFFE8FF00)
                                                "Davivienda" -> Color(0xFFed1c27)
                                                "BBVA" -> Color(0xFF072146)
                                                else -> Color.Gray // Default color for unrecognized accounts
                                            }
                                        }
                                    }
                                    ```
                                - OffersRepository.kt
                                    ```
                                    package com.isis3510.spendiq.model.repository
                                    
                                    import android.util.Log
                                    import com.isis3510.spendiq.model.data.Offer
                                    import com.isis3510.spendiq.model.singleton.FirebaseManager
                                    import kotlinx.coroutines.flow.Flow
                                    import kotlinx.coroutines.flow.flow
                                    import kotlinx.coroutines.tasks.await
                                    
                                    /**
                                     * Repository class for handling operations related to offers.
                                     *
                                     * This class provides methods to fetch all offers from Firestore,
                                     * as well as fetching a specific offer by its ID.
                                     */
                                    class OffersRepository {
                                        // Firestore instance for database interactions
                                        private val firestore = FirebaseManager.firestore
                                    
                                        /**
                                         * Retrieves all offers from the Firestore database.
                                         *
                                         * @return A Flow emitting the result containing a list of offers on success,
                                         * or an error if the operation fails.
                                         */
                                        fun getOffers(): Flow<Result<List<Offer>>> = flow {
                                            try {
                                                Log.d(TAG, "Fetching offers...") // Log the fetching operation
                                                val snapshot = firestore.collection("offers").get().await() // Await Firestore response
                                                // Map documents to Offer objects, handling potential deserialization errors
                                                val offerList = snapshot.documents.mapNotNull { doc ->
                                                    try {
                                                        // Convert Firestore document to Offer object and include the document ID
                                                        doc.toObject(Offer::class.java)?.copy(id = doc.id)
                                                    } catch (e: Exception) {
                                                        // Log error if deserialization fails for this document
                                                        Log.e(TAG, "Error deserializing document: ${doc.id} - ${e.message}")
                                                        null // Return null to skip this document
                                                    }
                                                }
                                                emit(Result.success(offerList)) // Emit success with the list of offers
                                            } catch (e: Exception) {
                                                // Log error and emit failure if the fetching operation fails
                                                Log.e(TAG, "Error fetching offers", e)
                                                emit(Result.failure(e))
                                            }
                                        }
                                    
                                        /**
                                         * Retrieves a specific offer by its ID.
                                         *
                                         * @param offerId The ID of the offer to retrieve.
                                         * @return A Flow emitting the result containing the offer on success,
                                         * or an error if the operation fails.
                                         */
                                        fun getOfferById(offerId: String): Flow<Result<Offer?>> = flow {
                                            try {
                                                // Fetch the specific document by offer ID
                                                val doc = firestore.collection("offers").document(offerId).get().await()
                                                // Convert the document to Offer object and include the document ID
                                                val offer = doc.toObject(Offer::class.java)?.copy(id = doc.id)
                                                emit(Result.success(offer)) // Emit success with the offer
                                            } catch (e: Exception) {
                                                // Log error and emit failure if the fetching operation fails
                                                Log.e(TAG, "Error fetching offer by id: $offerId", e)
                                                emit(Result.failure(e))
                                            }
                                        }
                                    
                                        companion object {
                                            private const val TAG = "OffersRepository" // Tag for logging
                                        }
                                    }
                                    ```
                                - AnomalyRepository.kt
                                    ```
                                    package com.isis3510.spendiq.model.repository
                                    
                                    import android.util.Log
                                    import com.isis3510.spendiq.services.AnomalyApiService
                                    
                                    /**
                                     * Repository class for managing anomaly detection requests related to transactions.
                                     * This class provides a method to analyze transactions for anomalies by interacting
                                     * with the Anomaly API service.
                                     */
                                    class AnomalyRepository {
                                        // Instance of the AnomalyApiService to make network calls
                                        private val apiService = AnomalyApiService.create()
                                    
                                        /**
                                         * Analyzes a transaction for anomalies using the provided user ID and transaction ID.
                                         *
                                         * @param userId The ID of the user associated with the transaction.
                                         * @param transactionId The ID of the transaction to analyze.
                                         */
                                        suspend fun analyzeTransaction(userId: String, transactionId: String) {
                                            try {
                                                // Make a network call to analyze the specified transaction
                                                apiService.analyzeTransaction(userId, transactionId)
                                            } catch (e: Exception) {
                                                // Log any exceptions encountered during the network call
                                                Log.e("AnomalyRepository", "Error analyzing transaction", e)
                                                // Errors are logged but not propagated as we don't need to handle them here
                                            }
                                        }
                                    }
                                    ```
                                - AuthRepository.kt
                                    ```
                                    package com.isis3510.spendiq.model.repository
                                    
                                    import android.content.Context
                                    import android.net.Uri
                                    import com.isis3510.spendiq.model.data.User
                                    import com.isis3510.spendiq.model.singleton.FirebaseManager
                                    import kotlinx.coroutines.flow.Flow
                                    import kotlinx.coroutines.flow.flow
                                    import kotlinx.coroutines.tasks.await
                                    
                                    /**
                                     * Repository class for handling authentication-related operations,
                                     * such as login, registration, user data management, and email verification.
                                     *
                                     * This class interacts with Firebase Authentication, Firestore, and Storage.
                                     *
                                     * @property context The application context used for operations requiring it.
                                     */
                                    class AuthRepository(private val context: Context) {
                                        // Firebase instances for authentication, Firestore, and storage
                                        private val auth = FirebaseManager.auth
                                        private val firestore = FirebaseManager.firestore
                                        private val storage = FirebaseManager.storage
                                    
                                        /**
                                         * Logs in a user with the provided email and password.
                                         *
                                         * @param email The email of the user.
                                         * @param password The password of the user.
                                         * @return A Flow emitting the result containing a User object on success or an error.
                                         */
                                        fun login(email: String, password: String): Flow<Result<User>> = flow {
                                            try {
                                                val result = auth.signInWithEmailAndPassword(email, password).await()
                                                result.user?.let {
                                                    // Create and emit User object upon successful login
                                                    val user = User(it.uid, it.email ?: "")
                                                    emit(Result.success(user))
                                                } ?: emit(Result.failure(Exception("Login failed"))) // Emit failure if user is null
                                            } catch (e: Exception) {
                                                emit(Result.failure(e)) // Emit failure in case of exception
                                            }
                                        }
                                    
                                        /**
                                         * Registers a new user with the provided email, password, and additional user data.
                                         *
                                         * @param email The email of the new user.
                                         * @param password The password of the new user.
                                         * @param userData A map containing additional user data to be saved.
                                         * @return A Flow emitting the result containing a User object on success or an error.
                                         */
                                        fun register(email: String, password: String, userData: Map<String, Any>): Flow<Result<User>> = flow {
                                            try {
                                                val result = auth.createUserWithEmailAndPassword(email, password).await()
                                                result.user?.let { firebaseUser ->
                                                    // Create User object and save additional user data to Firestore
                                                    val user = User(firebaseUser.uid, email)
                                                    firestore.collection("users").document(user.id)
                                                        .set(userData)
                                                        .await() // Wait for Firestore operation to complete
                                                    emit(Result.success(user)) // Emit the created user
                                                } ?: emit(Result.failure(Exception("Registration failed"))) // Emit failure if user is null
                                            } catch (e: Exception) {
                                                emit(Result.failure(e)) // Emit failure in case of exception
                                            }
                                        }
                                    
                                        /**
                                         * Retrieves the currently authenticated user.
                                         *
                                         * @return A User object if authenticated, null otherwise.
                                         */
                                        fun getCurrentUser(): User? {
                                            val firebaseUser = auth.currentUser
                                            return firebaseUser?.let { User(it.uid, it.email ?: "") } // Return User object or null
                                        }
                                    
                                        /**
                                         * Logs out the current user.
                                         */
                                        fun logout() {
                                            auth.signOut() // Sign out the current user
                                        }
                                    
                                        /**
                                         * Sends an email verification link to the currently authenticated user.
                                         *
                                         * @return A Flow emitting the result of the operation.
                                         */
                                        fun sendEmailVerification(): Flow<Result<Unit>> = flow {
                                            try {
                                                auth.currentUser?.sendEmailVerification()?.await() // Send verification email
                                                emit(Result.success(Unit)) // Emit success
                                            } catch (e: Exception) {
                                                emit(Result.failure(e)) // Emit failure in case of exception
                                            }
                                        }
                                    
                                        /**
                                         * Checks if the currently authenticated user's email is verified.
                                         *
                                         * @return True if the email is verified, false otherwise.
                                         */
                                        fun isEmailVerified(): Boolean {
                                            return auth.currentUser?.isEmailVerified ?: false // Return email verification status
                                        }
                                    
                                        /**
                                         * Reloads the currently authenticated user's data.
                                         *
                                         * @return A Flow emitting the result of the operation.
                                         */
                                        fun reloadUser(): Flow<Result<Unit>> = flow {
                                            try {
                                                auth.currentUser?.reload()?.await() // Reload user data
                                                emit(Result.success(Unit)) // Emit success
                                            } catch (e: Exception) {
                                                emit(Result.failure(e)) // Emit failure in case of exception
                                            }
                                        }
                                    
                                        /**
                                         * Saves additional user data to Firestore.
                                         *
                                         * @param userId The ID of the user to whom the data belongs.
                                         * @param data A map containing the data to be saved.
                                         * @return A Flow emitting the result of the operation.
                                         */
                                        fun saveUserData(userId: String, data: Map<String, Any>): Flow<Result<Unit>> = flow {
                                            try {
                                                firestore.collection("users").document(userId).set(data).await() // Save user data
                                                emit(Result.success(Unit)) // Emit success
                                            } catch (e: Exception) {
                                                emit(Result.failure(e)) // Emit failure in case of exception
                                            }
                                        }
                                    
                                        /**
                                         * Retrieves additional user data from Firestore.
                                         *
                                         * @param userId The ID of the user whose data is to be retrieved.
                                         * @return A Flow emitting the result containing user data on success or an error.
                                         */
                                        fun getUserData(userId: String): Flow<Result<Map<String, Any>>> = flow {
                                            try {
                                                val snapshot = firestore.collection("users").document(userId).get().await() // Retrieve user data
                                                if (snapshot.exists()) {
                                                    emit(Result.success(snapshot.data ?: emptyMap())) // Emit user data if exists
                                                } else {
                                                    emit(Result.failure(Exception("User data not found"))) // Emit failure if user data not found
                                                }
                                            } catch (e: Exception) {
                                                emit(Result.failure(e)) // Emit failure in case of exception
                                            }
                                        }
                                    
                                        /**
                                         * Uploads a profile image to Firebase Storage.
                                         *
                                         * @param uri The URI of the image to be uploaded.
                                         * @return A Flow emitting the result containing the image download URL on success or an error.
                                         */
                                        fun uploadProfileImage(uri: Uri): Flow<Result<String>> = flow {
                                            try {
                                                val user = auth.currentUser ?: throw Exception("User not authenticated") // Ensure user is authenticated
                                                val imageRef = storage.reference.child("profile_images/${user.uid}.jpg") // Reference to storage path
                                                val uploadTask = imageRef.putFile(uri).await() // Upload image and await result
                                                val downloadUrl = uploadTask.storage.downloadUrl.await().toString() // Get download URL
                                    
                                                // Update Firestore with the new image URL
                                                firestore.collection("users").document(user.uid)
                                                    .update("profileImageUrl", downloadUrl).await()
                                    
                                                emit(Result.success(downloadUrl)) // Emit the download URL
                                            } catch (e: Exception) {
                                                emit(Result.failure(e)) // Emit failure in case of exception
                                            }
                                        }
                                    
                                        /**
                                         * Sends a password reset email to the specified email address.
                                         *
                                         * @param email The email address to send the reset link to.
                                         * @return A Flow emitting the result of the operation.
                                         */
                                        fun sendPasswordResetEmail(email: String): Flow<Result<Unit>> = flow {
                                            try {
                                                auth.sendPasswordResetEmail(email).await() // Send password reset email
                                                emit(Result.success(Unit)) // Emit success
                                            } catch (e: Exception) {
                                                emit(Result.failure(e)) // Emit failure in case of exception
                                            }
                                        }
                                    }
                                    ```
                                - TransactionRepository.kt
                                    ```
                                    package com.isis3510.spendiq.model.repository
                                    
                                    import android.util.Log
                                    import com.isis3510.spendiq.model.data.Location
                                    import com.isis3510.spendiq.model.data.Transaction
                                    import com.isis3510.spendiq.model.singleton.FirebaseManager
                                    import kotlinx.coroutines.coroutineScope
                                    import kotlinx.coroutines.flow.Flow
                                    import kotlinx.coroutines.flow.flow
                                    import kotlinx.coroutines.launch
                                    import kotlinx.coroutines.tasks.await
                                    
                                    /**
                                     * Repository class for managing transactions related to user accounts.
                                     *
                                     * This class provides methods to fetch, add, update, and delete transactions
                                     * stored in Firestore, along with analyzing anomalies in transactions.
                                     */
                                    class TransactionRepository {
                                        // Firebase instances for authentication and Firestore
                                        private val auth = FirebaseManager.auth
                                        private val firestore = FirebaseManager.firestore
                                        private val anomalyRepository = AnomalyRepository() // For anomaly analysis
                                        private val accountRepository = AccountRepository() // For account balance updates
                                    
                                        companion object {
                                            // Default location used when no location is available
                                            private val DEFAULT_LOCATION = Location(
                                                latitude = 4.6097100,  // Coordinates for Bogota
                                                longitude = -74.0817500
                                            )
                                        }
                                    
                                        /**
                                         * Retrieves transactions for a specified account name.
                                         *
                                         * @param accountName The name of the account whose transactions are to be fetched.
                                         * @return A Flow emitting the result containing a list of transactions on success,
                                         * or an error if the operation fails.
                                         */
                                        fun getTransactions(accountName: String): Flow<Result<List<Transaction>>> = flow {
                                            try {
                                                val userId = auth.currentUser?.uid ?: throw Exception("User not authenticated")
                                                val accountSnapshot = firestore.collection("accounts")
                                                    .whereEqualTo("user_id", userId)
                                                    .whereEqualTo("name", accountName)
                                                    .get()
                                                    .await()
                                    
                                                if (accountSnapshot.documents.isEmpty()) {
                                                    emit(Result.failure(Exception("Account not found")))
                                                    return@flow
                                                }
                                    
                                                val accountId = accountSnapshot.documents[0].id
                                                val transactionsSnapshot = firestore.collection("accounts")
                                                    .document(accountId)
                                                    .collection("transactions")
                                                    .get()
                                                    .await()
                                    
                                                // Map documents to Transaction objects and sort them by date
                                                val transactions = transactionsSnapshot.documents.mapNotNull { doc ->
                                                    parseTransactionDocument(doc, accountId)
                                                }.sortedByDescending { it.dateTime.toDate() }
                                    
                                                emit(Result.success(transactions)) // Emit the result
                                            } catch (e: Exception) {
                                                Log.e("TransactionRepository", "Error fetching transactions", e) // Log error
                                                emit(Result.failure(e))
                                            }
                                        }
                                    
                                        /**
                                         * Retrieves a specific transaction by its ID.
                                         *
                                         * @param accountId The ID of the account containing the transaction.
                                         * @param transactionId The ID of the transaction to retrieve.
                                         * @return A Flow emitting the result containing the transaction on success,
                                         * or an error if the operation fails.
                                         */
                                        fun getTransaction(accountId: String, transactionId: String): Flow<Result<Transaction>> = flow {
                                            try {
                                                val transactionDoc = firestore.collection("accounts")
                                                    .document(accountId)
                                                    .collection("transactions")
                                                    .document(transactionId)
                                                    .get()
                                                    .await()
                                    
                                                if (!transactionDoc.exists()) {
                                                    emit(Result.failure(Exception("Transaction not found")))
                                                    return@flow
                                                }
                                    
                                                val transaction = parseTransactionDocument(transactionDoc, accountId)
                                                transaction?.let {
                                                    emit(Result.success(it)) // Emit the retrieved transaction
                                                } ?: emit(Result.failure(Exception("Failed to parse transaction")))
                                            } catch (e: Exception) {
                                                Log.e("TransactionRepository", "Error fetching transaction", e) // Log error
                                                emit(Result.failure(e))
                                            }
                                        }
                                    
                                        /**
                                         * Retrieves all transactions for the current user across all accounts.
                                         *
                                         * @return A Flow emitting the result containing a list of all transactions on success,
                                         * or an error if the operation fails.
                                         */
                                        fun getAllTransactions(): Flow<Result<List<Transaction>>> = flow {
                                            try {
                                                val userId = auth.currentUser?.uid ?: throw Exception("User not authenticated")
                                                val accountsSnapshot = firestore.collection("accounts")
                                                    .whereEqualTo("user_id", userId)
                                                    .get()
                                                    .await()
                                    
                                                val transactions = mutableListOf<Transaction>()
                                    
                                                // Iterate over each account to fetch its transactions
                                                for (accountDoc in accountsSnapshot.documents) {
                                                    val accountId = accountDoc.id
                                                    val transactionsSnapshot = firestore.collection("accounts")
                                                        .document(accountId)
                                                        .collection("transactions")
                                                        .get()
                                                        .await()
                                    
                                                    // Add each transaction to the list
                                                    transactions.addAll(transactionsSnapshot.documents.mapNotNull { doc ->
                                                        parseTransactionDocument(doc, accountId)
                                                    })
                                                }
                                    
                                                emit(Result.success(transactions)) // Emit the list of transactions
                                            } catch (e: Exception) {
                                                Log.e("TransactionRepository", "Error fetching all transactions", e) // Log error
                                                emit(Result.failure(e))
                                            }
                                        }
                                    
                                        /**
                                         * Adds a new transaction to the specified account.
                                         *
                                         * @param transaction The transaction to add.
                                         * @return A Flow emitting the result of the operation.
                                         */
                                        fun addTransaction(transaction: Transaction): Flow<Result<Unit>> = flow {
                                            try {
                                                // Create a reference for the new transaction document
                                                val accountRef = firestore.collection("accounts")
                                                    .document(transaction.accountId)
                                                    .collection("transactions")
                                                    .document()
                                    
                                                val transactionWithId = transaction.copy(id = accountRef.id) // Include the document ID
                                                val transactionMap = createTransactionMap(transactionWithId) // Create a map for Firestore
                                    
                                                // Store the transaction in Firestore
                                                accountRef.set(transactionMap).await()
                                    
                                                // Update the account balance based on transaction type
                                                val amountDelta = if (transaction.transactionType == "Income") transaction.amount else -transaction.amount
                                                accountRepository.updateAccountBalance(transaction.accountId, amountDelta)
                                    
                                                // Launch a coroutine to analyze the transaction for anomalies
                                                coroutineScope {
                                                    launch {
                                                        auth.currentUser?.uid?.let { userId ->
                                                            anomalyRepository.analyzeTransaction(userId, accountRef.id)
                                                        }
                                                    }
                                                }
                                    
                                                emit(Result.success(Unit)) // Emit success
                                            } catch (e: Exception) {
                                                Log.e("TransactionRepository", "Error adding transaction", e) // Log error
                                                emit(Result.failure(e))
                                            }
                                        }
                                    
                                        /**
                                         * Updates an existing transaction.
                                         *
                                         * @param accountId The ID of the account containing the transaction.
                                         * @param oldTransaction The transaction to be updated.
                                         * @param newTransaction The updated transaction details.
                                         * @return A Flow emitting the result of the operation.
                                         */
                                        fun updateTransaction(accountId: String, oldTransaction: Transaction, newTransaction: Transaction): Flow<Result<Unit>> = flow {
                                            try {
                                                val transactionRef = firestore.collection("accounts")
                                                    .document(accountId)
                                                    .collection("transactions")
                                                    .document(oldTransaction.id)
                                    
                                                // Check if the transaction exists before updating
                                                if (!(transactionRef.get().await().exists())) {
                                                    emit(Result.failure(Exception("Transaction does not exist")))
                                                    return@flow
                                                }
                                    
                                                // Calculate the balance adjustment based on the old and new amounts
                                                val oldAmount = if (oldTransaction.transactionType == "Income") oldTransaction.amount else -oldTransaction.amount
                                                val newAmount = if (newTransaction.transactionType == "Income") newTransaction.amount else -newTransaction.amount
                                                val balanceAdjustment = newAmount - oldAmount
                                    
                                                // Update the transaction in Firestore
                                                transactionRef.set(createTransactionMap(newTransaction)).await()
                                                // Update the account balance
                                                accountRepository.updateAccountBalance(accountId, balanceAdjustment)
                                    
                                                // Launch a coroutine to analyze the updated transaction for anomalies
                                                coroutineScope {
                                                    launch {
                                                        auth.currentUser?.uid?.let { userId ->
                                                            anomalyRepository.analyzeTransaction(userId, newTransaction.id)
                                                        }
                                                    }
                                                }
                                    
                                                emit(Result.success(Unit)) // Emit success
                                            } catch (e: Exception) {
                                                Log.e("TransactionRepository", "Error updating transaction", e) // Log error
                                                emit(Result.failure(e))
                                            }
                                        }
                                    
                                        /**
                                         * Deletes a transaction from the specified account.
                                         *
                                         * @param accountId The ID of the account containing the transaction.
                                         * @param transaction The transaction to delete.
                                         * @return A Flow emitting the result of the operation.
                                         */
                                        fun deleteTransaction(accountId: String, transaction: Transaction): Flow<Result<Unit>> = flow {
                                            try {
                                                val transactionRef = firestore.collection("accounts")
                                                    .document(accountId)
                                                    .collection("transactions")
                                                    .document(transaction.id)
                                    
                                                // Delete the transaction document
                                                transactionRef.delete().await()
                                    
                                                // Update the account balance
                                                val amountToRemove = if (transaction.transactionType == "Income") -transaction.amount else transaction.amount
                                                accountRepository.updateAccountBalance(accountId, amountToRemove)
                                    
                                                emit(Result.success(Unit)) // Emit success
                                            } catch (e: Exception) {
                                                Log.e("TransactionRepository", "Error deleting transaction", e) // Log error
                                                emit(Result.failure(e))
                                            }
                                        }
                                    
                                        /**
                                         * Parses a Firestore document into a Transaction object.
                                         *
                                         * @param doc The Firestore document to parse.
                                         * @param accountId The ID of the account associated with the transaction.
                                         * @return The Transaction object or null if parsing fails.
                                         */
                                        private fun parseTransactionDocument(doc: com.google.firebase.firestore.DocumentSnapshot, accountId: String): Transaction? {
                                            return try {
                                                Transaction(
                                                    id = doc.id,
                                                    accountId = accountId,
                                                    transactionName = doc.getString("transactionName") ?: return null,
                                                    amount = doc.getLong("amount") ?: return null,
                                                    dateTime = doc.getTimestamp("dateTime") ?: return null,
                                                    transactionType = doc.getString("transactionType") ?: return null,
                                                    location = doc.get("location")?.let { locationMap ->
                                                        if (locationMap is Map<*, *>) {
                                                            Location(
                                                                latitude = (locationMap["latitude"] as? Double) ?: DEFAULT_LOCATION.latitude,
                                                                longitude = (locationMap["longitude"] as? Double) ?: DEFAULT_LOCATION.longitude
                                                            )
                                                        } else null
                                                    },
                                                    amountAnomaly = doc.getBoolean("amountAnomaly") ?: false,
                                                    locationAnomaly = doc.getBoolean("locationAnomaly") ?: false,
                                                    automatic = doc.getBoolean("automatic") ?: false // Track if the transaction was created automatically
                                                )
                                            } catch (e: Exception) {
                                                Log.e("TransactionRepository", "Error parsing transaction document", e) // Log error
                                                null
                                            }
                                        }
                                    
                                        /**
                                         * Creates a map representation of a Transaction object for Firestore storage.
                                         *
                                         * @param transaction The Transaction object to convert.
                                         * @return A map containing the transaction's data.
                                         */
                                        private fun createTransactionMap(transaction: Transaction): Map<String, Any?> {
                                            return hashMapOf(
                                                "transactionId" to transaction.id,
                                                "amount" to transaction.amount,
                                                "dateTime" to transaction.dateTime,
                                                "transactionName" to transaction.transactionName,
                                                "transactionType" to transaction.transactionType,
                                                "location" to transaction.location?.let {
                                                    hashMapOf(
                                                        "latitude" to it.latitude,
                                                        "longitude" to it.longitude
                                                    )
                                                },
                                                "locationAnomaly" to transaction.locationAnomaly,
                                                "amountAnomaly" to transaction.amountAnomaly,
                                                "automatic" to transaction.automatic // Track if the transaction was created automatically
                                            )
                                        }
                                    }
                                    ```
                            - **facade/**
                                - ExternalServicesFacade.kt
                                    ```
                                    package com.isis3510.spendiq.model.facade
                                    
                                    import android.content.Context
                                    import androidx.biometric.BiometricPrompt
                                    import androidx.core.content.ContextCompat
                                    import androidx.fragment.app.FragmentActivity
                                    
                                    /**
                                     * ExternalServicesFacade is a class that encapsulates the logic for setting up
                                     * and handling biometric authentication using Android's Biometric API.
                                     *
                                     * @property context The context used to create the BiometricPrompt and prompt information.
                                     */
                                    class ExternalServicesFacade(private val context: Context) {
                                        private lateinit var biometricPrompt: BiometricPrompt // The biometric prompt for authentication
                                        private lateinit var promptInfo: BiometricPrompt.PromptInfo // Information about the biometric prompt
                                    
                                        /**
                                         * Sets up the biometric prompt with the provided activity and callback functions.
                                         *
                                         * This method initializes the biometric prompt and defines the behavior
                                         * for authentication success and errors.
                                         *
                                         * @param activity The FragmentActivity where the biometric prompt will be shown.
                                         * @param onSuccess A callback to be invoked when authentication is successful.
                                         * @param onError A callback to be invoked when an authentication error occurs.
                                         */
                                        fun setupBiometricPrompt(activity: FragmentActivity, onSuccess: () -> Unit, onError: (String) -> Unit) {
                                            // Initialize the biometric prompt with an activity and a callback executor
                                            biometricPrompt = BiometricPrompt(activity, ContextCompat.getMainExecutor(context),
                                                object : BiometricPrompt.AuthenticationCallback() {
                                                    override fun onAuthenticationSucceeded(result: BiometricPrompt.AuthenticationResult) {
                                                        super.onAuthenticationSucceeded(result)
                                                        onSuccess() // Call the success callback
                                                    }
                                    
                                                    override fun onAuthenticationError(errorCode: Int, errString: CharSequence) {
                                                        super.onAuthenticationError(errorCode, errString)
                                                        onError(errString.toString()) // Call the error callback with error message
                                                    }
                                                })
                                    
                                            // Build the prompt info with title, subtitle, and negative button text
                                            promptInfo = BiometricPrompt.PromptInfo.Builder()
                                                .setTitle("Biometric Authentication") // Title for the biometric prompt
                                                .setSubtitle("Log in using your biometric sensor!") // Subtitle for additional context
                                                .setNegativeButtonText("Cancel") // Text for the negative button
                                                .build()
                                        }
                                    
                                        /**
                                         * Displays the biometric prompt for user authentication.
                                         *
                                         * This method will invoke the biometric prompt using the previously set prompt info.
                                         */
                                        fun showBiometricPrompt() {
                                            biometricPrompt.authenticate(promptInfo) // Show the biometric prompt
                                        }
                                    }
                                    ```
                                - LDServicesFacade.kt
                                    ```
                                    package com.isis3510.spendiq.model.facade
                                    
                                    import android.app.Application
                                    import android.content.Context
                                    import android.content.SharedPreferences
                                    import android.util.Base64
                                    import androidx.security.crypto.EncryptedSharedPreferences
                                    import androidx.security.crypto.MasterKey
                                    import javax.crypto.AEADBadTagException
                                    
                                    /**
                                     * LDServicesFacade is a class responsible for securely storing and retrieving
                                     * user credentials using encrypted SharedPreferences.
                                     *
                                     * It utilizes Android's EncryptedSharedPreferences for storing sensitive data
                                     * such as email and password for biometric login.
                                     *
                                     * @property context The application context used to create the encrypted SharedPreferences.
                                     */
                                    class LDServicesFacade(private val context: Context) {
                                        // Lazy initialization of the encrypted SharedPreferences
                                        private val encryptedPrefs by lazy { createEncryptedSharedPreferences() }
                                    
                                        /**
                                         * Stores user credentials securely for biometric login.
                                         *
                                         * The credentials are encrypted using Base64 encoding before being saved
                                         * to the SharedPreferences.
                                         *
                                         * @param email The user's email to be stored.
                                         * @param password The user's password to be stored.
                                         */
                                        fun storeCredentials(email: String, password: String) {
                                            val encryptedEmail = Base64.encodeToString(email.toByteArray(), Base64.DEFAULT) // Encrypt email
                                            val encryptedPassword = Base64.encodeToString(password.toByteArray(), Base64.DEFAULT) // Encrypt password
                                            encryptedPrefs.edit().apply {
                                                putString("user_email", encryptedEmail) // Store encrypted email
                                                putString("user_password", encryptedPassword) // Store encrypted password
                                                apply() // Commit changes asynchronously
                                            }
                                        }
                                    
                                        /**
                                         * Retrieves the encrypted email from SharedPreferences.
                                         *
                                         * @return The encrypted email as a String, or null if not found.
                                         */
                                        fun getEncryptedEmail(): String? {
                                            return encryptedPrefs.getString("user_email", null) // Retrieve encrypted email
                                        }
                                    
                                        /**
                                         * Retrieves the encrypted password from SharedPreferences.
                                         *
                                         * @return The encrypted password as a String, or null if not found.
                                         */
                                        fun getEncryptedPassword(): String? {
                                            return encryptedPrefs.getString("user_password", null) // Retrieve encrypted password
                                        }
                                    
                                        /**
                                         * Creates an instance of EncryptedSharedPreferences for securely storing
                                         * biometric login credentials.
                                         *
                                         * @return The created SharedPreferences instance.
                                         */
                                        private fun createEncryptedSharedPreferences(): SharedPreferences {
                                            return try {
                                                // Create a MasterKey for encrypting the SharedPreferences
                                                val masterKey = MasterKey.Builder(context)
                                                    .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)
                                                    .build()
                                    
                                                // Create and return encrypted SharedPreferences
                                                EncryptedSharedPreferences.create(
                                                    context,
                                                    "secret_shared_prefs", // Name of the preferences file
                                                    masterKey,
                                                    EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
                                                    EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
                                                )
                                            } catch (e: AEADBadTagException) {
                                                // Handle AEADBadTagException by recreating the SharedPreferences
                                                context.getSharedPreferences("secret_shared_prefs", Context.MODE_PRIVATE).edit().clear().apply()
                                                val newMasterKey = MasterKey.Builder(context)
                                                    .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)
                                                    .build()
                                    
                                                // Create new encrypted SharedPreferences
                                                EncryptedSharedPreferences.create(
                                                    context,
                                                    "secret_shared_prefs",
                                                    newMasterKey,
                                                    EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
                                                    EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
                                                )
                                            }
                                        }
                                    }
                                    ```
                            - **iterator/**
                                - TransactionIterator.kt
                                    ```
                                    package com.isis3510.spendiq.model.iterator
                                    
                                    import android.os.Build
                                    import androidx.annotation.RequiresApi
                                    import com.isis3510.spendiq.model.data.DailyTransaction
                                    import com.isis3510.spendiq.model.data.Transaction
                                    import java.text.SimpleDateFormat
                                    import java.time.Instant
                                    import java.time.temporal.ChronoUnit
                                    import java.util.Locale
                                    
                                    class TransactionIterator(private val transactions: List<Transaction>) : Iterator<DailyTransaction> {
                                        private var currentIndex = 0
                                        private val dailyTransactions = mutableMapOf<String, Double>()
                                        @RequiresApi(Build.VERSION_CODES.O)
                                        private val thirtyDaysAgo = Instant.now().minus(30, ChronoUnit.DAYS).toEpochMilli()
                                    
                                        override fun hasNext(): Boolean {
                                            return currentIndex < transactions.size
                                        }
                                    
                                        @RequiresApi(Build.VERSION_CODES.O)
                                        override fun next(): DailyTransaction {
                                            val transaction = transactions[currentIndex++]
                                            val transactionDate = transaction.dateTime.toDate()
                                            val dateString = SimpleDateFormat("dd-MM", Locale.getDefault()).format(transactionDate)
                                            if (transaction.dateTime.toDate().time >= thirtyDaysAgo) {
                                    
                                                // Acumular el monto en el mapa
                                                val amount = if (transaction.transactionType == "Income") {
                                                    transaction.amount.toDouble() // Positivo para ingresos
                                                } else {
                                                    -transaction.amount.toDouble() // Negativo para gastos
                                                }
                                    
                                                // Sumar el monto al da correspondiente
                                                dailyTransactions[dateString] = dailyTransactions.getOrDefault(dateString, 0.0) + amount
                                            }
                                            return DailyTransaction(dateString, dailyTransactions[dateString] ?: 0.0)
                                        }
                                    
                                        fun getDailyTransactions(): List<DailyTransaction> {
                                            return dailyTransactions.map { DailyTransaction(it.key, it.value) } // Convertir el mapa a una lista
                                        }
                                    }                                    ```
                            - **singleton/**
                                - FirebaseManager.kt
                                    ```
                                    package com.isis3510.spendiq.model.singleton
                                    
                                    import com.google.firebase.auth.FirebaseAuth
                                    import com.google.firebase.firestore.FirebaseFirestore
                                    import com.google.firebase.storage.FirebaseStorage
                                    
                                    /**
                                     * Singleton object to manage Firebase services.
                                     *
                                     * This object provides lazy-loaded instances of Firebase Authentication,
                                     * Firestore Database, and Firebase Storage. By using a singleton pattern,
                                     * it ensures that there is only one instance of each service throughout
                                     * the application lifecycle, which can help to optimize resource usage.
                                     */
                                    object FirebaseManager {
                                        // Lazy initialization of Firebase Authentication instance
                                        val auth: FirebaseAuth by lazy { FirebaseAuth.getInstance() }
                                    
                                        // Lazy initialization of Firestore Database instance
                                        val firestore: FirebaseFirestore by lazy { FirebaseFirestore.getInstance() }
                                    
                                        // Lazy initialization of Firebase Storage instance
                                        val storage: FirebaseStorage by lazy { FirebaseStorage.getInstance() }
                                    }
                                    ```
                            - **data/**
                                - Account.kt
                                    ```
                                    package com.isis3510.spendiq.model.data
                                    
                                    import androidx.compose.ui.graphics.Color
                                    
                                    /**
                                     * Data class representing a financial account.
                                     *
                                     * This class contains information about a user's account, including its name,
                                     * type, balance, and color for UI representation.
                                     *
                                     * @property id Unique identifier for the account, typically assigned by the database.
                                     * @property name The name of the account (e.g., "Bank", "Cash", etc.).
                                     * @property type The type of the account (e.g., "Savings", "Checking", etc.).
                                     * @property amount The current balance of the account, represented as a long integer.
                                     * @property color A Color object representing the color associated with this account for UI display.
                                     */
                                    data class Account(
                                        val id: String, // Unique identifier for the account
                                        val name: String, // Name of the account
                                        val type: String, // Type of the account
                                        val amount: Long, // Current balance of the account
                                        val color: Color // Color representation for the account in the UI
                                    )
                                    ```
                                - Offer.kt
                                    ```
                                    package com.isis3510.spendiq.model.data
                                    
                                    /**
                                     * Data class representing a special offer available at a specific place.
                                     *
                                     * This class contains information about an offer, including its location,
                                     * description, and other related details.
                                     *
                                     * @property id Unique identifier for the offer, typically assigned by the database.
                                     * @property placeName The name of the place where the offer is available.
                                     * @property offerDescription A detailed description of the offer being made.
                                     * @property shopImage URL or identifier for an image representing the shop.
                                     * @property recommendationReason Reason why this offer is recommended to the user.
                                     * @property latitude Latitude coordinate of the offer's location.
                                     * @property longitude Longitude coordinate of the offer's location.
                                     * @property distance The distance from the user's current location to the offer's location, in meters.
                                     */
                                    data class Offer(
                                        val id: String? = null, // Unique identifier for the offer, default is null
                                        val placeName: String? = null, // Name of the place where the offer is available, default is null
                                        val offerDescription: String? = null, // Description of the offer, default is null
                                        val shopImage: String? = null, // Image URL for the shop, default is null
                                        val recommendationReason: String? = null, // Reason for recommending this offer, default is null
                                        val latitude: Double? = null, // Latitude of the offer's location, default is null
                                        val longitude: Double? = null, // Longitude of the offer's location, default is null
                                        val distance: Int? = null // Distance to the offer's location from the user, default is null
                                    )
                                    ```
                                - FinantialData.kt
                                    ```
                                    // model/FinancialData.kt
                                    package com.isis3510.spendiq.model
                                    
                                    
                                    data class Account(
                                        val id: String = "",
                                        val name: String = "",
                                        val userId: String = "",
                                        val amount: Long = 0L // Si este campo es necesario
                                    )
                                    
                                    data class Transaction(
                                        val id: String = "",
                                        val accountId: String = "",
                                        val amount: Long = 0L, // Usar Long si es consistente con el resto del cdigo
                                        val type: String = "" // Asegrate de que este sea el nombre correcto
                                    )
                                    
                                    ```
                                - DailyTransaction.kt
                                    ```
                                    package com.isis3510.spendiq.model.data
                                    
                                    data class DailyTransaction(
                                        val day: String,
                                        val amount: Double
                                    )                                    ```
                                - User.kt
                                    ```
                                    package com.isis3510.spendiq.model.data
                                    
                                    /**
                                     * Data class representing a user in the application.
                                     *
                                     * This class holds information about the user, including their unique identifier,
                                     * email address, personal details, and profile image URL.
                                     *
                                     * @property id Unique identifier for the user, typically their Firebase UID.
                                     * @property email The email address of the user.
                                     * @property fullName The full name of the user. Optional property.
                                     * @property phoneNumber The phone number of the user. Optional property.
                                     * @property birthDate The birth date of the user in a String format (e.g., "YYYY-MM-DD"). Optional property.
                                     * @property profileImageUrl URL to the user's profile image. Optional property.
                                     */
                                    data class User(
                                        val id: String, // Unique identifier for the user
                                        val email: String, // The user's email address
                                        val fullName: String? = null, // The user's full name, optional
                                        val phoneNumber: String? = null, // The user's phone number, optional
                                        val birthDate: String? = null, // The user's birth date, optional
                                        val profileImageUrl: String? = null // URL to the user's profile image, optional
                                    )
                                    ```
                                - Transaction.kt
                                    ```
                                    package com.isis3510.spendiq.model.data
                                    
                                    import com.google.firebase.Timestamp
                                    
                                    /**
                                     * Data class representing a financial transaction in the application.
                                     *
                                     * This class holds information about a transaction, including its unique identifier,
                                     * associated account, amount, type, and other relevant details.
                                     *
                                     * @property id Unique identifier for the transaction.
                                     * @property accountId The ID of the account associated with the transaction.
                                     * @property transactionName The name or description of the transaction.
                                     * @property amount The amount of money involved in the transaction.
                                     * @property dateTime The timestamp of when the transaction occurred.
                                     * @property transactionType The type of transaction (e.g., "Income", "Expense").
                                     * @property location The geographical location associated with the transaction, if available.
                                     * @property amountAnomaly Flag indicating if there is an anomaly with the amount (true if there's an anomaly).
                                     * @property locationAnomaly Flag indicating if there is an anomaly with the location (true if there's an anomaly).
                                     * @property automatic Flag indicating if the transaction was created automatically (true if automatic).
                                     */
                                    data class Transaction(
                                        val id: String, // Unique identifier for the transaction
                                        val accountId: String, // ID of the account associated with the transaction
                                        val transactionName: String, // Name or description of the transaction
                                        val amount: Long, // Amount of money involved in the transaction
                                        val dateTime: Timestamp, // Timestamp of when the transaction occurred
                                        val transactionType: String, // Type of transaction (e.g., "Income", "Expense")
                                        val location: Location?, // Geographical location associated with the transaction, if available
                                        val amountAnomaly: Boolean = false, // Indicates if there is an anomaly with the amount
                                        val locationAnomaly: Boolean = false, // Indicates if there is an anomaly with the location
                                        val automatic: Boolean = false // Indicates if the transaction was created automatically
                                    )
                                    
                                    /**
                                     * Data class representing a geographical location.
                                     *
                                     * This class holds latitude and longitude coordinates for a specific location.
                                     *
                                     * @property latitude The latitude of the location.
                                     * @property longitude The longitude of the location.
                                     */
                                    data class Location(
                                        val latitude: Double, // Latitude of the location
                                        val longitude: Double // Longitude of the location
                                    )
                                    ```
                        - **views/**
                            - **transaction/**
                                - AddTransactionModal.kt
                                    ```
                                    package com.isis3510.spendiq.views.transaction
                                    
                                    import android.app.DatePickerDialog
                                    import androidx.compose.foundation.layout.*
                                    import androidx.compose.foundation.text.KeyboardOptions
                                    import androidx.compose.material.icons.Icons
                                    import androidx.compose.material.icons.filled.LocationOn
                                    import androidx.compose.material3.*
                                    import androidx.compose.runtime.*
                                    import androidx.compose.ui.Alignment
                                    import androidx.compose.ui.Modifier
                                    import androidx.compose.ui.graphics.Color
                                    import androidx.compose.ui.platform.LocalContext
                                    import androidx.compose.ui.text.input.KeyboardType
                                    import androidx.compose.ui.unit.dp
                                    import com.isis3510.spendiq.model.data.Transaction
                                    import com.isis3510.spendiq.model.data.Location
                                    import com.isis3510.spendiq.viewmodel.AccountViewModel
                                    import com.google.firebase.Timestamp
                                    import kotlinx.coroutines.launch
                                    import java.util.*
                                    import com.isis3510.spendiq.model.data.Account
                                    import com.isis3510.spendiq.services.LocationService
                                    import com.isis3510.spendiq.viewmodel.TransactionViewModel
                                    
                                    /**
                                     * AddTransactionModal composable function
                                     *
                                     * A modal for adding a new transaction. The function provides fields for transaction details
                                     * and checks account availability before submission. It includes a location option and date picker.
                                     *
                                     * @param accountViewModel [AccountViewModel] for retrieving account details
                                     * @param transactionViewModel [TransactionViewModel] for transaction-related operations
                                     * @param onDismiss Callback to dismiss the modal
                                     * @param onTransactionAdded Callback triggered after successfully adding a transaction
                                     */
                                    @OptIn(ExperimentalMaterial3Api::class)
                                    @Composable
                                    fun AddTransactionModal(
                                        accountViewModel: AccountViewModel,
                                        transactionViewModel: TransactionViewModel,
                                        onDismiss: () -> Unit,
                                        onTransactionAdded: () -> Unit
                                    ) {
                                        // State variables for form inputs
                                        var amount by remember { mutableStateOf("") }
                                        var transactionName by remember { mutableStateOf("") }
                                        var selectedDate by remember { mutableStateOf(Timestamp.now()) }
                                        var selectedTransactionType by remember { mutableStateOf("Expense") }
                                        var expandedTransactionType by remember { mutableStateOf(false) }
                                        var selectedAccount by remember { mutableStateOf<Account?>(null) }
                                        var expandedAccountType by remember { mutableStateOf(false) }
                                        var showNoAccountsDialog by remember { mutableStateOf(false) }
                                        var isLocationEnabled by remember { mutableStateOf(false) }
                                        var location by remember { mutableStateOf<android.location.Location?>(null) }
                                    
                                        // Collect accounts from ViewModel
                                        val accounts by accountViewModel.accounts.collectAsState()
                                    
                                        // Initialize context, calendar, and location service
                                        val context = LocalContext.current
                                        val calendar = Calendar.getInstance()
                                        val locationService = remember { LocationService(context) }
                                        val scope = rememberCoroutineScope()
                                    
                                        // Date picker dialog configuration
                                        val datePickerDialog = DatePickerDialog(
                                            context,
                                            { _, year, month, dayOfMonth ->
                                                calendar.set(year, month, dayOfMonth)
                                                selectedDate = Timestamp(calendar.time)
                                            },
                                            calendar.get(Calendar.YEAR),
                                            calendar.get(Calendar.MONTH),
                                            calendar.get(Calendar.DAY_OF_MONTH)
                                        )
                                    
                                        // Display a dialog if no accounts are available
                                        if (showNoAccountsDialog) {
                                            AlertDialog(
                                                onDismissRequest = { showNoAccountsDialog = false },
                                                title = { Text("No Accounts Available") },
                                                text = { Text("Please create an account in the Accounts section before adding a transaction.") },
                                                confirmButton = {
                                                    Button(onClick = { showNoAccountsDialog = false }) {
                                                        Text("OK")
                                                    }
                                                }
                                            )
                                        }
                                    
                                        // Check for available accounts when the component is launched
                                        LaunchedEffect(Unit) {
                                            if (accounts.isEmpty()) {
                                                showNoAccountsDialog = true
                                            }
                                        }
                                    
                                        // Modal layout and transaction form
                                        ModalBottomSheet(
                                            onDismissRequest = onDismiss
                                        ) {
                                            Column(
                                                modifier = Modifier
                                                    .fillMaxWidth()
                                                    .padding(16.dp)
                                            ) {
                                                Text("Add Transaction", style = MaterialTheme.typography.headlineSmall)
                                                Spacer(modifier = Modifier.height(16.dp))
                                    
                                                // Amount input field with digit-only filter
                                                OutlinedTextField(
                                                    value = amount,
                                                    onValueChange = { amount = it.filter { char -> char.isDigit() } },
                                                    label = { Text("Amount") },
                                                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
                                                    modifier = Modifier.fillMaxWidth(),
                                                    singleLine = true
                                                )
                                    
                                                Spacer(modifier = Modifier.height(8.dp))
                                    
                                                // Transaction name input field
                                                OutlinedTextField(
                                                    value = transactionName,
                                                    onValueChange = { transactionName = it },
                                                    label = { Text("Transaction Name") },
                                                    modifier = Modifier.fillMaxWidth(),
                                                    singleLine = true
                                                )
                                    
                                                Spacer(modifier = Modifier.height(8.dp))
                                    
                                                // Date picker button
                                                Button(onClick = { datePickerDialog.show() }) {
                                                    Text("Select Date: ${selectedDate.toDate().toString().substring(0, 10)}")
                                                }
                                    
                                                Spacer(modifier = Modifier.height(8.dp))
                                    
                                                // Transaction type dropdown menu
                                                ExposedDropdownMenuBox(
                                                    expanded = expandedTransactionType,
                                                    onExpandedChange = { expandedTransactionType = !expandedTransactionType }
                                                ) {
                                                    TextField(
                                                        value = selectedTransactionType,
                                                        onValueChange = {},
                                                        readOnly = true,
                                                        label = { Text("Transaction Type") },
                                                        trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = expandedTransactionType) },
                                                        modifier = Modifier.menuAnchor().fillMaxWidth()
                                                    )
                                                    ExposedDropdownMenu(
                                                        expanded = expandedTransactionType,
                                                        onDismissRequest = { expandedTransactionType = false }
                                                    ) {
                                                        DropdownMenuItem(
                                                            text = { Text("Income") },
                                                            onClick = {
                                                                selectedTransactionType = "Income"
                                                                expandedTransactionType = false
                                                            }
                                                        )
                                                        DropdownMenuItem(
                                                            text = { Text("Expense") },
                                                            onClick = {
                                                                selectedTransactionType = "Expense"
                                                                expandedTransactionType = false
                                                            }
                                                        )
                                                    }
                                                }
                                    
                                                Spacer(modifier = Modifier.height(8.dp))
                                    
                                                // Account selection dropdown if accounts are available
                                                if (accounts.isNotEmpty()) {
                                                    ExposedDropdownMenuBox(
                                                        expanded = expandedAccountType,
                                                        onExpandedChange = { expandedAccountType = !expandedAccountType }
                                                    ) {
                                                        TextField(
                                                            value = selectedAccount?.name ?: "",
                                                            onValueChange = {},
                                                            readOnly = true,
                                                            label = { Text("Select Account") },
                                                            trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = expandedAccountType) },
                                                            modifier = Modifier.menuAnchor().fillMaxWidth()
                                                        )
                                                        ExposedDropdownMenu(
                                                            expanded = expandedAccountType,
                                                            onDismissRequest = { expandedAccountType = false }
                                                        ) {
                                                            accounts.forEach { account ->
                                                                DropdownMenuItem(
                                                                    text = { Text(account.name) },
                                                                    onClick = {
                                                                        selectedAccount = account
                                                                        expandedAccountType = false
                                                                    }
                                                                )
                                                            }
                                                        }
                                                    }
                                    
                                                    Spacer(modifier = Modifier.height(8.dp))
                                    
                                                    // Location toggle row with switch
                                                    Row(
                                                        modifier = Modifier.fillMaxWidth(),
                                                        verticalAlignment = Alignment.CenterVertically
                                                    ) {
                                                        Icon(
                                                            imageVector = Icons.Default.LocationOn,
                                                            contentDescription = "Location",
                                                            tint = if (isLocationEnabled) MaterialTheme.colorScheme.primary else Color.Gray
                                                        )
                                                        Spacer(modifier = Modifier.width(8.dp))
                                                        Text("Include Location")
                                                        Spacer(modifier = Modifier.weight(1f))
                                                        Switch(
                                                            checked = isLocationEnabled,
                                                            onCheckedChange = { enabled ->
                                                                isLocationEnabled = enabled
                                                                if (enabled) {
                                                                    scope.launch {
                                                                        location = locationService.getCurrentLocation()
                                                                    }
                                                                } else {
                                                                    location = null
                                                                }
                                                            }
                                                        )
                                                    }
                                    
                                                    Spacer(modifier = Modifier.height(16.dp))
                                    
                                                    // Submit button for adding transaction
                                                    Button(
                                                        onClick = {
                                                            selectedAccount?.let { account ->
                                                                val transaction = Transaction(
                                                                    id = "", // Firestore will assign ID
                                                                    accountId = account.id,
                                                                    transactionName = transactionName,
                                                                    amount = amount.toLongOrNull() ?: 0L,
                                                                    dateTime = selectedDate,
                                                                    transactionType = selectedTransactionType,
                                                                    location = if (isLocationEnabled && location != null) {
                                                                        Location(
                                                                            latitude = location!!.latitude,
                                                                            longitude = location!!.longitude
                                                                        )
                                                                    } else null,
                                                                    automatic = false, // Add this line to explicitly set manual transactions
                                                                    amountAnomaly = false,
                                                                    locationAnomaly = false
                                                                )
                                                                transactionViewModel.addTransactionWithAccountCheck(transaction)
                                                                onTransactionAdded()
                                                                onDismiss()
                                                            }
                                                        },
                                                        enabled = amount.isNotEmpty() &&
                                                                transactionName.isNotEmpty() &&
                                                                selectedAccount != null,
                                                        modifier = Modifier.fillMaxWidth()
                                                    ) {
                                                        Text("Add Transaction")
                                                    }
                                                } else {
                                                    // Message when no accounts are available
                                                    Text(
                                                        "No accounts available. Please create an account first.",
                                                        style = MaterialTheme.typography.bodyMedium,
                                                        color = MaterialTheme.colorScheme.error,
                                                        modifier = Modifier.padding(vertical = 16.dp)
                                                    )
                                                }
                                            }
                                        }
                                    }
                                    ```
                            - **settings/**
                                - settingsMainView.kt
                                    ```
                                    package com.isis3510.spendiq.views.settings
                                    // epic                                    ```
                            - **offers/**
                                - OffersScreen.kt
                                    ```
                                    package com.isis3510.spendiq.views.offers
                                    
                                    import android.Manifest
                                    import android.content.Context
                                    import android.location.Location
                                    import androidx.compose.foundation.clickable
                                    import androidx.compose.foundation.layout.*
                                    import androidx.compose.foundation.lazy.LazyColumn
                                    import androidx.compose.foundation.lazy.items
                                    import androidx.compose.foundation.shape.RoundedCornerShape
                                    import androidx.compose.material.icons.Icons
                                    import androidx.compose.material.icons.filled.LocationOn
                                    import androidx.compose.material3.*
                                    import androidx.compose.runtime.*
                                    import androidx.compose.ui.Alignment
                                    import androidx.compose.ui.Modifier
                                    import androidx.compose.ui.layout.ContentScale
                                    import androidx.compose.ui.platform.LocalContext
                                    import androidx.compose.ui.text.font.FontWeight
                                    import androidx.compose.ui.unit.dp
                                    import androidx.compose.ui.unit.sp
                                    import androidx.navigation.NavController
                                    import coil.compose.AsyncImage
                                    import com.google.android.gms.location.LocationServices
                                    import com.isis3510.spendiq.model.data.Offer
                                    import com.isis3510.spendiq.viewmodel.AccountViewModel
                                    import com.isis3510.spendiq.viewmodel.OffersViewModel
                                    import com.isis3510.spendiq.views.common.BottomNavigation
                                    import kotlinx.coroutines.launch
                                    import android.content.pm.PackageManager
                                    import androidx.activity.compose.rememberLauncherForActivityResult
                                    import androidx.activity.result.contract.ActivityResultContracts
                                    import androidx.core.content.ContextCompat
                                    import com.isis3510.spendiq.viewmodel.TransactionViewModel
                                    import kotlinx.coroutines.tasks.await
                                    import java.text.DecimalFormat
                                    
                                    /**
                                     * OffersScreen composable function
                                     *
                                     * Displays a list of nearby sales offers to the user. This screen utilizes location permissions to
                                     * identify the user's current location and sorts the offers based on proximity to provide a more
                                     * relevant user experience.
                                     *
                                     * Key Features:
                                     * - Location-Based Filtering: Only displays offers within 1 kilometer of the user's current location.
                                     * - Permissions Handling: Manages location permissions and displays prompts if permission is not granted.
                                     * - Dynamic UI Components:
                                     *   - `LocationPermissionCard`: A card prompting users to enable location permissions if not granted.
                                     *   - `OfferCard`: Displays individual offer details, including store image, name, description,
                                     *     and an estimated distance from the user's current location.
                                     * - Navigation: Enables users to navigate to a detailed view of each offer when clicked.
                                     *
                                     * UI Structure:
                                     * - Scaffold with:
                                     *   - TopAppBar for the screen title.
                                     *   - BottomNavigation for easy navigation between sections.
                                     * - Column layout including:
                                     *   - `LocationPermissionCard` (if location access is not granted).
                                     *   - A list of filtered offers rendered as `OfferCard` elements.
                                     *
                                     * Supporting Functions:
                                     * - `getCurrentLocation`: Retrieves the user's current location if location permissions are granted.
                                     * - `sortOffersByDistance`: Filters and sorts offers by their proximity to the users location.
                                     * - `formatDistance`: Formats distances into meters or kilometers for display clarity.
                                     *
                                     * @param navController [NavController] used for navigating within the app.
                                     * @param viewModel [OffersViewModel] provides the list of offers.
                                     * @param transactionViewModel [TransactionViewModel] for integration with bottom navigation.
                                     * @param accountViewModel [AccountViewModel] for integration with bottom navigation.
                                     */
                                    
                                    @OptIn(ExperimentalMaterial3Api::class)
                                    @Composable
                                    fun OffersScreen(
                                        navController: NavController,
                                        viewModel: OffersViewModel,
                                        transactionViewModel: TransactionViewModel,
                                        accountViewModel: AccountViewModel
                                    ) {
                                        // Acceder al contexto y configurar el scope de corrutinas
                                        val context = LocalContext.current
                                        val scope = rememberCoroutineScope()
                                    
                                        // Gestin de estados para ofertas, ubicacin y permisos
                                        val offers by viewModel.offers.collectAsState()
                                        var currentLocation by remember { mutableStateOf<Location?>(null) }
                                        var sortedOffers by remember { mutableStateOf<List<Pair<Offer, Float?>>>(emptyList()) }
                                        var hasLocationPermission by remember {
                                            mutableStateOf(
                                                ContextCompat.checkSelfPermission(
                                                    context,
                                                    Manifest.permission.ACCESS_FINE_LOCATION
                                                ) == PackageManager.PERMISSION_GRANTED
                                            )
                                        }
                                    
                                        // Lanzador de solicitud de permisos para acceso a la ubicacin
                                        val locationPermissionLauncher = rememberLauncherForActivityResult(
                                            ActivityResultContracts.RequestPermission()
                                        ) { isGranted ->
                                            hasLocationPermission = isGranted
                                            if (isGranted) {
                                                scope.launch {
                                                    getCurrentLocation(context)?.let { location ->
                                                        currentLocation = location
                                                        sortedOffers = sortOffersByDistance(offers, location)
                                                    }
                                                }
                                            }
                                        }
                                    
                                        // Carga inicial de datos y comprobacin de permisos de ubicacin
                                        LaunchedEffect(Unit) {
                                            viewModel.fetchOffers()
                                            if (hasLocationPermission) {
                                                getCurrentLocation(context)?.let { location ->
                                                    currentLocation = location
                                                    sortedOffers = sortOffersByDistance(offers, location)
                                                }
                                            } else {
                                                locationPermissionLauncher.launch(Manifest.permission.ACCESS_FINE_LOCATION)
                                            }
                                        }
                                    
                                        // Reordenar y filtrar ofertas cada vez que cambie la lista de ofertas o la ubicacin actual
                                        LaunchedEffect(offers, currentLocation) {
                                            sortedOffers = sortOffersByDistance(offers, currentLocation)
                                        }
                                    
                                        // Diseo Scaffold con barra superior y navegacin inferior
                                        Scaffold(
                                            topBar = {
                                                TopAppBar(
                                                    title = { Text("Special offers in your area") },
                                                )
                                            },
                                            bottomBar = {
                                                BottomNavigation(navController = navController, transactionViewModel = transactionViewModel, accountViewModel)
                                            }
                                        ) { paddingValues ->
                                            Box(
                                                modifier = Modifier
                                                    .fillMaxSize()
                                                    .padding(paddingValues)
                                            ) {
                                                Column(
                                                    modifier = Modifier
                                                        .fillMaxSize()
                                                        .padding(horizontal = 16.dp)
                                                ) {
                                    
                                                    if (!hasLocationPermission) {
                                                        LocationPermissionCard(
                                                            onEnableClick = {
                                                                locationPermissionLauncher.launch(Manifest.permission.ACCESS_FINE_LOCATION)
                                                            }
                                                        )
                                                    }
                                    
                                    
                                                    Text(
                                                        "Based on the stores where you've shopped before, we believe these offers near your location may be of interest to you",
                                                        fontSize = 14.sp,
                                                        color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f),
                                                        modifier = Modifier.padding(vertical = 8.dp)
                                                    )
                                    
                                                    LazyColumn(
                                                        verticalArrangement = Arrangement.spacedBy(16.dp),
                                                        contentPadding = PaddingValues(vertical = 8.dp)
                                                    ) {
                                                        items(sortedOffers) { (offer, distance) ->
                                                            OfferCard(
                                                                offer = offer,
                                                                distance = distance,
                                                                onClick = {
                                                                    offer.id?.let { id ->
                                                                        navController.navigate("specialSalesDetail/$id")
                                                                    }
                                                                }
                                                            )
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    
                                    @Composable
                                    private fun LocationPermissionCard(onEnableClick: () -> Unit) {
                                        Card(
                                            modifier = Modifier
                                                .fillMaxWidth()
                                                .padding(vertical = 8.dp),
                                            colors = CardDefaults.cardColors(
                                                containerColor = MaterialTheme.colorScheme.errorContainer
                                            )
                                        ) {
                                            Row(
                                                modifier = Modifier
                                                    .padding(16.dp)
                                                    .fillMaxWidth(),
                                                verticalAlignment = Alignment.CenterVertically
                                            ) {
                                                Icon(
                                                    Icons.Default.LocationOn,
                                                    contentDescription = "Ubicacin",
                                                    tint = MaterialTheme.colorScheme.error
                                                )
                                                Spacer(modifier = Modifier.width(8.dp))
                                                Text(
                                                    "Habilita la ubicacin para mejores ofertas",
                                                    color = MaterialTheme.colorScheme.error,
                                                    modifier = Modifier.weight(1f)
                                                )
                                                TextButton(onClick = onEnableClick) {
                                                    Text("Habilitar")
                                                }
                                            }
                                        }
                                    }
                                    
                                    @Composable
                                    fun OfferCard(offer: Offer, distance: Float?, onClick: () -> Unit) {
                                        Card(
                                            modifier = Modifier
                                                .fillMaxWidth()
                                                .clickable(onClick = onClick),
                                            shape = RoundedCornerShape(12.dp),
                                            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
                                        ) {
                                            Column {
                                                // Imagen de la tienda
                                                offer.shopImage?.let { imageUrl ->
                                                    AsyncImage(
                                                        model = imageUrl,
                                                        contentDescription = "Imagen de la Tienda",
                                                        modifier = Modifier
                                                            .fillMaxWidth()
                                                            .height(180.dp),
                                                        contentScale = ContentScale.Crop
                                                    )
                                                }
                                    
                                                Column(
                                                    modifier = Modifier.padding(16.dp)
                                                ) {
                                                    // Nombre de la tienda y distancia
                                                    Row(
                                                        modifier = Modifier.fillMaxWidth(),
                                                        horizontalArrangement = Arrangement.SpaceBetween,
                                                        verticalAlignment = Alignment.CenterVertically
                                                    ) {
                                                        offer.placeName?.let {
                                                            Text(
                                                                text = it,
                                                                fontSize = 18.sp,
                                                                fontWeight = FontWeight.Bold
                                                            )
                                                        }
                                    
                                                        distance?.let {
                                                            Surface(
                                                                color = MaterialTheme.colorScheme.primaryContainer,
                                                                shape = RoundedCornerShape(16.dp)
                                                            ) {
                                                                Text(
                                                                    text = "${formatDistance(it)} de distancia",
                                                                    modifier = Modifier.padding(horizontal = 8.dp, vertical = 4.dp),
                                                                    fontSize = 12.sp
                                                                )
                                                            }
                                                        }
                                                    }
                                    
                                                    Spacer(modifier = Modifier.height(8.dp))
                                    
                                                    // Descripcin de la oferta
                                                    offer.offerDescription?.let {
                                                        Text(
                                                            text = it,
                                                            fontSize = 14.sp,
                                                            color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f),
                                                            modifier = Modifier.fillMaxWidth()
                                                        )
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    
                                    private suspend fun getCurrentLocation(context: Context): Location? {
                                        return try {
                                            val fusedLocationClient = LocationServices.getFusedLocationProviderClient(context)
                                            if (ContextCompat.checkSelfPermission(
                                                    context,
                                                    Manifest.permission.ACCESS_FINE_LOCATION
                                                ) == PackageManager.PERMISSION_GRANTED
                                            ) {
                                                fusedLocationClient.lastLocation.await()
                                            } else null
                                        } catch (e: Exception) {
                                            null
                                        }
                                    }
                                    
                                    private fun sortOffersByDistance(offers: List<Offer>, currentLocation: Location?): List<Pair<Offer, Float?>> {
                                        return offers.mapNotNull { offer ->
                                            if (currentLocation != null && offer.latitude != null && offer.longitude != null) {
                                                val offerLocation = Location("").apply {
                                                    latitude = offer.latitude
                                                    longitude = offer.longitude
                                                }
                                                val distance = currentLocation.distanceTo(offerLocation)
                                                if (distance <= 1000f) {
                                                    offer to distance
                                                } else {
                                                    null // Excluir ofertas que estn a ms de 1 km
                                                }
                                            } else {
                                                null // Excluir ofertas sin ubicacin vlida
                                            }
                                        }.sortedBy { it.second }
                                    }
                                    
                                    private fun formatDistance(meters: Float): String {
                                        val df = DecimalFormat("#.#")
                                        return when {
                                            meters < 1000 -> "${df.format(meters)}m"
                                            else -> "${df.format(meters / 1000)}km"
                                        }
                                    }
                                    ```
                                - SpecialSalesDetail.kt
                                    ```
                                    // SpecialSalesDetail.kt
                                    package com.isis3510.spendiq.views.offers
                                    
                                    
                                    import androidx.compose.foundation.layout.*
                                    import androidx.compose.foundation.rememberScrollState
                                    import androidx.compose.foundation.verticalScroll
                                    import androidx.compose.material.icons.Icons
                                    import androidx.compose.material.icons.automirrored.filled.ArrowBack
                                    import androidx.compose.material.icons.filled.LocationOn
                                    import androidx.compose.material3.*
                                    import androidx.compose.runtime.*
                                    import androidx.compose.ui.Modifier
                                    import androidx.compose.ui.layout.ContentScale
                                    import androidx.compose.ui.platform.LocalContext
                                    import androidx.compose.ui.text.font.FontWeight
                                    import androidx.compose.ui.unit.dp
                                    import androidx.compose.ui.unit.sp
                                    import coil.compose.AsyncImage
                                    import com.google.android.gms.maps.model.CameraPosition
                                    import com.google.android.gms.maps.model.LatLng
                                    import com.google.maps.android.compose.*
                                    import com.isis3510.spendiq.model.data.Offer
                                    import androidx.navigation.NavController
                                    import android.content.Intent
                                    import android.net.Uri
                                    import androidx.compose.ui.text.style.TextAlign
                                    import com.isis3510.spendiq.views.common.BottomNavigation
                                    import com.isis3510.spendiq.viewmodel.AccountViewModel
                                    import com.isis3510.spendiq.viewmodel.TransactionViewModel
                                    
                                    /**
                                     * SpecialSalesDetail composable function
                                     *
                                     * Displays detailed information about a special sales offer, including images, location, and descriptions.
                                     * The function provides navigation options and allows users to open the stores location in Google Maps.
                                     *
                                     * UI Structure:
                                     * - Top Bar: Includes a title ("Special Sales") and a back button to navigate back to the previous screen.
                                     * - Store Image: Displays the store's image at the top if available.
                                     * - Store Details:
                                     *     - Store name displayed in bold font.
                                     *     - A Google Map view with a marker at the stores location if latitude and longitude are provided.
                                     *     - Button to open the stores location in Google Maps app.
                                     * - Sales Information:
                                     *     - Section for displaying details about sales offers with an optional description.
                                     *     - Recommended offer reason displayed in a styled card if available.
                                     *
                                     * Navigation and Intents:
                                     * - Navigates back to the previous screen when the back button is pressed.
                                     * - Launches Google Maps with the stores location when the "Open in Maps" button is clicked.
                                     *
                                     * @param offer [Offer] containing details about the sales offer
                                     * @param navController [NavController] used for navigation to other screens
                                     */
                                    @OptIn(ExperimentalMaterial3Api::class)
                                    @Composable
                                    fun SpecialSalesDetail(
                                        offer: Offer,
                                        navController: NavController,
                                        transactionViewModel: TransactionViewModel,
                                        accountViewModel: AccountViewModel
                                    ) {
                                        // Context for starting external intents
                                        val context = LocalContext.current
                                        var isNavigating by remember { mutableStateOf(false) }
                                        val coroutineScope = rememberCoroutineScope()
                                    
                                        // Scaffold component to manage top-level layout including top bar
                                        Scaffold(
                                            topBar = {
                                                // Top bar with title and back navigation
                                                TopAppBar(
                                                    title = { Text("Special Sales") }, // Title of the screen
                                                    navigationIcon = {
                                                        // Back button for navigation
                                                        IconButton(onClick = { navController.popBackStack() }) {
                                                            Icon(Icons.AutoMirrored.Filled.ArrowBack, "Back") // Back icon
                                                        }
                                                    }
                                                )
                                            },
                                            bottomBar = {
                                                BottomNavigation(
                                                    navController = navController,
                                                    transactionViewModel = transactionViewModel,
                                                    accountViewModel = accountViewModel
                                                )
                                            }
                                        ) { padding ->
                                            Column(
                                                modifier = Modifier
                                                    .fillMaxSize()
                                                    .padding(padding)
                                                    .verticalScroll(rememberScrollState()) // Enables scrolling for the content
                                            ) {
                                                // Display the store logo and name
                                                offer.shopImage?.let { imageUrl ->
                                                    AsyncImage(
                                                        model = imageUrl, // URL of the image to load
                                                        contentDescription = "Store Image",
                                                        modifier = Modifier
                                                            .fillMaxWidth()
                                                            .height(200.dp), // Sets the image height to 200dp
                                                        contentScale = ContentScale.Crop // Crops image to fill available space
                                                    )
                                                }
                                    
                                                // Content column for offer details
                                                Column(
                                                    modifier = Modifier
                                                        .fillMaxWidth()
                                                        .padding(16.dp) // Adds padding around the content
                                                ) {
                                                    // Display the place name if available
                                                    offer.placeName?.let {
                                                        Text(
                                                            text = it,
                                                            fontSize = 24.sp,
                                                            fontWeight = FontWeight.Bold // Bold font style for emphasis
                                                        )
                                                    }
                                    
                                                    Spacer(modifier = Modifier.height(16.dp)) // Adds vertical spacing
                                    
                                                    // Display a map with the location if latitude and longitude are available
                                                    if (offer.latitude != null && offer.longitude != null) {
                                                        Card(
                                                            modifier = Modifier
                                                                .fillMaxWidth()
                                                                .height(200.dp) // Map height
                                                        ) {
                                                            GoogleMap(
                                                                modifier = Modifier.fillMaxSize(), // Expands to fill card
                                                                cameraPositionState = rememberCameraPositionState {
                                                                    position = CameraPosition.fromLatLngZoom(
                                                                        LatLng(offer.latitude, offer.longitude),
                                                                        15f // Zoom level for map view
                                                                    )
                                                                }
                                                            ) {
                                                                // Place a marker at the offer's location
                                                                Marker(
                                                                    state = MarkerState(position = LatLng(offer.latitude, offer.longitude)),
                                                                    title = offer.placeName // Title for marker
                                                                )
                                                            }
                                                        }
                                    
                                                        Spacer(modifier = Modifier.height(16.dp)) // Adds spacing below the map
                                    
                                                        // Button to open the location in Google Maps app
                                                        Button(
                                                            onClick = {
                                                                // Create a URI for location with place name as a label
                                                                val uri = Uri.parse("geo:${offer.latitude},${offer.longitude}?q=${offer.latitude},${offer.longitude}(${offer.placeName})")
                                                                val mapIntent = Intent(Intent.ACTION_VIEW, uri) // Intent to open maps
                                                                mapIntent.setPackage("com.google.android.apps.maps") // Restrict to Google Maps
                                                                if (mapIntent.resolveActivity(context.packageManager) != null) {
                                                                    context.startActivity(mapIntent) // Start Google Maps if available
                                                                }
                                                            },
                                                            modifier = Modifier.fillMaxWidth() // Full-width button
                                                        ) {
                                                            Icon(Icons.Default.LocationOn, contentDescription = null) // Location icon
                                                            Spacer(modifier = Modifier.width(8.dp)) // Spacing between icon and text
                                                            Text("Open in Maps") // Button label
                                                        }
                                                    }
                                    
                                                    Spacer(modifier = Modifier.height(24.dp)) // Extra spacing between sections
                                    
                                                    // Section for displaying sales information
                                                    Text(
                                                        text = "Sales",
                                                        fontSize = 20.sp,
                                                        fontWeight = FontWeight.Bold // Bold for section title
                                                    )
                                    
                                                    Spacer(modifier = Modifier.height(8.dp)) // Small spacing below section title
                                    
                                                    // Description of the offer if available
                                                    offer.offerDescription?.let {
                                                        Text(
                                                            text = it,
                                                            fontSize = 16.sp, // Regular font size for description
                                                            textAlign = TextAlign.Start,
                                                            modifier = Modifier.fillMaxWidth()
                                                        )
                                                    }
                                    
                                                    Spacer(modifier = Modifier.height(16.dp)) // Spacing before recommendation section
                                    
                                                    // Display recommendation reason in a styled card
                                                    offer.recommendationReason?.let {
                                                        Card(
                                                            modifier = Modifier.fillMaxWidth(),
                                                            colors = CardDefaults.cardColors(
                                                                containerColor = MaterialTheme.colorScheme.primaryContainer // Card background color
                                                            )
                                                        ) {
                                                            Text(
                                                                text = "Recommended because: $it",
                                                                modifier = Modifier.padding(16.dp), // Padding within card
                                                                color = MaterialTheme.colorScheme.onPrimaryContainer // Text color
                                                            )
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    ```
                            - **splash/**
                                - SplashScreen.kt
                                    ```
                                    package com.isis3510.spendiq.views.splash
                                    
                                    import androidx.compose.foundation.layout.Box
                                    import androidx.compose.foundation.layout.fillMaxSize
                                    import androidx.compose.material3.CircularProgressIndicator
                                    import androidx.compose.material3.Text
                                    import androidx.compose.runtime.Composable
                                    import androidx.compose.runtime.LaunchedEffect
                                    import androidx.compose.runtime.collectAsState
                                    import androidx.compose.ui.Alignment
                                    import androidx.compose.ui.Modifier
                                    import androidx.navigation.NavController
                                    import com.isis3510.spendiq.viewmodel.AuthState
                                    import com.isis3510.spendiq.viewmodel.AuthViewModel
                                    
                                    /**
                                     * SplashScreen composable function
                                     *
                                     * Displays a splash screen with a loading indicator while waiting for authentication status.
                                     * Based on the authentication state, it navigates to different parts of the application.
                                     *
                                     * @param navController [NavController] used for navigation
                                     * @param viewModel [AuthViewModel] that provides the current authentication state
                                     */
                                    @Composable
                                    fun SplashScreen(navController: NavController, viewModel: AuthViewModel) {
                                        // Collect the current authentication state from the viewModel
                                        val authState = viewModel.authState.collectAsState()
                                    
                                        // Main box layout for centering the splash screen content
                                        Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                                            // Render UI elements based on the authentication state
                                            when (authState.value) {
                                                AuthState.Loading -> {
                                                    // Loading state UI: show progress indicator and loading text
                                                    CircularProgressIndicator()
                                                    Text(text = "Loading...", modifier = Modifier.align(Alignment.BottomCenter))
                                                }
                                                else -> {
                                                    // Fallback UI: show progress indicator while awaiting state change
                                                    CircularProgressIndicator()
                                                }
                                            }
                                        }
                                    
                                        // Handle side effects based on changes in the authentication state
                                        LaunchedEffect(authState.value) {
                                            when (authState.value) {
                                                is AuthState.Authenticated -> {
                                                    // Navigate to main screen if authenticated
                                                    navController.navigate("main") {
                                                        popUpTo("splash") { inclusive = true }
                                                    }
                                                }
                                                is AuthState.EmailVerified -> {
                                                    // Navigate to main screen if email is verified
                                                    navController.navigate("main") {
                                                        popUpTo("splash") { inclusive = true }
                                                    }
                                                }
                                                is AuthState.EmailNotVerified -> {
                                                    // Navigate to authentication screen if email is not verified
                                                    navController.navigate("authentication") {
                                                        popUpTo("splash") { inclusive = true }
                                                    }
                                                }
                                                is AuthState.EmailVerificationSent -> {
                                                    // Navigate to authentication screen after verification email is sent
                                                    navController.navigate("authentication") {
                                                        popUpTo("splash") { inclusive = true }
                                                    }
                                                }
                                                is AuthState.Error,
                                                AuthState.Idle,
                                                AuthState.BiometricEnabled -> {
                                                    // Handle other states by navigating to authentication screen
                                                    navController.navigate("authentication") {
                                                        popUpTo("splash") { inclusive = true }
                                                    }
                                                }
                                                AuthState.Loading -> {
                                                    // Do nothing while in loading state
                                                }
                                                AuthState.BiometricAlreadyEnabled -> {
                                                    // Navigate to authentication screen if biometrics are already enabled
                                                    navController.navigate("authentication") {
                                                        popUpTo("splash") { inclusive = true }
                                                    }
                                                }
                                                AuthState.PasswordResetEmailSent -> {
                                                    // Placeholder for handling password reset email sent state
                                                    TODO() // Implement as needed
                                                }
                                            }
                                        }
                                    }
                                    ```
                            - MainActivity.kt
                                ```
                                package com.isis3510.spendiq.views
                                
                                import android.Manifest
                                import android.content.Intent
                                import android.content.pm.PackageManager
                                import android.os.Build
                                import android.os.Bundle
                                import android.provider.Settings
                                import android.util.Log
                                import androidx.activity.compose.setContent
                                import androidx.activity.result.contract.ActivityResultContracts
                                import androidx.annotation.RequiresApi
                                import androidx.compose.foundation.layout.*
                                import androidx.compose.material3.*
                                import androidx.compose.runtime.*
                                import androidx.compose.ui.Alignment
                                import androidx.compose.ui.Modifier
                                import androidx.compose.ui.unit.dp
                                import androidx.core.content.ContextCompat
                                import androidx.fragment.app.FragmentActivity
                                import androidx.lifecycle.viewmodel.compose.viewModel
                                import androidx.navigation.NavType
                                import androidx.navigation.compose.NavHost
                                import androidx.navigation.compose.composable
                                import androidx.navigation.compose.rememberNavController
                                import androidx.navigation.navArgument
                                import com.isis3510.spendiq.views.accounts.AccountsScreen
                                import com.isis3510.spendiq.views.main.MainContent
                                import com.isis3510.spendiq.views.splash.SplashScreen
                                import com.isis3510.spendiq.views.auth.AuthenticationScreen
                                import com.isis3510.spendiq.views.auth.LoginScreen
                                import com.isis3510.spendiq.views.auth.RegisterScreen
                                import com.isis3510.spendiq.views.profile.*
                                import com.isis3510.spendiq.views.theme.SpendiQTheme
                                import com.isis3510.spendiq.viewmodel.*
                                import com.isis3510.spendiq.views.accounts.AccountTransactionsScreen
                                import com.isis3510.spendiq.views.accounts.TransactionDetailsScreen
                                import com.isis3510.spendiq.views.offers.OffersScreen
                                import com.isis3510.spendiq.views.offers.SpecialSalesDetail
                                
                                class MainActivity : FragmentActivity() {
                                    companion object {
                                        private const val TAG = "MainActivity" // Tag for logging purposes
                                    }
                                
                                    // Array of permissions required by the app
                                    @RequiresApi(Build.VERSION_CODES.TIRAMISU)
                                    private val REQUIRED_PERMISSIONS = arrayOf(
                                        Manifest.permission.ACCESS_FINE_LOCATION,  // Location permission
                                        Manifest.permission.POST_NOTIFICATIONS     // Notifications permission
                                    )
                                
                                    // Launcher for requesting multiple permissions
                                    private val requestPermissionLauncher = registerForActivityResult(
                                        ActivityResultContracts.RequestMultiplePermissions()
                                    ) { permissions ->
                                        // Log whether all required permissions were granted or some were denied
                                        if (permissions.all { it.value }) {
                                            Log.d(TAG, "All required permissions granted")
                                        } else {
                                            Log.d(TAG, "Some permissions were denied")
                                        }
                                    }
                                
                                    // Launcher specifically for requesting location permission
                                    private val requestLocationPermissionLauncher =
                                        registerForActivityResult(ActivityResultContracts.RequestPermission()) { isGranted: Boolean ->
                                            // Log the result of the location permission request
                                            if (isGranted) {
                                                Log.d(TAG, "Location permission granted")
                                            } else {
                                                Log.d(TAG, "Location permission denied")
                                            }
                                        }
                                
                                    @RequiresApi(Build.VERSION_CODES.TIRAMISU)
                                    override fun onCreate(savedInstanceState: Bundle?) {
                                        super.onCreate(savedInstanceState)
                                
                                        // Check if notification service access is enabled; if not, request it
                                        if (!isNotificationServiceEnabled()) {
                                            requestNotificationPermission()
                                        }
                                
                                        // Request location permission if it is not already granted
                                        requestLocationPermission()
                                
                                        // Check if all required permissions are granted; if not, request them
                                        if (!hasRequiredPermissions()) {
                                            requestPermissionLauncher.launch(REQUIRED_PERMISSIONS)
                                        }
                                
                                        // Initialize the main content view with Jetpack Compose and theme setup
                                        setContent {
                                            SpendiQTheme {
                                                Surface(
                                                    modifier = Modifier.fillMaxSize(),
                                                    color = MaterialTheme.colorScheme.background
                                                ) {
                                                    // Set up navigation controller for managing screen navigation
                                                    val navController = rememberNavController()
                                                    val authViewModel: AuthViewModel = viewModel()
                                                    val accountViewModel: AccountViewModel = viewModel()
                                                    val transactionViewModel: TransactionViewModel = viewModel()
                                                    val offersViewModel: OffersViewModel = viewModel()
                                                    val profileViewModel: ProfileViewModel = viewModel()
                                                    val userViewModel: UserViewModel = viewModel()
                                                    val connectivityViewModel: ConnectivityViewModel = viewModel()
                                                    val userData by userViewModel.userData.collectAsState()
                                
                                                    // Configure navigation destinations
                                                    NavHost(navController = navController, startDestination = "splash") {
                                                        // Define each composable destination with corresponding screen
                                                        composable("splash") {
                                                            SplashScreen(navController, authViewModel)
                                                        }
                                                        composable("authentication") {
                                                            AuthenticationScreen(navController)
                                                        }
                                                        composable("login") {
                                                            LoginScreen(navController, authViewModel, connectivityViewModel)
                                                        }
                                                        composable("register") {
                                                            RegisterScreen(navController, authViewModel)
                                                        }
                                                        composable("main") {
                                                            MainContent(navController, authViewModel, accountViewModel, offersViewModel, transactionViewModel)
                                                        }
                                                        composable("promos") {
                                                            OffersScreen(navController, offersViewModel, transactionViewModel, accountViewModel)
                                                        }
                                                        composable("profile") {
                                                            ProfileScreen(navController, authViewModel, transactionViewModel, accountViewModel, profileViewModel)
                                                        }
                                                        composable("accounts") {
                                                            AccountsScreen(navController, accountViewModel, transactionViewModel)
                                                        }
                                                        composable("profileNotificationsScreen") {
                                                            ProfileNotificationsScreen(navController, transactionViewModel, accountViewModel)
                                                        }
                                                        composable("profileSecurityScreen") {
                                                            ProfileSecurityScreen(navController, transactionViewModel, accountViewModel)
                                                        }
                                                        composable("profileAccountScreen") {
                                                            ProfileAccountScreen(navController, userData, transactionViewModel, accountViewModel)
                                                        }
                                                        composable("profileLaGScreen") {
                                                            ProfileLaGScreen(navController, transactionViewModel, accountViewModel)
                                                        }
                                                        composable("profileStatisticsScreen") {
                                                            ProfileStatisticsScreen(navController, transactionViewModel, accountViewModel)
                                                        }
                                                        composable("profileHelpScreen") {
                                                            ProfileHelpScreen(navController, transactionViewModel, accountViewModel)
                                                        }
                                                        composable("profileInfoScreen") {
                                                            ProfileInfoScreen(navController, transactionViewModel, accountViewModel)
                                                        }
                                                        // Define destination for account transactions with accountId as argument
                                                        composable(
                                                            route = "accountTransactions/{accountId}",
                                                            arguments = listOf(navArgument("accountId") { type = NavType.StringType })
                                                        ) { backStackEntry ->
                                                            AccountTransactionsScreen(
                                                                navController,
                                                                backStackEntry.arguments?.getString("accountId") ?: ""
                                                            )
                                                        }
                                                        // Define destination for special sales detail with offerId as argument
                                                        composable(
                                                            route = "specialSalesDetail/{offerId}",
                                                            arguments = listOf(navArgument("offerId") { type = NavType.StringType })
                                                        ) { backStackEntry ->
                                                            val offerId = backStackEntry.arguments?.getString("offerId")
                                                            if (offerId != null) {
                                                                // Fetch offer details based on the offerId
                                                                LaunchedEffect(offerId) {
                                                                    offersViewModel.getOfferById(offerId)
                                                                }
                                
                                                                val selectedOffer by offersViewModel.selectedOffer.collectAsState()
                                                                val uiState by offersViewModel.uiState.collectAsState()
                                
                                                                // Display loading, error, or success UI based on UI state
                                                                when (uiState) {
                                                                    is OffersViewModel.UiState.Loading -> {
                                                                        Box(modifier = Modifier.fillMaxSize()) {
                                                                            CircularProgressIndicator(
                                                                                modifier = Modifier.align(Alignment.Center)
                                                                            )
                                                                        }
                                                                    }
                                                                    is OffersViewModel.UiState.Error -> {
                                                                        Box(
                                                                            modifier = Modifier
                                                                                .fillMaxSize()
                                                                                .padding(16.dp)
                                                                        ) {
                                                                            Text(
                                                                                text = (uiState as OffersViewModel.UiState.Error).message,
                                                                                modifier = Modifier.align(Alignment.Center)
                                                                            )
                                                                        }
                                                                    }
                                                                    is OffersViewModel.UiState.Success -> {
                                                                        selectedOffer?.let { offer ->
                                                                            SpecialSalesDetail(
                                                                                offer = offer,
                                                                                navController = navController,
                                                                                accountViewModel = accountViewModel,
                                                                                transactionViewModel = transactionViewModel
                                                                            )
                                                                        }
                                                                    }
                                                                    else -> { /* No operation */ }
                                                                }
                                                            }
                                                        }
                                                        // Define destination for transaction details with accountId and transactionId as arguments
                                                        composable(
                                                            route = "transactionDetails/{accountId}/{transactionId}",
                                                            arguments = listOf(
                                                                navArgument("accountId") { type = NavType.StringType },
                                                                navArgument("transactionId") { type = NavType.StringType }
                                                            )
                                                        ) { backStackEntry ->
                                                            val accountId = backStackEntry.arguments?.getString("accountId") ?: ""
                                                            val transactionId = backStackEntry.arguments?.getString("transactionId") ?: ""
                                                            TransactionDetailsScreen(
                                                                navController = navController,
                                                                accountViewModel = accountViewModel,
                                                                accountId = accountId,
                                                                transactionId = transactionId,
                                                                transactionViewModel = transactionViewModel
                                                            )
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                
                                    // Check if all permissions in REQUIRED_PERMISSIONS array are granted
                                    @RequiresApi(Build.VERSION_CODES.TIRAMISU)
                                    private fun hasRequiredPermissions(): Boolean {
                                        return REQUIRED_PERMISSIONS.all {
                                            ContextCompat.checkSelfPermission(this, it) == PackageManager.PERMISSION_GRANTED
                                        }
                                    }
                                
                                    // Function to request notification listener permission
                                    private fun requestNotificationPermission() {
                                        val intent = Intent(Settings.ACTION_NOTIFICATION_LISTENER_SETTINGS)
                                        startActivity(intent)
                                    }
                                
                                    // Function to check if notification service is enabled
                                    private fun isNotificationServiceEnabled(): Boolean {
                                        val packageName = applicationContext.packageName
                                        val enabledListeners = Settings.Secure.getString(contentResolver, "enabled_notification_listeners")
                                        return enabledListeners?.contains(packageName) == true
                                    }
                                
                                    // Function to request location permission if not already granted
                                    private fun requestLocationPermission() {
                                        if (ContextCompat.checkSelfPermission(
                                                this,
                                                Manifest.permission.ACCESS_FINE_LOCATION
                                            ) != PackageManager.PERMISSION_GRANTED
                                        ) {
                                            requestLocationPermissionLauncher.launch(Manifest.permission.ACCESS_FINE_LOCATION)
                                        }
                                    }
                                }
                                ```
                            - **auth/**
                                - AuthenticationScreen.kt
                                    ```
                                    package com.isis3510.spendiq.views.auth
                                    
                                    import androidx.compose.foundation.Image
                                    import androidx.compose.foundation.background
                                    import androidx.compose.foundation.layout.*
                                    import androidx.compose.foundation.shape.RoundedCornerShape
                                    import androidx.compose.material.icons.Icons
                                    import androidx.compose.material.icons.filled.Close
                                    import androidx.compose.material.icons.filled.Warning
                                    import androidx.compose.material3.*
                                    import androidx.compose.runtime.Composable
                                    import androidx.compose.ui.Alignment
                                    import androidx.compose.ui.Modifier
                                    import androidx.compose.ui.draw.clip
                                    import androidx.compose.ui.graphics.Color
                                    import androidx.compose.ui.res.painterResource
                                    import androidx.compose.ui.text.TextStyle
                                    import androidx.compose.ui.text.font.FontFamily
                                    import androidx.compose.ui.text.font.FontWeight
                                    import androidx.compose.ui.text.style.TextAlign
                                    import androidx.compose.ui.unit.dp
                                    import androidx.compose.ui.unit.em
                                    import androidx.compose.ui.unit.sp
                                    import androidx.navigation.NavController
                                    import com.google.firebase.crashlytics.FirebaseCrashlytics
                                    import com.isis3510.spendiq.R
                                    
                                    /**
                                     * AuthenticationScreen composable function
                                     *
                                     * Serves as the entry point for the application's authentication workflow, presenting the user with options
                                     * to either log in or sign up for a new account. It includes visual elements such as the app title and a
                                     * background logo image, providing a welcoming layout to guide users in accessing the application.
                                     * Additionally, it incorporates Firebase Crashlytics integration, allowing for testing of error handling
                                     * (both recoverable and non-recoverable errors) by simulating a logged recoverable error and a forced crash.
                                     *
                                     * Key Features:
                                     * - App Branding: Displays the app title ("SpendiQ") in a prominent, bold font, paired with a background logo.
                                     * - Authentication Navigation:
                                     *   - Login: Navigates to the Login screen.
                                     *   - Register: Navigates to the Register screen.
                                     * - Firebase Crashlytics Integration:
                                     *   - Simulated Recoverable Error: Logs a non-fatal error to Firebase Crashlytics, simulating recoverable error handling.
                                     *   - Forced Crash: Triggers a forced app crash, useful for testing error tracking setup.
                                     *
                                     * UI Structure:
                                     * - Background logo image for branding.
                                     * - Centralized layout with app title, login, and register buttons.
                                     * - Row layout for icons that allow simulated bug/error handling and crash testing.
                                     *
                                     * Supporting Components:
                                     * - Buttons for Login and Register actions, both spanning the full width of the screen.
                                     * - Error handling icons that log simulated errors or trigger a crash.
                                     *
                                     * @param navController [NavController] used to navigate to either the Login or Register screen.
                                     */
                                    
                                    @Composable
                                    fun AuthenticationScreen(navController: NavController) {
                                        Box(
                                            modifier = Modifier
                                                .fillMaxSize()
                                                .clip(shape = RoundedCornerShape(7.dp))
                                                .background(color = Color.White)
                                        ) {
                                            // Background Logo Image
                                            Image(
                                                painter = painterResource(id = R.drawable.logogroupstart),
                                                contentDescription = "Logo Group",
                                                modifier = Modifier
                                                    .align(alignment = Alignment.TopStart)
                                                    .offset(x = (-63).dp, y = 376.dp)
                                                    .fillMaxWidth()
                                                    .height(470.dp)
                                            )
                                    
                                            // Main Column Layout for Centered Content
                                            Column(
                                                modifier = Modifier
                                                    .fillMaxSize()
                                                    .padding(horizontal = 16.dp), // Padding for horizontal sides
                                                horizontalAlignment = Alignment.CenterHorizontally, // Center content horizontally
                                                verticalArrangement = Arrangement.Center
                                            ) {
                                                // App Title "SpendiQ"
                                                Text(
                                                    text = "SpendiQ",
                                                    color = Color.Black,
                                                    textAlign = TextAlign.Center,
                                                    style = TextStyle(
                                                        fontSize = 73.sp,
                                                        fontFamily = FontFamily.SansSerif,
                                                        fontWeight = FontWeight.Bold
                                                    )
                                                )
                                    
                                                Spacer(modifier = Modifier.height(96.dp)) // Space below title
                                    
                                                // Row for Simulated Error and Crash Icons
                                                Row(
                                                    verticalAlignment = Alignment.CenterVertically,
                                                    modifier = Modifier.padding(16.dp)
                                                ) {
                                                    // Recoverable Error (Bug) Icon
                                                    IconButton(
                                                        onClick = {
                                                            // Set up Firebase Crashlytics instance
                                                            val crashlytics = FirebaseCrashlytics.getInstance()
                                    
                                                            try {
                                                                // Simulate an operation causing a recoverable error
                                                                throw Exception("Simulated recoverable error: Validation failed")
                                                            } catch (e: Exception) {
                                                                // Log the recoverable error in Crashlytics
                                                                crashlytics.recordException(e) // Logs non-fatal error without crashing
                                                                crashlytics.setCustomKey("Bug_AS", "Simulated recoverable error in Authorization Screen")
                                                                crashlytics.log("Non-fatal exception logged")
                                    
                                                                // Optionally show a user-facing message here
                                                                println("Recoverable error caught and logged")
                                                                crashlytics.sendUnsentReports()
                                                            }
                                                        }
                                                    ) {
                                                        Icon(
                                                            imageVector = Icons.Default.Warning,
                                                            contentDescription = "Bug Icon",
                                                            tint = Color(0xffb3cb54) // Color for warning icon
                                                        )
                                                    }
                                    
                                                    Spacer(modifier = Modifier.width(16.dp)) // Space between icons
                                    
                                                    // Forced Crash Icon
                                                    IconButton(
                                                        onClick = {
                                                            val crashlytics = FirebaseCrashlytics.getInstance()
                                                            crashlytics.setCustomKey("Crash_AS", "Crash in Authorization Screen")
                                                            crashlytics.log("App Crash after pushing crash button")
                                                            throw RuntimeException("Forced Crash from Authorization Screen")
                                                        }
                                                    ) {
                                                        Icon(
                                                            imageVector = Icons.Default.Close,
                                                            contentDescription = "Crash Icon",
                                                            tint = Color(0xffc33ba5) // Color for crash icon
                                                        )
                                                    }
                                                }
                                    
                                                // Log In Button
                                                Button(
                                                    onClick = { navController.navigate("login") },
                                                    shape = RoundedCornerShape(7.dp),
                                                    colors = ButtonDefaults.buttonColors(containerColor = Color(0xff65558f)),
                                                    contentPadding = PaddingValues(horizontal = 16.dp, vertical = 10.dp),
                                                    modifier = Modifier
                                                        .fillMaxWidth()
                                                        .height(42.dp)
                                                ) {
                                                    Text(
                                                        text = "Log In",
                                                        color = Color.White,
                                                        textAlign = TextAlign.Center,
                                                        lineHeight = 1.43.em,
                                                        style = TextStyle(
                                                            fontSize = 14.sp,
                                                            fontFamily = FontFamily.SansSerif,
                                                            letterSpacing = 0.1.sp
                                                        )
                                                    )
                                                }
                                    
                                                Spacer(modifier = Modifier.height(16.dp)) // Space between buttons
                                    
                                                // Register Button
                                                Button(
                                                    onClick = { navController.navigate("register") },
                                                    shape = RoundedCornerShape(7.dp),
                                                    colors = ButtonDefaults.buttonColors(containerColor = Color(0xff65558f)),
                                                    contentPadding = PaddingValues(horizontal = 24.dp, vertical = 10.dp),
                                                    modifier = Modifier
                                                        .fillMaxWidth()
                                                        .height(42.dp)
                                                ) {
                                                    Text(
                                                        text = "Sign Up",
                                                        color = Color.White,
                                                        textAlign = TextAlign.Center,
                                                        lineHeight = 1.43.em,
                                                        style = TextStyle(
                                                            fontSize = 14.sp,
                                                            fontFamily = FontFamily.SansSerif,
                                                            letterSpacing = 0.1.sp
                                                        )
                                                    )
                                                }
                                    
                                                Spacer(modifier = Modifier.height(260.dp)) // Space below buttons
                                            }
                                        }
                                    }                                    ```
                                - LoginScreen.kt
                                    ```
                                    package com.isis3510.spendiq.views.auth
                                    
                                    import android.widget.Toast
                                    import androidx.compose.foundation.Image
                                    import androidx.compose.foundation.background
                                    import androidx.compose.foundation.clickable
                                    import androidx.compose.foundation.layout.*
                                    import androidx.compose.foundation.rememberScrollState
                                    import androidx.compose.foundation.shape.RoundedCornerShape
                                    import androidx.compose.foundation.text.KeyboardActions
                                    import androidx.compose.foundation.text.KeyboardOptions
                                    import androidx.compose.foundation.verticalScroll
                                    import androidx.compose.material3.AlertDialog
                                    import androidx.compose.material3.IconButton
                                    import androidx.compose.material.icons.Icons
                                    import androidx.compose.material.icons.filled.Email
                                    import androidx.compose.material.icons.filled.Lock
                                    import androidx.compose.material3.*
                                    import androidx.compose.runtime.*
                                    import androidx.compose.runtime.livedata.observeAsState
                                    import androidx.compose.ui.Alignment
                                    import androidx.compose.ui.Modifier
                                    import androidx.compose.ui.focus.FocusDirection
                                    import androidx.compose.ui.graphics.Color
                                    import androidx.compose.ui.platform.LocalContext
                                    import androidx.compose.ui.platform.LocalFocusManager
                                    import androidx.compose.ui.res.painterResource
                                    import androidx.compose.ui.text.TextStyle
                                    import androidx.compose.ui.text.font.FontFamily
                                    import androidx.compose.ui.text.font.FontWeight
                                    import androidx.compose.ui.text.input.ImeAction
                                    import androidx.compose.ui.text.input.KeyboardType
                                    import androidx.compose.ui.text.input.PasswordVisualTransformation
                                    import androidx.compose.ui.text.input.VisualTransformation
                                    import androidx.compose.ui.text.style.TextAlign
                                    import androidx.compose.ui.unit.dp
                                    import androidx.compose.ui.unit.sp
                                    import androidx.fragment.app.FragmentActivity
                                    import androidx.navigation.NavController
                                    import com.isis3510.spendiq.R
                                    import com.isis3510.spendiq.viewmodel.AuthState
                                    import com.isis3510.spendiq.viewmodel.AuthViewModel
                                    import com.isis3510.spendiq.viewmodel.ConnectivityViewModel
                                    import com.isis3510.spendiq.views.theme.Purple40
                                    import kotlinx.coroutines.delay
                                    
                                    /**
                                     * LoginScreen composable function
                                     *
                                     * Provides the user interface for user login, including fields for email and password,
                                     * support for biometric login, and a password reset option. The login screen also reacts
                                     * to network connectivity changes and presents feedback messages based on authentication state.
                                     *
                                     * Key Features:
                                     * - Email and Password Input: Users enter their login credentials with real-time password visibility toggle.
                                     * - Biometric Authentication: Users can enable or log in using biometric authentication (e.g., fingerprint).
                                     * - Password Reset: Includes a "Forgot your password?" option, prompting a dialog for password reset.
                                     * - Network Connectivity Awareness: Displays a toast message when the network connection status changes.
                                     * - Authentication Status Handling: Manages states for loading, success, errors, email verification,
                                     *   biometric status, and password reset confirmation.
                                     *
                                     * UI Structure:
                                     * - Box layout for background logo alignment.
                                     * - Column layout containing:
                                     *   - App title.
                                     *   - Input fields for email and password.
                                     *   - Button to trigger login and text for password reset.
                                     *   - Conditional AlertDialogs for resetting passwords and enabling biometrics.
                                     * - Bottom Row layout with options for enabling biometrics and accessing help.
                                     *
                                     * Supporting Components:
                                     * - `OutlinedTextField`: Email and password fields with specific styling and icons.
                                     * - `AlertDialog`: Used for both password reset and biometric enabling dialogs.
                                     * - Authentication State Handling: Reacts to state changes with toast messages or by showing dialogs.
                                     *
                                     * @param navController [NavController] to navigate to other screens upon successful login.
                                     * @param viewModel [AuthViewModel] responsible for handling authentication logic and states.
                                     * @param connectivityViewModel [ConnectivityViewModel] observes network status for enabling/disabling the login button.
                                     */
                                    
                                    @OptIn(ExperimentalMaterial3Api::class)
                                    @Composable
                                    fun LoginScreen(
                                        navController: NavController,
                                        viewModel: AuthViewModel,
                                        connectivityViewModel: ConnectivityViewModel
                                    ) {
                                        // State variables for input fields, visibility toggle, focus, and auth state
                                        var email by remember { mutableStateOf("") }
                                        var password by remember { mutableStateOf("") }
                                        var passwordVisible by remember { mutableStateOf(false) }
                                        val focusManager = LocalFocusManager.current
                                        val authState by viewModel.authState.collectAsState()
                                        val context = LocalContext.current
                                    
                                        // Reset password and biometric dialog visibility
                                        var showResetPasswordDialog by remember { mutableStateOf(false) }
                                        var resetEmail by remember { mutableStateOf("") }
                                        var isBackButtonEnabled by remember { mutableStateOf(true) }
                                        var showBiometricDialog by remember { mutableStateOf(false) }
                                    
                                        //Connection & Eventual Connectivity
                                        val isLogInButtonEnable by connectivityViewModel.isConnected.observeAsState(true)
                                        var previousConnectionState by remember { mutableStateOf(isLogInButtonEnable) }
                                    
                                        Box(
                                            modifier = Modifier
                                                .fillMaxWidth()
                                                .verticalScroll(rememberScrollState())
                                        ) {
                                            // Background logo image
                                            Image(
                                                painter = painterResource(id = R.drawable.logo_log_in),
                                                contentDescription = "Background Logo",
                                                modifier = Modifier
                                                    .fillMaxWidth()
                                                    .aspectRatio(1f)
                                                    .align(Alignment.TopCenter)
                                                    .offset(y = 75.dp)
                                            )
                                    
                                            // Back button at the top
                                            Row(
                                                modifier = Modifier
                                                    .fillMaxWidth()
                                                    .padding(start = 16.dp, top = 24.dp),
                                                verticalAlignment = Alignment.CenterVertically,
                                                horizontalArrangement = Arrangement.Start
                                            ) {
                                                IconButton(
                                                    onClick = {
                                                        if (isBackButtonEnabled) {
                                                            isBackButtonEnabled = false
                                                            navController.popBackStack()
                                                        }
                                                    },
                                                    enabled = isBackButtonEnabled,
                                                    modifier = Modifier.size(36.dp)
                                                ) {
                                                    Icon(
                                                        painter = painterResource(id = R.drawable.round_arrow_back_ios_24),
                                                        contentDescription = "Back",
                                                        tint = Purple40,
                                                        modifier = Modifier.size(24.dp)
                                                    )
                                                }
                                            }
                                    
                                            // Main content
                                            Column(
                                                modifier = Modifier
                                                    .fillMaxSize()
                                                    .padding(horizontal = 24.dp),
                                                horizontalAlignment = Alignment.CenterHorizontally
                                            ) {
                                                Spacer(modifier = Modifier.height(113.dp))
                                    
                                                // App title
                                                Text(
                                                    text = "SpendiQ",
                                                    color = MaterialTheme.colorScheme.onPrimary,
                                                    textAlign = TextAlign.Center,
                                                    style = TextStyle(
                                                        fontSize = 73.sp,
                                                        fontFamily = FontFamily.SansSerif,
                                                        fontWeight = FontWeight.Bold
                                                    )
                                                )
                                    
                                                Spacer(modifier = Modifier.height(210.dp))
                                    
                                                // Email input field
                                                OutlinedTextField(
                                                    value = email,
                                                    onValueChange = { email = it },
                                                    placeholder = { Text("Email") },
                                                    modifier = Modifier
                                                        .fillMaxWidth()
                                                        .padding(vertical = 4.dp),
                                                    leadingIcon = { Icon(Icons.Default.Email, contentDescription = "Email", tint = Color(0xFFD9D9D9)) },
                                                    shape = RoundedCornerShape(50),
                                                    colors = OutlinedTextFieldDefaults.colors(
                                                        focusedBorderColor = Purple40,
                                                        unfocusedBorderColor = Purple40
                                                    ),
                                                    keyboardOptions = KeyboardOptions(
                                                        keyboardType = KeyboardType.Email,
                                                        imeAction = ImeAction.Next
                                                    ),
                                                    keyboardActions = KeyboardActions(
                                                        onNext = { focusManager.moveFocus(FocusDirection.Down) }
                                                    )
                                                )
                                    
                                                Spacer(modifier = Modifier.height(16.dp))
                                    
                                                // Password input field with visibility toggle and biometric icon
                                                OutlinedTextField(
                                                    value = password,
                                                    onValueChange = { password = it },
                                                    placeholder = { Text("Password") },
                                                    singleLine = true,
                                                    visualTransformation = if (passwordVisible) VisualTransformation.None else PasswordVisualTransformation(),
                                                    modifier = Modifier
                                                        .fillMaxWidth()
                                                        .padding(vertical = 4.dp),
                                                    leadingIcon = {
                                                        Icon(
                                                            imageVector = Icons.Default.Lock,
                                                            contentDescription = "Password Icon",
                                                            tint = Color(0xFFD9D9D9)
                                                        )
                                                    },
                                                    trailingIcon = {
                                                        Row {
                                                            IconButton(
                                                                onClick = { passwordVisible = !passwordVisible }
                                                            ) {
                                                                Icon(
                                                                    painter = painterResource(id = if (passwordVisible) R.drawable.round_visibility_24 else R.drawable.baseline_visibility_off_24),
                                                                    contentDescription = if (passwordVisible) "Hide password" else "Show password",
                                                                    tint = Color.Gray
                                                                )
                                                            }
                                                            IconButton(
                                                                onClick = {
                                                                    viewModel.setupBiometricPrompt(
                                                                        context as FragmentActivity,
                                                                        onSuccess = { viewModel.loginWithBiometrics() },
                                                                        onError = { /* Handle error */ }
                                                                    )
                                                                    viewModel.showBiometricPrompt()
                                                                }
                                                            ) {
                                                                Icon(
                                                                    painter = painterResource(id = R.drawable.fingerprint),
                                                                    contentDescription = "Fingerprint",
                                                                    modifier = Modifier.size(24.dp),
                                                                    tint = Color.Gray
                                                                )
                                                            }
                                                        }
                                                    },
                                                    shape = RoundedCornerShape(50),
                                                    colors = OutlinedTextFieldDefaults.colors(
                                                        focusedBorderColor = Purple40,
                                                        unfocusedBorderColor = Purple40
                                                    ),
                                                    keyboardOptions = KeyboardOptions(
                                                        keyboardType = KeyboardType.Password,
                                                        imeAction = ImeAction.Done
                                                    ),
                                                    keyboardActions = KeyboardActions(
                                                        onDone = { focusManager.moveFocus(FocusDirection.Down) }
                                                    )
                                                )
                                    
                                                Spacer(modifier = Modifier.height(24.dp))
                                    
                                                // Login button
                                                Button(
                                                    onClick = { viewModel.login(email, password) },
                                                    shape = RoundedCornerShape(7.dp),
                                                    colors = ButtonDefaults.buttonColors(containerColor = Color(0xff65558f)),
                                                    modifier = Modifier
                                                        .fillMaxWidth()
                                                        .height(48.dp),
                                                    enabled = isLogInButtonEnable
                                                ) {
                                                    Text(
                                                        text = "Log In",
                                                        fontSize = 16.sp,
                                                        color = Color.White
                                                    )
                                                }
                                    
                                                Spacer(modifier = Modifier.height(24.dp))
                                    
                                                // Forgot password option
                                                Text(
                                                    text = "Forgot your password?",
                                                    color = Color(0xff589ddd),
                                                    modifier = Modifier.clickable { showResetPasswordDialog = true },
                                                    style = TextStyle(fontSize = 16.sp)
                                                )
                                    
                                                // Reset password dialog
                                                if (showResetPasswordDialog) {
                                                    AlertDialog(
                                                        onDismissRequest = { showResetPasswordDialog = false },
                                                        title = {
                                                            Text(text = "Reset Password")
                                                        },
                                                        text = {
                                                            Column {
                                                                Text(
                                                                    text = "Enter your email address to receive a password reset link.",
                                                                    style = TextStyle(fontSize = 14.sp)
                                                                )
                                                                Spacer(modifier = Modifier.height(8.dp))
                                                                OutlinedTextField(
                                                                    value = resetEmail,
                                                                    onValueChange = { resetEmail = it },
                                                                    label = { Text("Email") },
                                                                    singleLine = true,
                                                                    modifier = Modifier.fillMaxWidth()
                                                                )
                                                            }
                                                        },
                                                        confirmButton = {
                                                            Button(
                                                                onClick = {
                                                                    viewModel.sendPasswordResetEmail(resetEmail)
                                                                    showResetPasswordDialog = false
                                                                },
                                                                colors = ButtonDefaults.buttonColors(containerColor = Color(0xff65558f))
                                                            ) {
                                                                Text("Send", color = Color.White)
                                                            }
                                                        },
                                                        dismissButton = {
                                                            TextButton(onClick = { showResetPasswordDialog = false }) {
                                                                Text("Cancel")
                                                            }
                                                        }
                                                    )
                                                }
                                    
                                                // Authentication and error handling messages
                                                when (authState) {
                                                    is AuthState.PasswordResetEmailSent -> {
                                                        Text(
                                                            text = "Password reset email sent successfully.",
                                                            color = Color(0xffb3cb54),
                                                            textAlign = TextAlign.Center,
                                                            style = TextStyle(fontSize = 16.sp),
                                                            modifier = Modifier
                                                                .fillMaxWidth()
                                                                .padding(16.dp)
                                                        )
                                                    }
                                                    is AuthState.Error -> {
                                                        val errorMessage = if ((authState as AuthState.Error).message.contains("network", ignoreCase = true)) {
                                                            "It looks like you're offline. Please check your network connection and try again to log in."
                                                        } else {
                                                            (authState as AuthState.Error).message
                                                        }
                                                        Text(
                                                            text = errorMessage,
                                                            color = MaterialTheme.colorScheme.error,
                                                            textAlign = TextAlign.Center,
                                                            style = TextStyle(fontSize = 16.sp),
                                                            modifier = Modifier
                                                                .fillMaxWidth()
                                                                .padding(16.dp)
                                                        )
                                                    }
                                                    is AuthState.Authenticated -> {
                                                        LaunchedEffect(Unit) {
                                                            viewModel.checkEmailVerification()
                                                        }
                                                    }
                                                    is AuthState.EmailNotVerified -> {
                                                        Text("Please verify your email to continue.")
                                                        Button(onClick = { viewModel.sendEmailVerification() }) {
                                                            Text("Resend verification email")
                                                        }
                                                    }
                                                    is AuthState.EmailVerified -> {
                                                        LaunchedEffect(Unit) {
                                                            navController.navigate("main") {
                                                                popUpTo("authentication") { inclusive = true }
                                                            }
                                                        }
                                                    }
                                                    is AuthState.BiometricAlreadyEnabled ->
                                                    {
                                                        Toast.makeText(context, "Biometrics Already Enabled", Toast.LENGTH_SHORT).show()
                                                    }
                                                    else -> { /* Handle other states */ }
                                                }
                                    
                                                // Spacer for adjusting layout
                                                Spacer(modifier = Modifier.weight(1f))
                                    
                                                // Enable biometrics and help options
                                                Row(
                                                    modifier = Modifier
                                                        .fillMaxWidth()
                                                        .padding(vertical = 32.dp),
                                                    horizontalArrangement = Arrangement.SpaceEvenly
                                                ) {
                                                    Text(
                                                        text = "Enable Biometrics",
                                                        color = Color(0xffc33ba5),
                                                        modifier = Modifier.clickable {
                                                            showBiometricDialog = true
                                                        },
                                                        style = TextStyle(fontSize = 16.sp)
                                                    )
                                    
                                                    Box(
                                                        modifier = Modifier
                                                            .width(2.dp)
                                                            .height(24.dp)
                                                            .background(Color(0xff5875dd).copy(alpha = 0.53f))
                                                    )
                                    
                                                    Text(
                                                        text = "Help",
                                                        color = Color(0xffb3cb54),
                                                        modifier = Modifier.clickable { /* Handle help */ },
                                                        style = TextStyle(fontSize = 16.sp)
                                                    )
                                                }
                                            }
                                    
                                            // Biometric enable dialog
                                            if (showBiometricDialog) {
                                                AlertDialog(
                                                    onDismissRequest = { showBiometricDialog = false },
                                                    title = { Text(text = "Enable Biometrics") },
                                                    text = { Text("Are you sure you want to enable biometric login?") },
                                                    confirmButton = {
                                                        Button(
                                                            onClick = {
                                                                viewModel.enableBiometricLogin(email, password)
                                                                showBiometricDialog = false
                                                            },
                                                            colors = ButtonDefaults.buttonColors(containerColor = Color(0xff65558f))
                                                        ) {
                                                            Text("Accept", color = Color.White)
                                                        }
                                                    },
                                                    dismissButton = {
                                                        TextButton(onClick = { showBiometricDialog = false }) {
                                                            Text("Cancel")
                                                        }
                                                    }
                                                )
                                            }
                                    
                                            if (isLogInButtonEnable != previousConnectionState) {
                                                if (isLogInButtonEnable) {
                                                    Toast.makeText(context, "Back Online!", Toast.LENGTH_SHORT).show()
                                                } else {
                                                    Toast.makeText(context, "It looks like you're offline. Please check your network connection", Toast.LENGTH_SHORT).show()
                                                }
                                                previousConnectionState = isLogInButtonEnable
                                            }
                                    
                                            // Reset AuthState after displaying messages
                                            LaunchedEffect(authState) {
                                                if (authState is AuthState.PasswordResetEmailSent || authState is AuthState.Error) {
                                                    delay(3000)
                                                    viewModel.resetAuthState()
                                                }
                                            }
                                        }
                                    }
                                    ```
                                - RegisterScreen.kt
                                    ```
                                    package com.isis3510.spendiq.views.auth
                                    
                                    import android.app.DatePickerDialog
                                    import android.util.Patterns
                                    import android.widget.DatePicker
                                    import androidx.compose.foundation.background
                                    import androidx.compose.foundation.clickable
                                    import androidx.compose.foundation.layout.*
                                    import androidx.compose.foundation.rememberScrollState
                                    import androidx.compose.foundation.selection.toggleable
                                    import androidx.compose.foundation.shape.RoundedCornerShape
                                    import androidx.compose.foundation.text.KeyboardOptions
                                    import androidx.compose.foundation.verticalScroll
                                    import androidx.compose.material.icons.Icons
                                    import androidx.compose.material.icons.automirrored.filled.Send
                                    import androidx.compose.material.icons.filled.*
                                    import androidx.compose.material3.*
                                    import androidx.compose.runtime.*
                                    import androidx.compose.ui.Alignment
                                    import androidx.compose.ui.Modifier
                                    import androidx.compose.ui.graphics.Color
                                    import androidx.compose.ui.platform.LocalContext
                                    import androidx.compose.ui.res.painterResource
                                    import androidx.compose.ui.semantics.Role
                                    import androidx.compose.ui.text.TextStyle
                                    import androidx.compose.ui.text.font.FontFamily
                                    import androidx.compose.ui.text.input.KeyboardType
                                    import androidx.compose.ui.text.input.PasswordVisualTransformation
                                    import androidx.compose.ui.text.style.TextAlign
                                    import androidx.compose.ui.unit.dp
                                    import androidx.compose.ui.unit.sp
                                    import androidx.navigation.NavController
                                    import com.isis3510.spendiq.R
                                    import com.isis3510.spendiq.viewmodel.AuthState
                                    import com.isis3510.spendiq.viewmodel.AuthViewModel
                                    import com.isis3510.spendiq.views.common.AlertDialogCreate
                                    import com.isis3510.spendiq.views.theme.Purple40
                                    import java.text.SimpleDateFormat
                                    import java.util.*
                                    
                                    /**
                                     * RegisterScreen composable function
                                     *
                                     * Provides the user interface for the account registration process, allowing users to input their personal
                                     * information and create an account. The form includes fields for the user's full name, email, phone number,
                                     * birth date, and password. A checkbox for agreeing to terms and conditions and password confirmation are
                                     * also required to complete the registration.
                                     *
                                     * Key Features:
                                     * - Input Validation: Real-time validation for email format and phone number length.
                                     * - Date Picker: Allows users to select a birth date using a DatePicker dialog.
                                     * - Form Validation: Ensures that all required fields are filled out and meet validation criteria before
                                     *   enabling the "Sign Up" button.
                                     * - Authentication Status Handling: Manages the different states of authentication, such as loading,
                                     *   error, email verification, and success.
                                     *
                                     * UI Structure:
                                     * - Column layout that vertically scrolls for comfortable input on smaller screens.
                                     * - Fields for full name, email, phone number, birth date, password, and confirm password.
                                     * - Checkbox for terms and conditions agreement.
                                     * - "Sign Up" button that triggers registration if all criteria are met.
                                     *
                                     * Supporting Components:
                                     * - `OutlinedTextField`: Used for user input fields, each with specific styling and icons.
                                     * - `DatePickerDialog`: Allows selection of birth date.
                                     * - Authentication State Handling: Renders feedback or actions based on current authentication state,
                                     *   such as showing a progress indicator or error message.
                                     *
                                     * @param navController [NavController] to navigate within the app after registration.
                                     * @param viewModel [AuthViewModel] that handles registration logic and authentication states.
                                     */
                                    
                                    @Composable
                                    fun RegisterScreen(
                                        navController: NavController,
                                        viewModel: AuthViewModel
                                    ) {
                                        // State variables for user inputs
                                        var email by remember { mutableStateOf("") }
                                        var password by remember { mutableStateOf("") }
                                        var confirmPassword by remember { mutableStateOf("") }
                                        var fullName by remember { mutableStateOf("") }
                                        var phoneNumber by remember { mutableStateOf("") }
                                        var birthDate by remember { mutableStateOf("") }
                                        val authState by viewModel.authState.collectAsState()
                                        var checkedState by remember { mutableStateOf(false) } // Terms and conditions checkbox
                                        var isBackButtonEnabled by remember { mutableStateOf(true) } // Back button control
                                        var enableEmailVerSentDialog by remember { mutableStateOf(false) }
                                        var isBirthdateValid by remember { mutableStateOf(false) }
                                    
                                        // DatePicker setup for birth date
                                        val context = LocalContext.current
                                        val calendar = Calendar.getInstance()
                                        val year = calendar.get(Calendar.YEAR)
                                        val month = calendar.get(Calendar.MONTH)
                                        val day = calendar.get(Calendar.DAY_OF_MONTH)
                                        val dateFormatter = SimpleDateFormat("dd/MM/yyyy", Locale.getDefault())
                                    
                                        fun isDateMoreThan16YearsOld(date: Calendar): Boolean {
                                            val today = Calendar.getInstance()
                                            today.add(Calendar.YEAR, -16)
                                            return date.before(today)
                                        }
                                    
                                        val datePickerDialog = DatePickerDialog(
                                            context,
                                            { _: DatePicker, selectedYear: Int, selectedMonth: Int, selectedDay: Int ->
                                                calendar.set(selectedYear, selectedMonth, selectedDay)
                                                birthDate = dateFormatter.format(calendar.time)
                                    
                                                // Check if the birthdate is more than 16 years ago
                                                isBirthdateValid = isDateMoreThan16YearsOld(calendar)
                                            },
                                            year,
                                            month,
                                            day
                                        )
                                    
                                        datePickerDialog.datePicker.maxDate = System.currentTimeMillis() // Restricts date selection to today or earlier
                                        calendar.add(Calendar.YEAR, -100) // Sets minimum date to 100 years ago
                                        datePickerDialog.datePicker.minDate = calendar.timeInMillis
                                    
                                        Column(
                                            modifier = Modifier
                                                .fillMaxSize()
                                                .verticalScroll(rememberScrollState())
                                                .background(color = Color.White)
                                                .padding(horizontal = 16.dp),
                                            verticalArrangement = Arrangement.Top
                                        ) {
                                            // Back button
                                            Row(
                                                modifier = Modifier
                                                    .fillMaxWidth()
                                                    .padding(top = 16.dp),
                                                verticalAlignment = Alignment.CenterVertically,
                                                horizontalArrangement = Arrangement.Start
                                            ) {
                                                IconButton(
                                                    onClick = {
                                                        if (isBackButtonEnabled) {
                                                            isBackButtonEnabled = false
                                                            navController.popBackStack()
                                                        }
                                                    },
                                                    enabled = isBackButtonEnabled,
                                                    modifier = Modifier.size(24.dp)
                                                ) {
                                                    Icon(
                                                        painter = painterResource(id = R.drawable.round_arrow_back_ios_24),
                                                        contentDescription = "Back",
                                                        tint = Purple40,
                                                        modifier = Modifier.size(24.dp)
                                                    )
                                                }
                                            }
                                    
                                            Spacer(modifier = Modifier.height(32.dp))
                                    
                                            // Title
                                            Column(
                                                modifier = Modifier
                                                    .fillMaxWidth()
                                                    .padding(vertical = 16.dp),
                                                horizontalAlignment = Alignment.CenterHorizontally
                                            ) {
                                                Text(
                                                    text = "Create Free Account",
                                                    color = Color.Black,
                                                    textAlign = TextAlign.Center,
                                                    style = TextStyle(
                                                        fontSize = 40.sp,
                                                        fontFamily = FontFamily.SansSerif
                                                    )
                                                )
                                                Spacer(modifier = Modifier.height(32.dp))
                                            }
                                    
                                            // Form fields
                                            Column(
                                                modifier = Modifier.fillMaxWidth(),
                                                horizontalAlignment = Alignment.CenterHorizontally
                                            ) {
                                                // Full Name field
                                                OutlinedTextField(
                                                    value = fullName,
                                                    onValueChange = { fullName = it },
                                                    placeholder = { Text("Full Name") },
                                                    modifier = Modifier
                                                        .fillMaxWidth(0.9f)
                                                        .padding(vertical = 4.dp),
                                                    leadingIcon = { Icon(Icons.Default.Person, contentDescription = "Person", tint = Color(0xffb3cb54)) },
                                                    shape = RoundedCornerShape(50),
                                                    colors = OutlinedTextFieldDefaults.colors(
                                                        focusedBorderColor = Purple40,
                                                        unfocusedBorderColor = Purple40
                                                    ),
                                                    singleLine = true
                                                )
                                    
                                                // Email field with validation
                                                val isEmailValid = remember(email) { Patterns.EMAIL_ADDRESS.matcher(email).matches() }
                                                OutlinedTextField(
                                                    value = email,
                                                    onValueChange = { email = it },
                                                    placeholder = { Text("Email") },
                                                    isError = email.isNotEmpty() && !isEmailValid,
                                                    modifier = Modifier
                                                        .fillMaxWidth(0.9f)
                                                        .padding(vertical = 4.dp),
                                                    leadingIcon = { Icon(Icons.Default.Email, contentDescription = "Email", tint = Color(0xffb3cb54)) },
                                                    shape = RoundedCornerShape(50),
                                                    colors = OutlinedTextFieldDefaults.colors(
                                                        focusedBorderColor = Purple40,
                                                        unfocusedBorderColor = Purple40
                                                    ),
                                                    singleLine = true,
                                                    keyboardOptions = KeyboardOptions.Default.copy(keyboardType = KeyboardType.Email)
                                                )
                                                if (email.isNotEmpty() && !isEmailValid) {
                                                    Text(
                                                        text = "Invalid email format",
                                                        color = MaterialTheme.colorScheme.error,
                                                        style = TextStyle(fontSize = 12.sp)
                                                    )
                                                }
                                    
                                                // Phone number field with validation
                                                val isPhoneValid = remember(phoneNumber) { phoneNumber.all { it.isDigit() } && phoneNumber.length >= 10 }
                                                OutlinedTextField(
                                                    value = phoneNumber,
                                                    onValueChange = { if (it.all { char -> char.isDigit() }) phoneNumber = it },
                                                    placeholder = { Text("Phone Number") },
                                                    isError = phoneNumber.isNotEmpty() && !isPhoneValid,
                                                    modifier = Modifier
                                                        .fillMaxWidth(0.9f)
                                                        .padding(vertical = 4.dp),
                                                    leadingIcon = { Icon(Icons.Default.Phone, contentDescription = "Phone", tint = Color(0xffb3cb54)) },
                                                    shape = RoundedCornerShape(50),
                                                    colors = OutlinedTextFieldDefaults.colors(
                                                        focusedBorderColor = Purple40,
                                                        unfocusedBorderColor = Purple40
                                                    ),
                                                    singleLine = true,
                                                    keyboardOptions = KeyboardOptions.Default.copy(keyboardType = KeyboardType.Number)
                                                )
                                                if (phoneNumber.isNotEmpty() && !isPhoneValid) {
                                                    Text(
                                                        text = "Phone number must have at least 10 digits",
                                                        color = MaterialTheme.colorScheme.error,
                                                        style = TextStyle(fontSize = 12.sp)
                                                    )
                                                }
                                    
                                                // Birth Date field
                                                OutlinedTextField(
                                                    value = birthDate,
                                                    onValueChange = { },
                                                    placeholder = { Text("Birth Date (Click to select)") },
                                                    modifier = Modifier
                                                        .fillMaxWidth(0.9f)
                                                        .padding(vertical = 4.dp)
                                                        .clickable { datePickerDialog.show() },
                                                    leadingIcon = { Icon(Icons.Default.DateRange, contentDescription = "Calendar", tint = Color(0xffc33ba5)) },
                                                    readOnly = true,
                                                    enabled = false,
                                                    shape = RoundedCornerShape(50),
                                                    colors = OutlinedTextFieldDefaults.colors(
                                                        disabledBorderColor = Purple40,
                                                        disabledTextColor = Color.Black,
                                                        disabledPlaceholderColor = Color.Black
                                                    ),
                                                    singleLine = true
                                                )
                                                if (birthDate.isNotEmpty() && !isBirthdateValid) {
                                                    Text(
                                                        text = "You must be at least 16 years old",
                                                        color = MaterialTheme.colorScheme.error,
                                                        style = TextStyle(fontSize = 12.sp)
                                                    )
                                                }
                                    
                                                // Password and Confirm Password fields
                                                val isPasswordValid = remember(password) { password.length >= 6 }
                                                OutlinedTextField(
                                                    value = password,
                                                    onValueChange = { password = it },
                                                    placeholder = { Text("Password") },
                                                    visualTransformation = PasswordVisualTransformation(),
                                                    modifier = Modifier
                                                        .fillMaxWidth(0.9f)
                                                        .padding(vertical = 4.dp),
                                                    leadingIcon = { Icon(Icons.Default.Lock, contentDescription = "Lock1", tint = Color(0xffc33ba5)) },
                                                    shape = RoundedCornerShape(50),
                                                    colors = OutlinedTextFieldDefaults.colors(
                                                        focusedBorderColor = Purple40,
                                                        unfocusedBorderColor = Purple40
                                                    ),
                                                    singleLine = true,
                                                    keyboardOptions = KeyboardOptions.Default.copy(keyboardType = KeyboardType.Password)
                                                )
                                                if (password.isNotEmpty() && !isPasswordValid) {
                                                    Text(
                                                        text = "Password must at least have 6 letters",
                                                        color = MaterialTheme.colorScheme.error,
                                                        style = TextStyle(fontSize = 12.sp)
                                                    )
                                                }
                                    
                                                val isConfirmPasswordValid = remember(confirmPassword) {confirmPassword == password}
                                                OutlinedTextField(
                                                    value = confirmPassword,
                                                    onValueChange = { confirmPassword = it },
                                                    placeholder = { Text("Confirm Password") },
                                                    visualTransformation = PasswordVisualTransformation(),
                                                    modifier = Modifier
                                                        .fillMaxWidth(0.9f)
                                                        .padding(vertical = 4.dp),
                                                    leadingIcon = { Icon(Icons.Default.Lock, contentDescription = "Lock2", tint = Color(0xffc33ba5)) },
                                                    shape = RoundedCornerShape(50),
                                                    colors = OutlinedTextFieldDefaults.colors(
                                                        focusedBorderColor = Purple40,
                                                        unfocusedBorderColor = Purple40
                                                    ),
                                                    singleLine = true,
                                                    keyboardOptions = KeyboardOptions.Default.copy(keyboardType = KeyboardType.Password)
                                                )
                                                if (confirmPassword.isNotEmpty() && !isConfirmPasswordValid) {
                                                    Text(
                                                        text = "Passwords do not match",
                                                        color = MaterialTheme.colorScheme.error,
                                                        style = TextStyle(fontSize = 12.sp)
                                                    )
                                                }
                                    
                                                // Terms and Conditions Checkbox
                                                Row(
                                                    Modifier
                                                        .fillMaxWidth(0.9f)
                                                        .toggleable(
                                                            value = checkedState,
                                                            onValueChange = { checkedState = it },
                                                            role = Role.Checkbox
                                                        )
                                                        .padding(vertical = 8.dp),
                                                    verticalAlignment = Alignment.CenterVertically
                                                ) {
                                                    Checkbox(
                                                        checked = checkedState,
                                                        onCheckedChange = { checkedState = it },
                                                        colors = CheckboxDefaults.colors(
                                                            checkedColor = Purple40,
                                                            uncheckedColor = Color.Gray
                                                        )
                                                    )
                                                    Text(text = "Accept Terms & Conditions", modifier = Modifier.padding(start = 16.dp))
                                                }
                                    
                                                Spacer(modifier = Modifier.height(16.dp))
                                    
                                                // Sign Up Button
                                                Button(
                                                    onClick = {
                                                        if (password == confirmPassword && checkedState) {
                                                            viewModel.register(email, password, fullName, phoneNumber, birthDate)
                                                        }
                                                    },
                                                    enabled = password == confirmPassword && checkedState &&
                                                            email.isNotEmpty() && fullName.isNotEmpty() && isBirthdateValid &&
                                                            birthDate.isNotEmpty() && phoneNumber.isNotEmpty() &&
                                                            isEmailValid && isPhoneValid,
                                                    shape = RoundedCornerShape(7.dp),
                                                    modifier = Modifier
                                                        .fillMaxWidth(0.6f)
                                                        .padding(vertical = 16.dp),
                                                    colors = ButtonDefaults.buttonColors(containerColor = Color(0xff65558f))
                                                ) {
                                                    Text("Sign Up", color = Color.White, textAlign = TextAlign.Center)
                                                }
                                    
                                                Spacer(modifier = Modifier.height(16.dp))
                                    
                                                if (enableEmailVerSentDialog)
                                                {
                                                    AlertDialogCreate({enableEmailVerSentDialog = false},
                                                        { enableEmailVerSentDialog = false
                                                            viewModel.checkEmailVerification() },
                                                        "Verification Email Sent",
                                                        "Please check your inbox. After verifying, click on CONFIRM to continue.",
                                                        Icons.AutoMirrored.Filled.Send,
                                                        false)
                                                }
                                    
                                                // Authentication state feedback
                                                when (authState) {
                                                    is AuthState.Loading -> CircularProgressIndicator()
                                                    is AuthState.Error -> Text(
                                                        (authState as AuthState.Error).message,
                                                        color = MaterialTheme.colorScheme.error
                                                    )
                                                    is AuthState.Authenticated -> {
                                                        LaunchedEffect(Unit) {
                                                            viewModel.sendEmailVerification()
                                                        }
                                                    }
                                                    is AuthState.EmailVerificationSent -> {
                                                        enableEmailVerSentDialog = true
                                                    }
                                                    is AuthState.EmailVerified -> {
                                                        LaunchedEffect(Unit) {
                                                            navController.navigate("main") {
                                                                popUpTo("authentication") { inclusive = true }
                                                            }
                                                        }
                                                    }
                                                    else -> {}
                                                }
                                            }
                                        }
                                    }
                                    ```
                            - **common/**
                                - AlertDialog.kt
                                    ```
                                    package com.isis3510.spendiq.views.common
                                    
                                    import androidx.compose.material3.AlertDialog
                                    import androidx.compose.material3.Icon
                                    import androidx.compose.material3.Text
                                    import androidx.compose.material3.TextButton
                                    import androidx.compose.runtime.Composable
                                    import androidx.compose.ui.graphics.vector.ImageVector
                                    
                                    @Composable
                                    fun AlertDialogCreate(
                                        onDismissRequest: () -> Unit,
                                        onConfirmation: () -> Unit,
                                        dialogTitle: String,
                                        dialogText: String,
                                        icon: ImageVector,
                                        enableDismissButton: Boolean
                                    ) {
                                        AlertDialog(
                                            icon = {
                                                Icon(icon, contentDescription = "Example Icon")
                                            },
                                            title = {
                                                Text(text = dialogTitle)
                                            },
                                            text = {
                                                Text(text = dialogText)
                                            },
                                            onDismissRequest = {
                                                onDismissRequest()
                                            },
                                            confirmButton = {
                                                TextButton(
                                                    onClick = {
                                                        onConfirmation()
                                                    }
                                                ) {
                                                    Text("Confirm")
                                                }
                                            },
                                            dismissButton = {
                                                TextButton(
                                                    onClick = {
                                                        onDismissRequest()
                                                    },
                                                    enabled = enableDismissButton
                                                ) {
                                                    Text("Cancel")
                                                }
                                            }
                                        )
                                    }                                    ```
                                - BarChart.kt
                                    ```
                                    package com.isis3510.spendiq.views.common
                                    
                                    import androidx.compose.foundation.Canvas
                                    import androidx.compose.foundation.isSystemInDarkTheme
                                    import androidx.compose.runtime.Composable
                                    import androidx.compose.ui.Modifier
                                    import androidx.compose.ui.graphics.Color
                                    import androidx.compose.ui.geometry.Offset
                                    import androidx.compose.ui.geometry.Size
                                    
                                    @Composable
                                    fun BarChart(
                                        modifier: Modifier = Modifier,
                                        data: Map<String, Long>,
                                        isDarkTheme: Boolean = isSystemInDarkTheme()
                                    ) {
                                        val maxAmount = data.values.maxOrNull() ?: 0L
                                        val maxBarHeight = if (maxAmount != 0L) maxAmount else 1L
                                        val barColors = if (isDarkTheme) {
                                            listOf(Color.Cyan, Color.Magenta)
                                        } else {
                                            listOf(Color(0xFFB3CB54), Color(0xFFE57373))
                                        }
                                    
                                        val sortedData = data.toList().sortedBy { it.first }
                                    
                                        Canvas(modifier = modifier) {
                                            val barWidth = size.width / (data.size * 2)
                                            var xPosition = barWidth / 2
                                    
                                            sortedData.forEach { (accountName, amount) ->
                                                val barHeightRatio = amount.toFloat() / maxBarHeight.toFloat()
                                                val barHeight = barHeightRatio * size.height
                                                drawRect(
                                                    color = if (amount >= 0L) barColors[0] else barColors[1],
                                                    topLeft = Offset(xPosition, size.height - barHeight),
                                                    size = Size(barWidth, barHeight)
                                                )
                                                xPosition += barWidth * 2
                                            }
                                        }
                                    }
                                    ```
                                - BottomNavigation.kt
                                    ```
                                    package com.isis3510.spendiq.views.common
                                    
                                    import androidx.compose.foundation.background
                                    import androidx.compose.foundation.layout.*
                                    import androidx.compose.foundation.shape.CircleShape
                                    import androidx.compose.foundation.shape.RoundedCornerShape
                                    import androidx.compose.material3.*
                                    import androidx.compose.runtime.*
                                    import androidx.compose.ui.Alignment
                                    import androidx.compose.ui.Modifier
                                    import androidx.compose.ui.draw.clip
                                    import androidx.compose.ui.graphics.Color
                                    import androidx.compose.ui.res.painterResource
                                    import androidx.compose.ui.text.font.FontWeight
                                    import androidx.compose.ui.unit.dp
                                    import androidx.compose.ui.unit.sp
                                    import androidx.navigation.NavController
                                    import androidx.navigation.compose.currentBackStackEntryAsState
                                    import com.isis3510.spendiq.R
                                    import com.isis3510.spendiq.viewmodel.AccountViewModel
                                    import com.isis3510.spendiq.viewmodel.TransactionViewModel
                                    import com.isis3510.spendiq.views.transaction.AddTransactionModal
                                    
                                    /**
                                     * BottomNavigation composable function
                                     *
                                     * This component renders a custom bottom navigation bar for the app, allowing users to navigate between
                                     * key sections: Home, Promotions, Accounts, and Profile. The bar also includes a centered button for adding
                                     * new transactions, which opens a modal when clicked.
                                     *
                                     * Key Features:
                                     * - Navigation Icons: Provides navigation icons for the main app sections.
                                     * - Add Transaction Button: Centered button to open a modal for adding new transactions.
                                     * - Route Highlighting: Highlights the active icon based on the current route.
                                     *
                                     * Functionality:
                                     * - `BottomNavigation`: Displays the navigation bar with icons and labels. It manages the visibility of
                                     *   `AddTransactionModal`, which allows users to input transaction details.
                                     * - `NavItem`: Displays each navigation item with an icon and label, with dynamic color based on selection.
                                     * - `AddTransactionButton`: Renders a circular button at the center of the navigation bar to trigger the add
                                     *   transaction modal.
                                     * - `isCurrentRoute`: Extension function on `NavController` to check if a given route is currently active.
                                     *
                                     * Supporting Components:
                                     * - `NavItem`: Used for each navigation icon (Home, Promos, Accounts, Profile) with an icon and label.
                                     * - `AddTransactionButton`: A circular button that opens `AddTransactionModal` when clicked.
                                     * - `AddTransactionModal`: A modal dialog for creating a new transaction, triggered by the Add button.
                                     *
                                     * @param navController [NavController] used to manage navigation between screens.
                                     * @param transactionViewModel [TransactionViewModel] manages transactions, passed to the modal.
                                     * @param accountViewModel [AccountViewModel] provides account-related data, passed to the modal.
                                     */
                                    @Composable
                                    fun BottomNavigation(
                                        navController: NavController,
                                        transactionViewModel: TransactionViewModel,
                                        accountViewModel: AccountViewModel // Add AccountViewModel parameter
                                    ) {
                                        var showAddTransactionModal by remember { mutableStateOf(false) }
                                    
                                        // Main container for the navigation bar, with rounded corners and white background
                                        Box(
                                            modifier = Modifier
                                                .fillMaxWidth()
                                                .height(77.dp)
                                                .clip(RoundedCornerShape(topStart = 16.dp, topEnd = 16.dp))
                                                .background(Color.White)
                                        ) {
                                            // Row layout to arrange navigation items horizontally
                                            Row(
                                                modifier = Modifier.fillMaxSize(),
                                                horizontalArrangement = Arrangement.SpaceEvenly,
                                                verticalAlignment = Alignment.CenterVertically
                                            ) {
                                                // Define each navigation item
                                                NavItem(
                                                    label = "Home",
                                                    iconRes = R.drawable.rounded_home_24,
                                                    isSelected = navController.isCurrentRoute("main"),
                                                    navController = navController,
                                                    route = "main"
                                                )
                                                NavItem(
                                                    label = "Promos",
                                                    iconRes = R.drawable.rounded_gifts_24,
                                                    isSelected = navController.isCurrentRoute("promos"),
                                                    navController = navController,
                                                    route = "promos"
                                                )
                                                AddTransactionButton(onClick = { showAddTransactionModal = true }) // Button to add transactions
                                                NavItem(
                                                    label = "Accounts",
                                                    iconRes = R.drawable.creditcard24,
                                                    isSelected = navController.isCurrentRoute("accounts"),
                                                    navController = navController,
                                                    route = "accounts"
                                                )
                                                NavItem(
                                                    label = "Profile",
                                                    iconRes = R.drawable.person24,
                                                    isSelected = navController.isCurrentRoute("profile"),
                                                    navController = navController,
                                                    route = "profile"
                                                )
                                            }
                                        }
                                    
                                        // Display modal for adding a transaction when Add button is clicked
                                        if (showAddTransactionModal) {
                                            AddTransactionModal(
                                                accountViewModel = accountViewModel,
                                                transactionViewModel = transactionViewModel,
                                                onDismiss = { showAddTransactionModal = false },
                                                onTransactionAdded = { showAddTransactionModal = false }
                                            )
                                        }
                                    }
                                    
                                    /**
                                     * NavItem composable function
                                     *
                                     * Displays an individual navigation item with an icon and label. Changes color based on whether the item is selected.
                                     *
                                     * @param label Text label for the navigation item
                                     * @param iconRes Resource ID of the icon to display
                                     * @param isSelected Boolean indicating if the item is selected (current route)
                                     * @param navController [NavController] used to navigate to the item's route
                                     * @param route Route associated with this navigation item
                                     */
                                    @Composable
                                    fun NavItem(label: String, iconRes: Int, isSelected: Boolean, navController: NavController, route: String) {
                                        val color = if (isSelected) Color(0xFF5875DD) else Color.Black // Color based on selection
                                    
                                        Column(
                                            horizontalAlignment = Alignment.CenterHorizontally,
                                            verticalArrangement = Arrangement.Center
                                        ) {
                                            IconButton(onClick = { navController.navigate(route) }) {
                                                Icon(
                                                    painter = painterResource(id = iconRes),
                                                    contentDescription = label,
                                                    tint = color,
                                                    modifier = Modifier.size(24.dp)
                                                )
                                            }
                                            Text(
                                                text = label,
                                                color = color,
                                                fontSize = 12.sp,
                                                fontWeight = FontWeight.Medium
                                            )
                                        }
                                    }
                                    
                                    /**
                                     * AddTransactionButton composable function
                                     *
                                     * Displays a circular button for adding transactions, styled with a distinctive color and centered in the bottom navigation bar.
                                     *
                                     * @param onClick Lambda function triggered when the button is clicked
                                     */
                                    @Composable
                                    fun AddTransactionButton(onClick: () -> Unit) {
                                        IconButton(onClick = onClick) {
                                            Box(
                                                modifier = Modifier
                                                    .size(50.dp)
                                                    .clip(CircleShape)
                                                    .background(Color(0xFF5875DD))
                                            ) {
                                                Icon(
                                                    painter = painterResource(id = R.drawable.add24),
                                                    contentDescription = "Add Transaction",
                                                    tint = Color.White,
                                                    modifier = Modifier
                                                        .size(24.dp)
                                                        .align(Alignment.Center)
                                                )
                                            }
                                        }
                                    }
                                    
                                    /**
                                     * Extension function to check if a specific route is currently selected in the NavController.
                                     *
                                     * @param route The route to check against the current navigation route
                                     * @return True if the provided route matches the current route, false otherwise
                                     */
                                    @Composable
                                    fun NavController.isCurrentRoute(route: String): Boolean {
                                        return this.currentBackStackEntryAsState().value?.destination?.route == route
                                    }
                                    ```
                                - PieChart.kt
                                    ```
                                    package com.isis3510.spendiq.views.common
                                    
                                    import android.util.Log
                                    import androidx.compose.foundation.layout.size
                                    import androidx.compose.runtime.Composable
                                    import androidx.compose.ui.Modifier
                                    import androidx.compose.ui.graphics.Color
                                    import androidx.compose.ui.unit.dp
                                    import ir.ehsannarmani.compose_charts.PieChart
                                    import ir.ehsannarmani.compose_charts.models.Pie
                                    
                                    /**
                                     * CreatePieChart composable function
                                     *
                                     * Displays a pie chart visualization using provided data. This component leverages a third-party
                                     * library, `ComposeChart`, to render a customizable pie chart with selectable slices.
                                     *
                                     * Features:
                                     * - Converts input data into a pie chart format suitable for ComposeChart.
                                     * - Allows individual slices of the chart to be highlighted when clicked.
                                     * - Customizable colors for each data label, with specific colors for "Income" and "Expenses".
                                     *
                                     * Functionality:
                                     * - `CreatePieChart`: Takes a list of data pairs (`List<Pair<String, Long>>`) representing labels
                                     *   and values, converts them to `Pie` objects, and renders them in a pie chart.
                                     * - Slices in the chart are selectable, with the clicked slice visually enlarged.
                                     *
                                     * Supporting Function:
                                     * - `getColorForLabel`: Maps each label to a specific color, providing consistent color coding
                                     *   for "Income" and "Expenses" labels.
                                     *
                                     * @param data A list of pairs with each containing a label (`String`) and its associated value (`Long`).
                                     */
                                    
                                    @Composable
                                    fun CreatePieChart(data: List<Pair<String, Long>>) {
                                        Log.d("PieChart", "$data") // Log the data for debugging purposes
                                    
                                        // Convert the input data to a format compatible with ComposeChart's PieChart model
                                        var pieData = data.map { (label, value) ->
                                            Pie(
                                                label = label,
                                                data = value.toDouble(),
                                                color = getColorForLabel(label), // Color based on label
                                                selectedColor = Color.Red       // Highlight color for selected slice
                                            )
                                        }
                                    
                                        // Render the PieChart with customization for size, spacing, and styling
                                        PieChart(
                                            modifier = Modifier.size(170.dp), // Chart size
                                            data = pieData,                   // Pie chart data
                                            onPieClick = {                    // Handles pie slice selection
                                                val pieIndex = pieData.indexOf(it) // Get index of clicked slice
                                                // Update pieData to set the clicked slice as selected
                                                pieData = pieData.mapIndexed { mapIndex, pie ->
                                                    pie.copy(selected = pieIndex == mapIndex)
                                                }
                                            },
                                            selectedScale = 1.2f,             // Scale of selected slice
                                            spaceDegree = 4f,                 // Space between slices in degrees
                                            selectedPaddingDegree = 2f,       // Padding around selected slice
                                            style = Pie.Style.Stroke(width = 42.dp) // Stroke style with 42dp width
                                        )
                                    }
                                    
                                    /**
                                     * Maps specific labels to predefined colors for the pie chart slices.
                                     * - "Income" -> Green color
                                     * - "Expenses" -> Pink color
                                     * - Default color is Gray for other labels
                                     *
                                     * @param label A label for the pie slice.
                                     * @return A [Color] corresponding to the label.
                                     */
                                    private fun getColorForLabel(label: String): Color {
                                        return when (label) {
                                            "Income" -> Color(0xffb3cb54)    // Green color for income
                                            "Expenses" -> Color(0xffc33ba5)  // Pink color for expenses
                                            else -> Color.Gray               // Default gray color
                                        }
                                    }
                                    ```
                            - **profile/**
                                - ProfileInfoScreen.kt
                                    ```
                                    // ProfileInfoScreen.kt
                                    package com.isis3510.spendiq.views.profile
                                    
                                    import androidx.compose.foundation.layout.Box
                                    import androidx.compose.foundation.layout.fillMaxSize
                                    import androidx.compose.foundation.layout.padding
                                    import androidx.compose.material3.*
                                    import androidx.compose.runtime.*
                                    import androidx.compose.ui.Alignment
                                    import androidx.compose.ui.Modifier
                                    import androidx.compose.ui.res.painterResource
                                    import androidx.navigation.NavController
                                    import com.isis3510.spendiq.R
                                    import com.isis3510.spendiq.views.common.BottomNavigation
                                    import com.isis3510.spendiq.viewmodel.AccountViewModel
                                    import com.isis3510.spendiq.viewmodel.TransactionViewModel
                                    import kotlinx.coroutines.delay
                                    import kotlinx.coroutines.launch
                                    
                                    @OptIn(ExperimentalMaterial3Api::class)
                                    @Composable
                                    fun ProfileInfoScreen(
                                        navController: NavController,
                                        transactionViewModel: TransactionViewModel,
                                        accountViewModel: AccountViewModel
                                    ) {
                                        var isNavigating by remember { mutableStateOf(false) }
                                        val coroutineScope = rememberCoroutineScope()
                                    
                                        Scaffold(
                                            topBar = {
                                                TopAppBar(
                                                    title = { Text("Information") },
                                                    navigationIcon = {
                                                        IconButton(onClick = {
                                                            if (!isNavigating) {
                                                                isNavigating = true
                                                                coroutineScope.launch {
                                                                    navController.popBackStack()
                                                                    delay(300)
                                                                    isNavigating = false
                                                                }
                                                            }
                                                        }) {
                                                            Icon(
                                                                painter = painterResource(id = R.drawable.round_arrow_back_ios_24),
                                                                contentDescription = "Back"
                                                            )
                                                        }
                                                    }
                                                )
                                            },
                                            bottomBar = {
                                                BottomNavigation(
                                                    navController = navController,
                                                    transactionViewModel = transactionViewModel,
                                                    accountViewModel = accountViewModel
                                                )
                                            }
                                        ) { innerPadding ->
                                            Box(
                                                contentAlignment = Alignment.Center,
                                                modifier = Modifier
                                                    .fillMaxSize()
                                                    .padding(innerPadding)
                                            ) {
                                                Text(text = "Information Screen")
                                            }
                                        }
                                    }
                                    ```
                                - ProfileHelpScreen.kt
                                    ```
                                    // ProfileHelpScreen.kt
                                    package com.isis3510.spendiq.views.profile
                                    
                                    import androidx.compose.foundation.layout.Box
                                    import androidx.compose.foundation.layout.fillMaxSize
                                    import androidx.compose.foundation.layout.padding
                                    import androidx.compose.material3.*
                                    import androidx.compose.runtime.*
                                    import androidx.compose.ui.Alignment
                                    import androidx.compose.ui.Modifier
                                    import androidx.compose.ui.res.painterResource
                                    import androidx.navigation.NavController
                                    import com.isis3510.spendiq.R
                                    import com.isis3510.spendiq.views.common.BottomNavigation
                                    import com.isis3510.spendiq.viewmodel.AccountViewModel
                                    import com.isis3510.spendiq.viewmodel.TransactionViewModel
                                    import kotlinx.coroutines.delay
                                    import kotlinx.coroutines.launch
                                    
                                    @OptIn(ExperimentalMaterial3Api::class)
                                    @Composable
                                    fun ProfileHelpScreen(
                                        navController: NavController,
                                        transactionViewModel: TransactionViewModel,
                                        accountViewModel: AccountViewModel
                                    ) {
                                        var isNavigating by remember { mutableStateOf(false) }
                                        val coroutineScope = rememberCoroutineScope()
                                    
                                        Scaffold(
                                            topBar = {
                                                TopAppBar(
                                                    title = { Text("Help") },
                                                    navigationIcon = {
                                                        IconButton(onClick = {
                                                            if (!isNavigating) {
                                                                isNavigating = true
                                                                coroutineScope.launch {
                                                                    navController.popBackStack()
                                                                    delay(300)
                                                                    isNavigating = false
                                                                }
                                                            }
                                                        }) {
                                                            Icon(
                                                                painter = painterResource(id = R.drawable.round_arrow_back_ios_24),
                                                                contentDescription = "Back"
                                                            )
                                                        }
                                                    }
                                                )
                                            },
                                            bottomBar = {
                                                BottomNavigation(
                                                    navController = navController,
                                                    transactionViewModel = transactionViewModel,
                                                    accountViewModel = accountViewModel
                                                )
                                            }
                                        ) { innerPadding ->
                                            Box(
                                                contentAlignment = Alignment.Center,
                                                modifier = Modifier
                                                    .fillMaxSize()
                                                    .padding(innerPadding)
                                            ) {
                                                Text(text = "Help Screen")
                                            }
                                        }
                                    }
                                    ```
                                - ProfileStatisticsScreen.kt
                                    ```
                                    // ProfileStatisticsScreen.kt
                                    package com.isis3510.spendiq.views.profile
                                    
                                    import androidx.compose.foundation.background
                                    import androidx.compose.foundation.isSystemInDarkTheme
                                    import androidx.compose.foundation.layout.*
                                    import androidx.compose.foundation.Canvas
                                    import androidx.compose.foundation.rememberScrollState
                                    import androidx.compose.foundation.shape.RoundedCornerShape
                                    import androidx.compose.foundation.verticalScroll
                                    import androidx.compose.material3.*
                                    import androidx.compose.runtime.*
                                    import androidx.compose.ui.Alignment
                                    import androidx.compose.ui.Modifier
                                    import androidx.compose.ui.geometry.Offset
                                    import androidx.compose.ui.geometry.Size
                                    import androidx.compose.ui.graphics.Color
                                    import androidx.compose.ui.graphics.drawscope.drawIntoCanvas
                                    import androidx.compose.ui.graphics.nativeCanvas
                                    import androidx.compose.ui.res.painterResource
                                    import androidx.compose.ui.unit.dp
                                    import androidx.compose.ui.unit.sp
                                    import androidx.navigation.NavController
                                    import com.isis3510.spendiq.R
                                    import com.isis3510.spendiq.views.common.BottomNavigation
                                    import com.isis3510.spendiq.viewmodel.AccountViewModel
                                    import com.isis3510.spendiq.viewmodel.TransactionViewModel
                                    import kotlinx.coroutines.delay
                                    import kotlinx.coroutines.launch
                                    import com.isis3510.spendiq.model.data.Account
                                    import com.isis3510.spendiq.model.data.Transaction
                                    import kotlin.math.abs
                                    import android.graphics.Paint as AndroidPaint
                                    
                                    @OptIn(ExperimentalMaterial3Api::class)
                                    @Composable
                                    fun ProfileStatisticsScreen(
                                        navController: NavController,
                                        transactionViewModel: TransactionViewModel,
                                        accountViewModel: AccountViewModel
                                    ) {
                                        val isDarkTheme = isSystemInDarkTheme()
                                        val cardBackgroundColor = Color(0xFFB3CB54)
                                        val textColor = if (isDarkTheme) Color.White else Color.Black
                                    
                                        var isNavigating by remember { mutableStateOf(false) }
                                        val coroutineScope = rememberCoroutineScope()
                                    
                                        val accounts by accountViewModel.accounts.collectAsState()
                                        val transactions by transactionViewModel.transactions.collectAsState()
                                    
                                        val accountBalances = remember { mutableStateMapOf<String, Double>() }
                                    
                                        LaunchedEffect(Unit) {
                                            transactionViewModel.fetchAllTransactions()
                                        }
                                    
                                        LaunchedEffect(accounts, transactions) {
                                            val balances = mutableMapOf<String, Double>()
                                            accounts.forEach { account ->
                                                val transactionsForAccount = transactions.filter { it.accountId == account.id }
                                                val total = transactionsForAccount.sumOf {
                                                    if (it.transactionType == "Income") it.amount else -it.amount
                                                }
                                                balances[account.name] = total.toDouble()
                                            }
                                            accountBalances.clear()
                                            accountBalances.putAll(balances)
                                        }
                                    
                                        Scaffold(
                                            containerColor = Color.Transparent,
                                            topBar = {
                                                TopAppBar(
                                                    title = { Text("Statistics") },
                                                    navigationIcon = {
                                                        IconButton(onClick = {
                                                            if (!isNavigating) {
                                                                isNavigating = true
                                                                coroutineScope.launch {
                                                                    navController.popBackStack()
                                                                    delay(300)
                                                                    isNavigating = false
                                                                }
                                                            }
                                                        }) {
                                                            Icon(
                                                                painter = painterResource(id = R.drawable.round_arrow_back_ios_24),
                                                                contentDescription = "Back"
                                                            )
                                                        }
                                                    },
                                                    colors = TopAppBarDefaults.topAppBarColors(containerColor = Color.Transparent)
                                                )
                                            },
                                            bottomBar = {
                                                BottomNavigation(
                                                    navController = navController,
                                                    transactionViewModel = transactionViewModel,
                                                    accountViewModel = accountViewModel
                                                )
                                            }
                                        ) { innerPadding ->
                                            Column(
                                                modifier = Modifier
                                                    .fillMaxSize()
                                                    .padding(innerPadding)
                                                    .padding(horizontal = 16.dp) // Aumentado para mejor espaciado
                                                    .verticalScroll(rememberScrollState()),
                                                horizontalAlignment = Alignment.CenterHorizontally
                                            ) {
                                                // Botones Segmented "Daily" y "Weekly"
                                                SegmentedButton(
                                                    options = listOf("Daily", "Weekly"),
                                                    selectedOption = "Daily",
                                                    onOptionSelected = {},
                                                    backgroundColor = Color.Transparent,
                                                    selectedColor = cardBackgroundColor,
                                                    textColor = textColor
                                                )
                                    
                                                // Espacio adicional para bajar el grfico (aprox. 50 dp)
                                                Spacer(modifier = Modifier.height(50.dp))
                                    
                                                // Grfico de Barras
                                                Box(
                                                    modifier = Modifier
                                                        .fillMaxWidth()
                                                        .height(300.dp) // Ajusta la altura segn sea necesario
                                                        .background(Color.Transparent),
                                                    contentAlignment = Alignment.Center
                                                ) {
                                                    if (accountBalances.isNotEmpty()) {
                                                        BarChart(
                                                            modifier = Modifier
                                                                .fillMaxSize()
                                                                .padding(16.dp),
                                                            data = accountBalances.toMap(),
                                                            isDarkTheme = isDarkTheme
                                                        )
                                                    } else {
                                                        Text("Cargando datos...", color = textColor)
                                                    }
                                                }
                                    
                                                Spacer(modifier = Modifier.height(16.dp))
                                    
                                                // Etiquetas de las cuentas justo debajo del eje X
                                                Row(
                                                    modifier = Modifier
                                                        .fillMaxWidth()
                                                        .padding(horizontal = 16.dp),
                                                    horizontalArrangement = Arrangement.SpaceEvenly
                                                ) {
                                                    sortedAccounts(accountBalances).forEach { accountName ->
                                                        Text(
                                                            text = accountName,
                                                            fontSize = 12.sp,
                                                            color = textColor,
                                                            maxLines = 1,
                                                            modifier = Modifier
                                                                .widthIn(min = 40.dp, max = 80.dp)
                                                        )
                                                    }
                                                }
                                    
                                                Spacer(modifier = Modifier.height(24.dp))
                                    
                                                // Tarjetas resumen
                                                Column(
                                                    verticalArrangement = Arrangement.spacedBy(8.dp)
                                                ) {
                                                    Row(
                                                        modifier = Modifier.fillMaxWidth(),
                                                        horizontalArrangement = Arrangement.SpaceEvenly
                                                    ) {
                                                        SummaryCard(
                                                            title = "8 PM",
                                                            subtitle = "Highest spending time",
                                                            backgroundColor = cardBackgroundColor,
                                                            textColor = textColor,
                                                            iconResId = R.drawable.round_clock_24
                                                        )
                                                        SummaryCard(
                                                            title = "Saturday",
                                                            subtitle = "Highest spending day",
                                                            backgroundColor = cardBackgroundColor,
                                                            textColor = textColor,
                                                            iconResId = R.drawable.calendar24
                                                        )
                                                    }
                                                    Row(
                                                        modifier = Modifier.fillMaxWidth(),
                                                        horizontalArrangement = Arrangement.SpaceEvenly
                                                    ) {
                                                        SummaryCard(
                                                            title = "Sept. 3",
                                                            subtitle = "Last advice",
                                                            backgroundColor = cardBackgroundColor,
                                                            textColor = textColor,
                                                            iconResId = R.drawable.round_lightbulb_24
                                                        )
                                                        SummaryCard(
                                                            title = "El Corral",
                                                            subtitle = "Most visited place",
                                                            backgroundColor = cardBackgroundColor,
                                                            textColor = textColor,
                                                            iconResId = R.drawable.round_star_24
                                                        )
                                                    }
                                                    Row(
                                                        modifier = Modifier.fillMaxWidth(),
                                                        horizontalArrangement = Arrangement.SpaceEvenly
                                                    ) {
                                                        SummaryCard(
                                                            title = "$67,500",
                                                            subtitle = "Highest expend",
                                                            backgroundColor = cardBackgroundColor,
                                                            textColor = textColor,
                                                            iconResId = R.drawable.round_money_24
                                                        )
                                                        SummaryCard(
                                                            title = "Nequi",
                                                            subtitle = "Preferred payment account",
                                                            backgroundColor = cardBackgroundColor,
                                                            textColor = textColor,
                                                            iconResId = R.drawable.outline_giftcard_24
                                                        )
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    
                                    // Funcin auxiliar para ordenar las cuentas (si es necesario)
                                    @Composable
                                    fun sortedAccounts(accountBalances: Map<String, Double>): List<String> {
                                        return accountBalances.keys.sorted()
                                    }
                                    
                                    @Composable
                                    fun BarChart(
                                        modifier: Modifier = Modifier,
                                        data: Map<String, Double>,
                                        isDarkTheme: Boolean = isSystemInDarkTheme()
                                    ) {
                                        val step = 10000.0
                                        val maxPositiveAmount = data.values.filter { it > 0 }.maxOrNull() ?: 0.0
                                        val maxNegativeAmount = data.values.filter { it < 0 }.minOrNull() ?: 0.0
                                        val maxAmount = maxOf(maxPositiveAmount, abs(maxNegativeAmount))
                                        val numberOfSteps = if (maxAmount % step == 0.0) (maxAmount / step).toInt() else (maxAmount / step).toInt() + 1
                                    
                                        val barColors = if (isDarkTheme) {
                                            listOf(Color.Cyan, Color.Magenta)
                                        } else {
                                            listOf(Color(0xFFB3CB54), Color(0xFFE57373))
                                        }
                                    
                                        val sortedData = data.toList().sortedBy { it.first }
                                    
                                        Canvas(modifier = modifier) {
                                            val paddingBottom = 40.dp.toPx() // Reducido para acomodar etiquetas
                                            val paddingTop = 20.dp.toPx()
                                            val paddingStart = 40.dp.toPx()
                                            val paddingEnd = 20.dp.toPx()
                                    
                                            val availableHeight = size.height - paddingTop - paddingBottom
                                            val availableWidth = size.width - paddingStart - paddingEnd
                                    
                                            val centerY = paddingTop + (availableHeight / 2)
                                    
                                            val barWidth = availableWidth / (sortedData.size * 2)
                                            var xPosition = paddingStart + barWidth / 2
                                    
                                            // Dibujar lneas de referencia horizontales
                                            for (i in 1..numberOfSteps) {
                                                val y = centerY - (i * step / maxAmount * availableHeight)
                                                drawLine(
                                                    color = Color.LightGray,
                                                    start = Offset(paddingStart, y.toFloat()),
                                                    end = Offset(size.width - paddingEnd, y.toFloat()),
                                                    strokeWidth = 1f
                                                )
                                            }
                                    
                                            // Dibujar eje X
                                            drawLine(
                                                color = Color.Black,
                                                start = Offset(paddingStart, centerY),
                                                end = Offset(size.width - paddingEnd, centerY),
                                                strokeWidth = 2f
                                            )
                                    
                                    
                                            // Dibujar barras
                                            sortedData.forEach { (accountName, amount) ->
                                                val barHeightRatio = if (maxAmount != 0.0) abs(amount) / maxAmount else 0.0
                                                val barHeight = barHeightRatio.toFloat() * availableHeight
                                    
                                                val isPositive = amount >= 0.0
                                                val topLeftY = if (isPositive) centerY - barHeight else centerY
                                    
                                                drawRoundRect(
                                                    color = if (isPositive) barColors[0] else barColors[1],
                                                    topLeft = Offset(xPosition, topLeftY),
                                                    size = Size(barWidth, barHeight),
                                                    cornerRadius = androidx.compose.ui.geometry.CornerRadius(8.dp.toPx())
                                                )
                                    
                                                // Dibujar etiquetas de las cuentas justo debajo del eje X dentro del Canvas
                                                drawIntoCanvas { canvas ->
                                                    val paint = AndroidPaint().apply {
                                                        color = android.graphics.Color.BLACK
                                                        textAlign = AndroidPaint.Align.CENTER
                                                        textSize = 12.sp.toPx()
                                                        isAntiAlias = true
                                                    }
                                                    canvas.nativeCanvas.drawText(
                                                        accountName,
                                                        xPosition + barWidth / 2,
                                                        centerY + 25.dp.toPx(), // Aumentado para mayor separacin del eje X
                                                        paint
                                                    )
                                                }
                                    
                                                // Dibujar lnea delgada gris debajo del eje X hasta el final del grfico
                                                drawLine(
                                                    color = Color.LightGray,
                                                    start = Offset(xPosition, centerY + 2.dp.toPx()), // Un poco debajo del eje X
                                                    end = Offset(xPosition + barWidth, centerY + 2.dp.toPx()),
                                                    strokeWidth = 1f
                                                )
                                    
                                                xPosition += barWidth * 2
                                            }
                                    
                                            // **Agregar una lnea delgada gris al final del eje X**
                                            drawLine(
                                                color = Color.LightGray,
                                                start = Offset(paddingStart, size.height - paddingBottom),
                                                end = Offset(size.width - paddingEnd, size.height - paddingBottom),
                                                strokeWidth = 1f
                                            )
                                        }
                                    }
                                    
                                    @Composable
                                    fun SummaryCard(
                                        title: String,
                                        subtitle: String,
                                        backgroundColor: Color,
                                        textColor: Color,
                                        iconResId: Int? = null
                                    ) {
                                        Surface(
                                            modifier = Modifier
                                                .width(140.dp)
                                                .height(100.dp),
                                            shape = RoundedCornerShape(16.dp),
                                            color = backgroundColor
                                        ) {
                                            Box(modifier = Modifier.fillMaxSize()) {
                                                iconResId?.let {
                                                    Icon(
                                                        painter = painterResource(id = it),
                                                        contentDescription = null,
                                                        tint = textColor,
                                                        modifier = Modifier
                                                            .size(48.dp)
                                                            .align(Alignment.TopEnd)
                                                            .padding(10.dp)
                                                    )
                                                }
                                                Column(
                                                    modifier = Modifier
                                                        .padding(start = 12.dp, top = 12.dp, end = 8.dp, bottom = 12.dp)
                                                        .fillMaxSize(),
                                                    verticalArrangement = Arrangement.SpaceBetween
                                                ) {
                                                    Text(text = title, style = MaterialTheme.typography.titleMedium, color = textColor)
                                                    Text(text = subtitle, style = MaterialTheme.typography.bodyMedium, color = textColor)
                                                }
                                            }
                                        }
                                    }
                                    
                                    @Composable
                                    fun SegmentedButton(
                                        options: List<String>,
                                        selectedOption: String,
                                        onOptionSelected: (String) -> Unit,
                                        backgroundColor: Color,
                                        selectedColor: Color,
                                        textColor: Color
                                    ) {
                                        Row(
                                            modifier = Modifier
                                                .background(backgroundColor, shape = RoundedCornerShape(50))
                                                .padding(4.dp),
                                            horizontalArrangement = Arrangement.Center,
                                            verticalAlignment = Alignment.CenterVertically
                                        ) {
                                            options.forEach { option ->
                                                val isSelected = option == selectedOption
                                                Button(
                                                    onClick = { onOptionSelected(option) },
                                                    shape = RoundedCornerShape(50),
                                                    colors = ButtonDefaults.buttonColors(containerColor = if (isSelected) selectedColor else backgroundColor)
                                                ) {
                                                    Text(option, color = textColor)
                                                }
                                            }
                                        }
                                    }
                                    ```
                                - ProfileNotificationsScreen.kt
                                    ```
                                    // ProfileNotificationsScreen.kt
                                    package com.isis3510.spendiq.views.profile
                                    
                                    import androidx.compose.foundation.layout.Box
                                    import androidx.compose.foundation.layout.fillMaxSize
                                    import androidx.compose.foundation.layout.padding
                                    import androidx.compose.material3.*
                                    import androidx.compose.runtime.*
                                    import androidx.compose.ui.Alignment
                                    import androidx.compose.ui.Modifier
                                    import androidx.compose.ui.res.painterResource
                                    import androidx.navigation.NavController
                                    import com.isis3510.spendiq.R
                                    import com.isis3510.spendiq.views.common.BottomNavigation
                                    import com.isis3510.spendiq.viewmodel.AccountViewModel
                                    import com.isis3510.spendiq.viewmodel.TransactionViewModel
                                    import kotlinx.coroutines.delay
                                    import kotlinx.coroutines.launch
                                    
                                    @OptIn(ExperimentalMaterial3Api::class)
                                    @Composable
                                    fun ProfileNotificationsScreen(
                                        navController: NavController,
                                        transactionViewModel: TransactionViewModel,
                                        accountViewModel: AccountViewModel
                                    ) {
                                        var isNavigating by remember { mutableStateOf(false) }
                                        val coroutineScope = rememberCoroutineScope()
                                    
                                        Scaffold(
                                            topBar = {
                                                TopAppBar(
                                                    title = { Text("Notifications Settings") },
                                                    navigationIcon = {
                                                        IconButton(onClick = {
                                                            if (!isNavigating) {
                                                                isNavigating = true
                                                                coroutineScope.launch {
                                                                    navController.popBackStack()
                                                                    delay(300)
                                                                    isNavigating = false
                                                                }
                                                            }
                                                        }) {
                                                            Icon(
                                                                painter = painterResource(id = R.drawable.round_arrow_back_ios_24),
                                                                contentDescription = "Back"
                                                            )
                                                        }
                                                    }
                                                )
                                            },
                                            bottomBar = {
                                                BottomNavigation(
                                                    navController = navController,
                                                    transactionViewModel = transactionViewModel,
                                                    accountViewModel = accountViewModel
                                                )
                                            }
                                        ) { innerPadding ->
                                            Box(
                                                contentAlignment = Alignment.Center,
                                                modifier = Modifier
                                                    .fillMaxSize()
                                                    .padding(innerPadding)
                                            ) {
                                                Text(text = "Notifications Settings Screen")
                                            }
                                        }
                                    }
                                    ```
                                - ProfileSecurityScreen.kt
                                    ```
                                    // ProfileSecurityScreen.kt
                                    package com.isis3510.spendiq.views.profile
                                    
                                    import androidx.compose.foundation.layout.Box
                                    import androidx.compose.foundation.layout.fillMaxSize
                                    import androidx.compose.foundation.layout.padding
                                    import androidx.compose.material3.*
                                    import androidx.compose.runtime.*
                                    import androidx.compose.ui.Alignment
                                    import androidx.compose.ui.Modifier
                                    import androidx.compose.ui.res.painterResource
                                    import androidx.navigation.NavController
                                    import com.isis3510.spendiq.R
                                    import com.isis3510.spendiq.views.common.BottomNavigation
                                    import com.isis3510.spendiq.viewmodel.AccountViewModel
                                    import com.isis3510.spendiq.viewmodel.TransactionViewModel
                                    import kotlinx.coroutines.delay
                                    import kotlinx.coroutines.launch
                                    
                                    @OptIn(ExperimentalMaterial3Api::class)
                                    @Composable
                                    fun ProfileSecurityScreen(
                                        navController: NavController,
                                        transactionViewModel: TransactionViewModel,
                                        accountViewModel: AccountViewModel
                                    ) {
                                        // Estado para prevenir mltiples clics rpidos en el botn de retroceso
                                        var isNavigating by remember { mutableStateOf(false) }
                                        // Recordar el CoroutineScope para manejar la navegacin
                                        val coroutineScope = rememberCoroutineScope()
                                    
                                        Scaffold(
                                            topBar = {
                                                TopAppBar(
                                                    title = { Text("Security Settings") },
                                                    navigationIcon = {
                                                        IconButton(onClick = {
                                                            if (!isNavigating) {
                                                                isNavigating = true
                                                                coroutineScope.launch {
                                                                    navController.popBackStack()
                                                                    // Esperar 300 ms antes de permitir otro clic en el botn
                                                                    delay(300)
                                                                    isNavigating = false
                                                                }
                                                            }
                                                        }) {
                                                            Icon(
                                                                painter = painterResource(id = R.drawable.round_arrow_back_ios_24),
                                                                contentDescription = "Back"
                                                            )
                                                        }
                                                    }
                                                )
                                            },
                                            bottomBar = {
                                                BottomNavigation(
                                                    navController = navController,
                                                    transactionViewModel = transactionViewModel,
                                                    accountViewModel = accountViewModel
                                                )
                                            }
                                        ) { innerPadding ->
                                            Box(
                                                contentAlignment = Alignment.Center,
                                                modifier = Modifier
                                                    .fillMaxSize()
                                                    .padding(innerPadding)
                                            ) {
                                                Text(text = "Security Settings Screen")
                                            }
                                        }
                                    }
                                    ```
                                - ProfileLaGScreen.kt
                                    ```
                                    package com.isis3510.spendiq.views.profile
                                    
                                    import androidx.compose.foundation.background
                                    import androidx.compose.foundation.border
                                    import androidx.compose.foundation.clickable
                                    import androidx.compose.foundation.layout.*
                                    import androidx.compose.foundation.shape.RoundedCornerShape
                                    import androidx.compose.foundation.text.KeyboardOptions
                                    import androidx.compose.foundation.verticalScroll
                                    import androidx.compose.foundation.rememberScrollState
                                    import androidx.compose.material.icons.Icons
                                    import androidx.compose.material.icons.filled.ArrowBack
                                    import androidx.compose.material.icons.filled.Delete
                                    import androidx.compose.material3.*
                                    import androidx.compose.runtime.*
                                    import androidx.compose.ui.Alignment
                                    import androidx.compose.ui.Modifier
                                    import androidx.compose.ui.draw.clip
                                    import androidx.compose.ui.graphics.Brush
                                    import androidx.compose.ui.graphics.Color
                                    import androidx.compose.ui.text.AnnotatedString
                                    import androidx.compose.ui.text.TextStyle
                                    import androidx.compose.ui.text.font.FontWeight
                                    import androidx.compose.ui.text.input.KeyboardType
                                    import androidx.compose.ui.text.input.OffsetMapping
                                    import androidx.compose.ui.text.input.TransformedText
                                    import androidx.compose.ui.text.input.VisualTransformation
                                    import androidx.compose.ui.text.style.TextAlign
                                    import androidx.compose.ui.unit.dp
                                    import androidx.compose.ui.unit.sp
                                    import androidx.navigation.NavController
                                    import com.isis3510.spendiq.viewmodel.AccountViewModel
                                    import com.isis3510.spendiq.viewmodel.TransactionViewModel
                                    import com.isis3510.spendiq.views.common.BottomNavigation
                                    import java.text.NumberFormat
                                    import java.util.Locale
                                    
                                    // Clase Expense con propiedades reactivas
                                    class Expense(
                                        name: String = "",
                                        amount: String = ""
                                    ) {
                                        var name by mutableStateOf(name)
                                        var amount by mutableStateOf(amount)
                                    }
                                    
                                    // VisualTransformation para formatear nmeros con comas
                                    class NumberFormatTransformation : VisualTransformation {
                                        private val formatter: NumberFormat = NumberFormat.getNumberInstance(Locale.US).apply {
                                            isGroupingUsed = true
                                            maximumFractionDigits = 2
                                            minimumFractionDigits = 0
                                        }
                                    
                                        override fun filter(text: AnnotatedString): TransformedText {
                                            val originalText = text.text.replace("[^\\d.]".toRegex(), "")
                                            val number = originalText.toDoubleOrNull()
                                            val formatted = if (number != null) formatter.format(number) else originalText
                                    
                                            val offsetMapping = object : OffsetMapping {
                                                override fun originalToTransformed(offset: Int): Int = formatted.length
                                                override fun transformedToOriginal(offset: Int): Int = originalText.length
                                            }
                                    
                                            return TransformedText(AnnotatedString(formatted), offsetMapping)
                                        }
                                    }
                                    
                                    @OptIn(ExperimentalMaterial3Api::class)
                                    @Composable
                                    fun ProfileLaGScreen(
                                        navController: NavController,
                                        transactionViewModel: TransactionViewModel,
                                        accountViewModel: AccountViewModel
                                    ) {
                                        // Variables de estado
                                        var isByExpenseChecked by remember { mutableStateOf(true) }
                                        var isByQuantityChecked by remember { mutableStateOf(false) }
                                        val expenses = remember { mutableStateListOf<Expense>() }
                                        var selectedFrequency by remember { mutableStateOf("Daily") }
                                        var amountText by remember { mutableStateOf("") }
                                        val lightGrayColor = Color(0xFFD9D9D9)
                                        val selectedButtonColor = Color(0xFFB3CB54) // Color especificado para seleccin
                                        val cornerRadius = 50.dp // Bordes ms redondeados
                                        var selectedExpenseIndex by remember { mutableStateOf(-1) }
                                    
                                        // Estado de desplazamiento para controlar las sombras
                                        val scrollState = rememberScrollState()
                                        val canScrollUp by remember { derivedStateOf { scrollState.value > 0 } }
                                        val canScrollDown by remember { derivedStateOf { scrollState.value < scrollState.maxValue } }
                                    
                                        Scaffold(
                                            topBar = {
                                                TopAppBar(
                                                    title = {
                                                        Box(Modifier.fillMaxWidth()) {
                                                            Text(
                                                                "Limits and Goals",
                                                                modifier = Modifier.align(Alignment.Center),
                                                                textAlign = TextAlign.Center
                                                            )
                                                        }
                                                    },
                                                    navigationIcon = {
                                                        IconButton(onClick = { navController.popBackStack() }) {
                                                            Icon(Icons.Filled.ArrowBack, contentDescription = "Back")
                                                        }
                                                    },
                                                    actions = { Spacer(modifier = Modifier.width(48.dp)) }
                                                )
                                            },
                                            bottomBar = {
                                                BottomNavigation(
                                                    navController = navController,
                                                    transactionViewModel = transactionViewModel,
                                                    accountViewModel = accountViewModel
                                                )
                                            }
                                        ) { innerPadding ->
                                            // Contenido principal, ajustado con innerPadding para evitar superposicin con topBar y bottomBar
                                            Column(
                                                modifier = Modifier
                                                    .padding(innerPadding)
                                                    .fillMaxSize()
                                                    .imePadding() // Aade padding cuando el teclado est visible
                                            ) {
                                                // Seccin principal con scroll
                                                Column(
                                                    modifier = Modifier
                                                        .weight(1f)
                                                        .verticalScroll(scrollState)
                                                        .padding(16.dp)
                                                ) {
                                                    // Seccin By Expense
                                                    Row(verticalAlignment = Alignment.CenterVertically) {
                                                        Checkbox(
                                                            checked = isByExpenseChecked,
                                                            onCheckedChange = {
                                                                isByExpenseChecked = it
                                                                if (it) isByQuantityChecked = false
                                                            }
                                                        )
                                                        Spacer(modifier = Modifier.width(8.dp))
                                                        Text("By expense")
                                                    }
                                    
                                                    if (isByExpenseChecked) {
                                                        Spacer(modifier = Modifier.height(8.dp))
                                    
                                                        // Contenedor de gastos desplazable con fondo transparente y bordes redondeados
                                                        Box(
                                                            modifier = Modifier
                                                                .fillMaxWidth()
                                                                .heightIn(max = 300.dp)
                                                                .clip(RoundedCornerShape(cornerRadius))
                                                                .background(Color.Transparent)
                                                        ) {
                                                            // Contenedor scrollable
                                                            Column(
                                                                modifier = Modifier
                                                                    .fillMaxWidth()
                                                                    .verticalScroll(scrollState)
                                                                    .padding(8.dp)
                                                            ) {
                                                                expenses.forEachIndexed { index, expense ->
                                                                    // Card para cada gasto con un borde condicional verde si est seleccionado
                                                                    Card(
                                                                        modifier = Modifier
                                                                            .fillMaxWidth()
                                                                            .padding(vertical = 4.dp)
                                                                            .border(
                                                                                width = if (index == selectedExpenseIndex) 2.dp else 0.dp,
                                                                                color = if (index == selectedExpenseIndex) Color(0xFFB3CB54) else Color.Transparent,
                                                                                shape = RoundedCornerShape(30.dp)
                                                                            )
                                                                            .clickable { selectedExpenseIndex = index }, // Al hacer clic, selecciona este contenedor
                                                                        shape = RoundedCornerShape(30.dp),
                                                                        colors = CardDefaults.cardColors(
                                                                            containerColor = lightGrayColor
                                                                        )
                                                                    ) {
                                                                        // Contenido de cada contenedor (campo de texto y otros)
                                                                        Row(
                                                                            modifier = Modifier
                                                                                .fillMaxWidth()
                                                                                .padding(8.dp),
                                                                            verticalAlignment = Alignment.CenterVertically
                                                                        ) {
                                                                            // Campo de nombre del gasto
                                                                            TextField(
                                                                                value = expense.name,
                                                                                onValueChange = { newValue ->
                                                                                    expense.name = newValue
                                                                                },
                                                                                placeholder = { Text("Expense Name", fontSize = 15.sp) },
                                                                                textStyle = TextStyle(
                                                                                    fontSize = 15.sp,
                                                                                    textAlign = TextAlign.Start
                                                                                ),
                                                                                modifier = Modifier
                                                                                    .weight(1f)
                                                                                    .height(56.dp),
                                                                                colors = TextFieldDefaults.textFieldColors(
                                                                                    containerColor = Color.Transparent,
                                                                                    focusedIndicatorColor = Color.Transparent,
                                                                                    unfocusedIndicatorColor = Color.Transparent,
                                                                                    disabledIndicatorColor = Color.Transparent,
                                                                                    errorIndicatorColor = Color.Transparent,
                                                                                ),
                                                                                shape = RoundedCornerShape(30.dp),
                                                                                singleLine = true,
                                                                            )
                                    
                                                                            Spacer(modifier = Modifier.width(8.dp))
                                    
                                                                            // Campo de monto
                                                                            TextField(
                                                                                value = expense.amount,
                                                                                onValueChange = { newValue ->
                                                                                    val filtered = newValue.replace("[^\\d.]".toRegex(), "")
                                                                                    expense.amount = filtered
                                                                                },
                                                                                placeholder = { Text("Amount", fontSize = 14.sp) },
                                                                                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
                                                                                textStyle = TextStyle(
                                                                                    fontSize = 14.sp,
                                                                                    textAlign = TextAlign.Center
                                                                                ),
                                                                                modifier = Modifier
                                                                                    .width(140.dp)
                                                                                    .height(56.dp),
                                                                                colors = TextFieldDefaults.textFieldColors(
                                                                                    containerColor = Color.White,
                                                                                    focusedIndicatorColor = Color.Transparent,
                                                                                    unfocusedIndicatorColor = Color.Transparent,
                                                                                    disabledIndicatorColor = Color.Transparent,
                                                                                    errorIndicatorColor = Color.Transparent,
                                                                                ),
                                                                                shape = RoundedCornerShape(30.dp),
                                                                                leadingIcon = { Text("$", fontSize = 14.sp) },
                                                                                singleLine = true,
                                                                                visualTransformation = NumberFormatTransformation()
                                                                            )
                                    
                                                                            Spacer(modifier = Modifier.width(8.dp))
                                    
                                                                            // Botn de eliminacin
                                                                            IconButton(
                                                                                onClick = {
                                                                                    expenses.removeAt(index)
                                                                                },
                                                                                modifier = Modifier
                                                                                    .size(24.dp)
                                                                            ) {
                                                                                Icon(
                                                                                    imageVector = Icons.Filled.Delete,
                                                                                    contentDescription = "Delete Expense",
                                                                                    tint = Color.Black
                                                                                )
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                    
                                                            // Sombras de indicacin de scroll con bordes redondeados y opacidad ajustada
                                                            if (canScrollUp) {
                                                                Box(
                                                                    modifier = Modifier
                                                                        .fillMaxWidth()
                                                                        .height(40.dp) // Sombra superior ms larga
                                                                        .background(
                                                                            Brush.verticalGradient(
                                                                                colors = listOf(Color.Gray.copy(alpha = 0.15f), Color.Transparent),
                                                                                startY = 0f,
                                                                                endY = 40f
                                                                            )
                                                                        )
                                                                        .clip(RoundedCornerShape(cornerRadius))
                                                                        .align(Alignment.TopCenter)
                                                                )
                                                            }
                                    
                                                            if (canScrollDown) {
                                                                Box(
                                                                    modifier = Modifier
                                                                        .fillMaxWidth()
                                                                        .height(30.dp)
                                                                        .background(
                                                                            Brush.verticalGradient(
                                                                                colors = listOf(Color.Transparent, Color.Gray.copy(alpha = 0.15f)),
                                                                                startY = 0f,
                                                                                endY = 30f
                                                                            )
                                                                        )
                                                                        .clip(RoundedCornerShape(cornerRadius))
                                                                        .align(Alignment.BottomCenter)
                                                                )
                                                            }
                                                        }
                                    
                                                        Spacer(modifier = Modifier.height(8.dp))
                                    
                                                        // Botn para agregar gasto
                                                        Button(
                                                            onClick = { expenses.add(Expense("", "")) },
                                                            enabled = isByExpenseChecked,
                                                            colors = ButtonDefaults.buttonColors(containerColor = lightGrayColor),
                                                            shape = RoundedCornerShape(50),
                                                            modifier = Modifier.fillMaxWidth()
                                                        ) {
                                                            Text("Add expense")
                                                        }
                                                    }
                                    
                                                    Spacer(modifier = Modifier.height(16.dp))
                                    
                                                    // Seccin By Quantity
                                                    Row(verticalAlignment = Alignment.CenterVertically) {
                                                        Checkbox(
                                                            checked = isByQuantityChecked,
                                                            onCheckedChange = {
                                                                isByQuantityChecked = it
                                                                if (it) isByExpenseChecked = false
                                                            }
                                                        )
                                                        Spacer(modifier = Modifier.width(8.dp))
                                                        Text("By quantity")
                                                    }
                                    
                                                    if (isByQuantityChecked) {
                                                        Spacer(modifier = Modifier.height(8.dp))
                                    
                                                        // Contenedor de frecuencia con botones estilizados
                                                        Card(
                                                            modifier = Modifier
                                                                .fillMaxWidth()
                                                                .padding(vertical = 4.dp),
                                                            shape = RoundedCornerShape(cornerRadius),
                                                            colors = CardDefaults.cardColors(
                                                                containerColor = lightGrayColor
                                                            )
                                                        ) {
                                                            Row(
                                                                modifier = Modifier
                                                                    .fillMaxWidth()
                                                                    .padding(8.dp),
                                                                horizontalArrangement = Arrangement.SpaceAround,
                                                                verticalAlignment = Alignment.CenterVertically
                                                            ) {
                                                                listOf("Daily", "Weekly", "Monthly").forEach { frequency ->
                                                                    Button(
                                                                        onClick = { selectedFrequency = frequency },
                                                                        colors = ButtonDefaults.buttonColors(
                                                                            containerColor = if (selectedFrequency == frequency) selectedButtonColor else lightGrayColor,
                                                                            contentColor = if (selectedFrequency == frequency) Color.White else Color.Black
                                                                        ),
                                                                        shape = RoundedCornerShape(20.dp),
                                                                        modifier = Modifier
                                                                            .weight(1f)
                                                                            .padding(horizontal = 4.dp)
                                                                    ) {
                                                                        Text(frequency)
                                                                    }
                                                                }
                                                            }
                                                        }
                                    
                                                        Spacer(modifier = Modifier.height(8.dp))
                                    
                                    
                                                        Card(
                                                            modifier = Modifier
                                                                .width(210.dp)
                                                                .padding(vertical = 4.dp),
                                                            shape = RoundedCornerShape(cornerRadius),
                                                            colors = CardDefaults.cardColors(
                                                                containerColor = lightGrayColor
                                                            )
                                                        ) {
                                                            Box(
                                                                modifier = Modifier.fillMaxWidth(),
                                                                contentAlignment = Alignment.Center // Centramos el contenido en el contenedor
                                                            ) {
                                                                Card(
                                                                    modifier = Modifier
                                                                        .width(230.dp)
                                                                        .padding(vertical = 4.dp),
                                                                    shape = RoundedCornerShape(cornerRadius),
                                                                    colors = CardDefaults.cardColors(
                                                                        containerColor = lightGrayColor
                                                                    )
                                                                ) {
                                                                    Box(
                                                                        modifier = Modifier.fillMaxWidth(),
                                                                        contentAlignment = Alignment.Center // Centra el contenido interno tambin
                                                                    ) {
                                                                        Card(
                                                                            modifier = Modifier
                                                                                .width(200.dp) // Ancho del fondo gris limitado a 200.dp
                                                                                .padding(vertical = 4.dp),
                                                                            shape = RoundedCornerShape(30.dp),
                                                                            colors = CardDefaults.cardColors(
                                                                                containerColor = Color(0xFFD9D9D9) // Fondo gris claro
                                                                            )
                                                                        ) {
                                                                            // Campo de texto para el monto dentro del fondo gris
                                                                            TextField(
                                                                                value = amountText,
                                                                                onValueChange = { newValue ->
                                                                                    // Permitir solo dgitos y puntos
                                                                                    val filtered = newValue.replace("[^\\d.]".toRegex(), "")
                                                                                    amountText = filtered
                                                                                },
                                                                                placeholder = {
                                                                                    Text(
                                                                                        "Amount",
                                                                                        fontSize = 15.sp
                                                                                    )
                                                                                },
                                                                                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
                                                                                textStyle = TextStyle(
                                                                                    fontSize = 15.sp,
                                                                                    textAlign = TextAlign.Center
                                                                                ),
                                                                                modifier = Modifier
                                                                                    .fillMaxWidth()
                                                                                    .background(
                                                                                        Color.White,
                                                                                        shape = RoundedCornerShape(30.dp)
                                                                                    ) // Fondo blanco en el campo de texto
                                                                                    .height(60.dp), // Ajusta la altura segn sea necesario
                                                                                shape = RoundedCornerShape(30.dp),
                                                                                colors = TextFieldDefaults.textFieldColors(
                                                                                    containerColor = Color.Transparent,
                                                                                    focusedIndicatorColor = Color.Transparent,
                                                                                    unfocusedIndicatorColor = Color.Transparent,
                                                                                    disabledIndicatorColor = Color.Transparent,
                                                                                    errorIndicatorColor = Color.Transparent,
                                                                                ),
                                                                                leadingIcon = {
                                                                                    Text("$", fontSize = 15.sp)
                                                                                },
                                                                                singleLine = true,
                                                                                visualTransformation = NumberFormatTransformation()
                                                                            )
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    
                                        // Funcin de formateo de nmero (opcional, no utilizada en el ltimo cdigo)
                                        fun formatCurrency(value: String): String {
                                            return if (value.isNotEmpty()) {
                                                try {
                                                    NumberFormat.getNumberInstance(Locale.US).format(value.toDouble())
                                                } catch (e: NumberFormatException) {
                                                    value
                                                }
                                            } else value
                                        }
                                    }
                                    ```
                                - ProfileAccountScreen.kt
                                    ```
                                    // ProfileAccountScreen.kt
                                    package com.isis3510.spendiq.views.profile
                                    
                                    import androidx.compose.foundation.background
                                    import androidx.compose.foundation.layout.*
                                    import androidx.compose.foundation.shape.CircleShape
                                    import androidx.compose.material3.*
                                    import androidx.compose.runtime.*
                                    import androidx.compose.ui.Alignment
                                    import androidx.compose.ui.Modifier
                                    import androidx.compose.ui.graphics.Color
                                    import androidx.compose.ui.res.painterResource
                                    import androidx.compose.ui.unit.dp
                                    import androidx.navigation.NavController
                                    import com.isis3510.spendiq.R
                                    import com.isis3510.spendiq.views.common.BottomNavigation
                                    import com.isis3510.spendiq.viewmodel.AccountViewModel
                                    import com.isis3510.spendiq.viewmodel.TransactionViewModel
                                    import kotlinx.coroutines.delay
                                    import kotlinx.coroutines.launch
                                    
                                    @OptIn(ExperimentalMaterial3Api::class)
                                    @Composable
                                    fun ProfileAccountScreen(
                                        navController: NavController,
                                        userData: Map<String, Any?>?,
                                        transactionViewModel: TransactionViewModel,
                                        accountViewModel: AccountViewModel
                                    ) {
                                        // Estado para evitar mltiples clics rpidos en el botn de retroceso
                                        var isNavigating by remember { mutableStateOf(false) }
                                        val coroutineScope = rememberCoroutineScope()
                                    
                                        Scaffold(
                                            topBar = {
                                                TopAppBar(
                                                    title = { Text("Account Settings") },
                                                    navigationIcon = {
                                                        IconButton(onClick = {
                                                            if (!isNavigating) {
                                                                isNavigating = true
                                                                coroutineScope.launch {
                                                                    navController.popBackStack()
                                                                    delay(300) // Esperar 300 ms antes de permitir otro clic
                                                                    isNavigating = false
                                                                }
                                                            }
                                                        }) {
                                                            Icon(
                                                                painter = painterResource(id = R.drawable.round_arrow_back_ios_24),
                                                                contentDescription = "Back"
                                                            )
                                                        }
                                                    }
                                                )
                                            },
                                            bottomBar = {
                                                BottomNavigation(
                                                    navController = navController,
                                                    transactionViewModel = transactionViewModel,
                                                    accountViewModel = accountViewModel
                                                )
                                            }
                                        ) { innerPadding ->
                                            Column(
                                                modifier = Modifier
                                                    .fillMaxSize()
                                                    .padding(innerPadding)
                                            ) {
                                                Spacer(modifier = Modifier.height(16.dp))
                                                // Campos de perfil con fondo rosado en los iconos
                                                ProfileField("Full Name", (userData?.get("fullName") as? String) ?: "N/A", R.drawable.person24)
                                                ProfileField("Email Address", (userData?.get("email") as? String) ?: "N/A", R.drawable.email24)
                                                ProfileField("Phone Number", (userData?.get("phoneNumber") as? String) ?: "N/A", R.drawable.phone24)
                                                ProfileField("Birth Date", (userData?.get("birthDate") as? String) ?: "N/A", R.drawable.calendar24)
                                            }
                                        }
                                    }
                                    
                                    @Composable
                                    fun ProfileField(label: String, value: String, iconResId: Int) {
                                        Row(
                                            modifier = Modifier
                                                .fillMaxWidth()
                                                .padding(16.dp),
                                            verticalAlignment = Alignment.CenterVertically
                                        ) {
                                            Box(
                                                modifier = Modifier
                                                    .size(40.dp)
                                                    .background(Color(0xFFC33BA5), shape = CircleShape),
                                                contentAlignment = Alignment.Center
                                            ) {
                                                Icon(
                                                    painter = painterResource(id = iconResId),
                                                    contentDescription = label,
                                                    modifier = Modifier.size(24.dp),
                                                    tint = Color.White
                                                )
                                            }
                                            Spacer(modifier = Modifier.width(16.dp))
                                            Column {
                                                Text(
                                                    text = label,
                                                    style = MaterialTheme.typography.bodySmall,
                                                    color = MaterialTheme.colorScheme.onBackground
                                                )
                                                Text(
                                                    text = value,
                                                    style = MaterialTheme.typography.bodyLarge,
                                                    color = MaterialTheme.colorScheme.onBackground
                                                )
                                            }
                                        }
                                    }
                                    ```
                                - ProfileScreen.kt
                                    ```
                                    package com.isis3510.spendiq.views.profile
                                    
                                    import android.annotation.SuppressLint
                                    import android.content.Context
                                    import android.graphics.Bitmap
                                    import android.location.Geocoder
                                    import android.location.Location
                                    import android.net.Uri
                                    import android.widget.Toast
                                    import androidx.activity.compose.rememberLauncherForActivityResult
                                    import androidx.activity.result.contract.ActivityResultContracts
                                    import androidx.compose.foundation.Canvas
                                    import androidx.compose.foundation.Image
                                    import androidx.compose.foundation.background
                                    import androidx.compose.foundation.border
                                    import androidx.compose.foundation.clickable
                                    import androidx.compose.foundation.layout.*
                                    import androidx.compose.foundation.rememberScrollState
                                    import androidx.compose.foundation.shape.CircleShape
                                    import androidx.compose.foundation.shape.RoundedCornerShape
                                    import androidx.compose.foundation.verticalScroll
                                    import androidx.compose.material.icons.Icons
                                    import androidx.compose.material.icons.automirrored.filled.ArrowBack
                                    import androidx.compose.material3.*
                                    import androidx.compose.runtime.*
                                    import androidx.compose.ui.Alignment
                                    import androidx.compose.ui.Modifier
                                    import androidx.compose.ui.draw.alpha
                                    import androidx.compose.ui.draw.clip
                                    import androidx.compose.ui.graphics.Color
                                    import androidx.compose.ui.graphics.ColorFilter
                                    import androidx.compose.ui.graphics.StrokeCap
                                    import androidx.compose.ui.graphics.drawscope.Stroke
                                    import androidx.compose.ui.layout.ContentScale
                                    import androidx.compose.ui.platform.LocalContext
                                    import androidx.compose.ui.res.painterResource
                                    import androidx.compose.ui.text.font.FontWeight
                                    import androidx.compose.ui.tooling.data.UiToolingDataApi
                                    import androidx.compose.ui.unit.dp
                                    import androidx.navigation.NavController
                                    import coil.compose.rememberAsyncImagePainter
                                    import com.google.android.gms.location.FusedLocationProviderClient
                                    import com.google.android.gms.location.LocationServices
                                    import com.isis3510.spendiq.R
                                    import com.isis3510.spendiq.viewmodel.AccountViewModel
                                    import com.isis3510.spendiq.viewmodel.AuthViewModel
                                    import com.isis3510.spendiq.viewmodel.TransactionViewModel
                                    import com.isis3510.spendiq.viewmodel.ProfileViewModel
                                    import com.isis3510.spendiq.views.common.BottomNavigation
                                    import kotlinx.coroutines.Dispatchers
                                    import kotlinx.coroutines.withContext
                                    import java.io.File
                                    import java.io.FileOutputStream
                                    import java.io.IOException
                                    import java.util.*
                                    
                                    @OptIn(ExperimentalMaterial3Api::class)
                                    @Composable
                                    fun ProfileScreen(
                                        navController: NavController,
                                        viewModel: AuthViewModel,
                                        transactionViewModel: TransactionViewModel,
                                        accountViewModel: AccountViewModel,
                                        profileViewModel: ProfileViewModel
                                    ) {
                                        var userData by remember { mutableStateOf<Map<String, Any>?>(null) }
                                        val profileImageUri by profileViewModel.profileImageUri.collectAsState()
                                        var isLoading by remember { mutableStateOf(true) }
                                        val context = LocalContext.current
                                    
                                        var locationText by remember { mutableStateOf("Location not available") }
                                    
                                    
                                        val galleryLauncher = rememberLauncherForActivityResult(ActivityResultContracts.GetContent()) { uri ->
                                            uri?.let { newUri ->
                                                saveImageToInternalStorage(context, newUri)
                                                profileViewModel.saveProfileImage(context, newUri)
                                            }
                                        }
                                    
                                        LaunchedEffect(Unit) {
                                            viewModel.getUserData()
                                            profileViewModel.loadProfileImage(context)
                                            updateLocation(context) { location -> locationText = location }
                                        }
                                    
                                        val userDataState by viewModel.userData.collectAsState()
                                        LaunchedEffect(userDataState) {
                                            when (userDataState) {
                                                is AuthViewModel.UserDataState.Success -> {
                                                    userData = (userDataState as AuthViewModel.UserDataState.Success).data
                                                    isLoading = false
                                                }
                                                is AuthViewModel.UserDataState.Error -> {
                                                    Toast.makeText(
                                                        context,
                                    
                                                        "Error loading data: ${(userDataState as AuthViewModel.UserDataState.Error).message}",
                                    
                                                        Toast.LENGTH_LONG
                                                    ).show()
                                                    isLoading = false
                                                }
                                                AuthViewModel.UserDataState.Loading -> isLoading = true
                                                AuthViewModel.UserDataState.Idle -> {}
                                            }
                                        }
                                    
                                        Scaffold(
                                            topBar = {
                                                TopAppBar(
                                                    title = { Text("Profile") },
                                                    navigationIcon = {
                                    
                                                        IconButton(onClick = { navController.navigate("main") { launchSingleTop = true } }) {
                                                            Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back")
                                    
                                                        }
                                                    }
                                                )
                                            },
                                            bottomBar = {
                                                BottomNavigation(
                                                    navController = navController,
                                                    transactionViewModel = transactionViewModel,
                                                    accountViewModel = accountViewModel
                                                )
                                            }
                                        ) { innerPadding ->
                                            if (isLoading) {
                                                Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                                                    CircularProgressIndicator()
                                                }
                                            } else {
                                                Column(
                                                    modifier = Modifier
                                                        .fillMaxSize()
                                                        .padding(innerPadding)
                                                        .padding(16.dp)
                                                        .verticalScroll(rememberScrollState()),
                                    
                                                    horizontalAlignment = Alignment.CenterHorizontally
                                                ) {
                                                    Box(
                                                        modifier = Modifier
                                                            .size(120.dp)
                                                            .clickable {
                                                                galleryLauncher.launch("image/*")
                                                            }
                                                    ) {
                                                        ProfileImageWithMultiColorBorder(profileImageUri)
                                                    }
                                    
                                                    Spacer(modifier = Modifier.height(12.dp))
                                    
                                                    userData?.let { data ->
                                                        Text(
                                                            text = (data["fullName"] as? String) ?: "",
                                                            style = MaterialTheme.typography.headlineMedium,
                                                            fontWeight = FontWeight.Bold
                                                        )
                                    
                                                        Spacer(modifier = Modifier.height(12.dp))
                                    
                                                        Row(verticalAlignment = Alignment.CenterVertically) {
                                                            Icon(
                                                                painter = painterResource(id = R.drawable.baseline_location_pin_24),
                                                                contentDescription = "Location",
                                                                tint = Color.Gray,
                                                                modifier = Modifier.size(24.dp)
                                                            )
                                                            Spacer(modifier = Modifier.width(8.dp))
                                                            Text(
                                                                text = locationText,
                                                                style = MaterialTheme.typography.bodyLarge
                                                            )
                                                        }
                                                    }
                                    
                                                    Spacer(modifier = Modifier.height(24.dp))
                                    
                                                    SectionWithButtons(navController)
                                    
                                                    Spacer(modifier = Modifier.height(24.dp))
                                    
                                                    Button(
                                                        onClick = {
                                                            viewModel.logout()
                                                            navController.navigate("authentication") {
                                                                popUpTo(0) { inclusive = true }
                                                            }
                                                        },
                                                        modifier = Modifier.fillMaxWidth(0.8f)
                                                    ) {
                                                        Text("Logout")
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    
                                    @Composable
                                    fun SectionWithButtons(navController: NavController) {
                                        Column {
                                            // Seccin de Notificaciones, Seguridad y Cuenta
                                            Box(modifier = Modifier.padding(vertical = 8.dp)) {
                                                Column(
                                                    modifier = Modifier
                                                        .fillMaxWidth()
                                                        .clip(RoundedCornerShape(20.dp))
                                                        .background(Color(0xFFEEEEEE))
                                                        .padding(16.dp)
                                                ) {
                                                    // Botn Notifications - Deshabilitado
                                                    ActionButtonWithArrow(
                                                        text = "Notifications",
                                                        iconResId = R.drawable.baseline_notifications_24,
                                                        navController = navController,
                                                        backgroundColor = Color(0xFFC33BA5),
                                                        textColor = Color.Black,
                                                        enabled = false // Deshabilitado
                                                    ) {
                                                        // Accin deshabilitada, no se ejecutar
                                                    }
                                                    Divider(color = Color(0xFFC5C5C5), thickness = 1.dp)
                                    
                                                    // Botn Security - Deshabilitado
                                                    ActionButtonWithArrow(
                                                        text = "Security",
                                                        iconResId = R.drawable.baseline_shield_24,
                                                        navController = navController,
                                                        backgroundColor = Color(0xFFC33BA5),
                                                        textColor = Color.Black,
                                                        enabled = false // Deshabilitado
                                                    ) {
                                                        // Accin deshabilitada, no se ejecutar
                                                    }
                                                    Divider(color = Color(0xFFC5C5C5), thickness = 1.dp)
                                    
                                                    // Botn Account - Habilitado (opcional, ya que es true por defecto)
                                                    ActionButtonWithArrow(
                                                        text = "Account",
                                                        iconResId = R.drawable.person24,
                                                        navController = navController,
                                                        backgroundColor = Color(0xFFC33BA5),
                                                        textColor = Color.Black
                                                        // enabled = true por defecto
                                                    ) {
                                                        navController.navigate("profileAccountScreen") { launchSingleTop = true }
                                                    }
                                                }
                                            }
                                    
                                            // Seccin de Limites y Estadsticas
                                            Box(modifier = Modifier.padding(vertical = 8.dp)) {
                                                Column(
                                                    modifier = Modifier
                                                        .fillMaxWidth()
                                                        .clip(RoundedCornerShape(20.dp))
                                                        .background(Color(0xFFEEEEEE))
                                                        .padding(16.dp)
                                                ) {
                                                    ActionButtonWithArrow(
                                                        text = "Limits and Goals",
                                                        iconResId = R.drawable.baseline_adjust_24,
                                                        navController = navController,
                                                        backgroundColor = Color(0xFFB3CB54),
                                                        textColor = Color.Black
                                                    ) {
                                                        navController.navigate("profileLaGScreen") { launchSingleTop = true }
                                                    }
                                                    Divider(color = Color(0xFFC5C5C5), thickness = 1.dp)
                                                    ActionButtonWithArrow(
                                                        text = "Estatistics",
                                                        iconResId = R.drawable.round_equalizer_24,
                                                        navController = navController,
                                                        backgroundColor = Color(0xFFB3CB54),
                                                        textColor = Color.Black
                                                    ) {
                                                        navController.navigate("profileStatisticsScreen") { launchSingleTop = true }
                                                    }
                                                }
                                            }
                                    
                                            // Seccin de Ayuda e Informacin
                                            Box(modifier = Modifier.padding(vertical = 8.dp)) {
                                                Column(
                                                    modifier = Modifier
                                                        .fillMaxWidth()
                                                        .clip(RoundedCornerShape(20.dp))
                                                        .background(Color(0xFFEEEEEE))
                                                        .padding(16.dp)
                                                ) {
                                                    // Botn Help - Deshabilitado
                                                    ActionButtonWithArrow(
                                                        text = "Help",
                                                        iconResId = R.drawable.outline_question_mark_24,
                                                        navController = navController,
                                                        backgroundColor = Color(0xFF5875DD),
                                                        textColor = Color.Black,
                                                        enabled = false // Deshabilitado
                                                    ) {
                                                        // Accin deshabilitada, no se ejecutar
                                                    }
                                                    Divider(color = Color(0xFFC5C5C5), thickness = 1.dp)
                                    
                                                    // Botn Information - Deshabilitado
                                                    ActionButtonWithArrow(
                                                        text = "Information",
                                                        iconResId = R.drawable.sharp_info_outline_24,
                                                        navController = navController,
                                                        backgroundColor = Color(0xFF5875DD),
                                                        textColor = Color.Black,
                                                        enabled = false // Deshabilitado
                                                    ) {
                                                        // Accin deshabilitada, no se ejecutar
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    
                                    
                                    @Composable
                                    fun ActionButtonWithArrow(
                                        text: String,
                                        iconResId: Int,
                                        navController: NavController,
                                        backgroundColor: Color = Color(0xFFB3CB54),
                                        textColor: Color = Color.Black,
                                        enabled: Boolean = true, // Nuevo parmetro
                                        onClick: () -> Unit
                                    ) {
                                        Row(
                                            modifier = Modifier
                                                .fillMaxWidth()
                                                .then(
                                                    if (enabled) {
                                                        Modifier.clickable(onClick = onClick)
                                                    } else {
                                                        Modifier
                                                    }
                                                )
                                                .padding(vertical = 12.dp)
                                                .alpha(if (enabled) 1f else 0.5f), // Cambia la opacidad para indicar estado deshabilitado
                                            verticalAlignment = Alignment.CenterVertically
                                        ) {
                                            Box(
                                                modifier = Modifier
                                                    .size(40.dp)
                                                    .clip(CircleShape)
                                                    .background(backgroundColor),
                                                contentAlignment = Alignment.Center
                                            ) {
                                                Icon(
                                                    painter = painterResource(id = iconResId),
                                                    contentDescription = text,
                                                    tint = Color.White,
                                                    modifier = Modifier.size(24.dp)
                                                )
                                            }
                                            Spacer(modifier = Modifier.width(8.dp))
                                            Text(
                                                text = text,
                                                style = MaterialTheme.typography.bodyLarge,
                                                color = textColor,
                                                modifier = Modifier.weight(1f)
                                            )
                                            if (enabled) { // Solo muestra la flecha si est habilitado
                                                Icon(
                                                    painter = painterResource(id = R.drawable.round_arrow_forward_ios_24),
                                                    contentDescription = "Arrow",
                                                    tint = Color.Black,
                                                    modifier = Modifier.size(24.dp)
                                                )
                                            }
                                        }
                                    }
                                    
                                    
                                    @SuppressLint("ResourceAsColor")
                                    @Composable
                                    fun ProfileImageWithMultiColorBorder(profileImageUri: Uri?) {
                                        Box(
                                            modifier = Modifier
                                                .size(106.dp) // Ajuste para dar espacio a los bordes
                                                .clip(CircleShape)
                                        ) {
                                            // Dibujo de los arcos de colores
                                            Canvas(modifier = Modifier.matchParentSize()) {
                                                drawArc(
                                                    color = Color(0xFFB3CB54),
                                                    startAngle = 0f,
                                                    sweepAngle = 90f,
                                                    useCenter = false,
                                                    style = Stroke(8.dp.toPx(), cap = StrokeCap.Round)
                                                )
                                                drawArc(
                                                    color = Color(0xFFC33BA5),
                                                    startAngle = 90f,
                                                    sweepAngle = 90f,
                                                    useCenter = false,
                                                    style = Stroke(8.dp.toPx(), cap = StrokeCap.Round)
                                                )
                                                drawArc(
                                                    color = Color(0xFFB3CB54),
                                                    startAngle = 180f,
                                                    sweepAngle = 90f,
                                                    useCenter = false,
                                                    style = Stroke(8.dp.toPx(), cap = StrokeCap.Round)
                                                )
                                                drawArc(
                                                    color = Color(0xFFC33BA5),
                                                    startAngle = 270f,
                                                    sweepAngle = 90f,
                                                    useCenter = false,
                                                    style = Stroke(8.dp.toPx(), cap = StrokeCap.Round)
                                                )
                                            }
                                    
                                            // Imagen de perfil (si existe)
                                            Box(
                                                modifier = Modifier
                                                    .size(100.dp) // Tamao ms pequeo para la imagen de perfil, respetando los bordes
                                                    .clip(CircleShape)
                                                    .align(Alignment.Center)
                                                    .background(Color.Gray), // Fondo gris por defecto
                                                contentAlignment = Alignment.Center
                                            ) {
                                                if (profileImageUri != null) {
                                                    Image(
                                                        painter = rememberAsyncImagePainter(profileImageUri),
                                                        contentDescription = "Profile Picture",
                                                        modifier = Modifier
                                                            .fillMaxSize()
                                                            .clip(CircleShape),
                                                        contentScale = ContentScale.Crop
                                                    )
                                                } else {
                                                    Image(
                                                        painter = painterResource(id = R.drawable.baseline_add_a_photo_24),
                                                        contentDescription = "Add Photo",
                                                        modifier = Modifier.size(50.dp),
                                                        colorFilter = ColorFilter.tint(Color.White)
                                                    )
                                                }
                                            }
                                        }
                                    }
                                    
                                    @Composable
                                    fun ActionButton(text: String) {
                                        Button(onClick = { /* Acciones de botn */ }) {
                                            Text(text)
                                        }
                                    }
                                    
                                    
                                    
                                    
                                    @OptIn(UiToolingDataApi::class)
                                    @SuppressLint("MissingPermission") // Asegrate de manejar permisos en el nivel de actividad
                                    suspend fun updateLocation(context: Context, onLocationUpdated: (String) -> Unit) {
                                        val fusedLocationClient: FusedLocationProviderClient = LocationServices.getFusedLocationProviderClient(context)
                                    
                                        withContext(Dispatchers.IO) {
                                            fusedLocationClient.lastLocation.addOnSuccessListener { location: Location? ->
                                                location?.let {
                                                    val geocoder = Geocoder(context, Locale.getDefault())
                                                    val addresses = geocoder.getFromLocation(it.latitude, it.longitude, 1)
                                                    if (addresses != null) {
                                                        if (addresses.isNotEmpty()) {
                                                            val city = addresses[0].locality ?: "Ciudad desconocida"
                                                            val country = addresses[0].countryName ?: "Pas desconocido"
                                                            onLocationUpdated("$city, $country")
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    
                                    
                                    fun saveBitmapToInternalStorage(context: Context, bitmap: Bitmap): Uri? {
                                        val filename = "profile_image.png"
                                        val file = File(context.filesDir, filename)
                                        return try {
                                            val outputStream = FileOutputStream(file)
                                            bitmap.compress(Bitmap.CompressFormat.PNG, 100, outputStream)
                                            outputStream.flush()
                                            outputStream.close()
                                            Uri.fromFile(file)
                                        } catch (e: IOException) {
                                            e.printStackTrace()
                                            null
                                        }
                                    }
                                    
                                    // Funcin para guardar la imagen en el almacenamiento interno
                                    fun saveImageToInternalStorage(context: Context, uri: Uri) {
                                        val file = File(context.filesDir, "profile_image.png")
                                        context.contentResolver.openInputStream(uri)?.use { inputStream ->
                                            FileOutputStream(file).use { outputStream ->
                                                inputStream.copyTo(outputStream)
                                            }
                                        }
                                    }
                                    
                                    // Funcin para guardar la URI de la imagen de perfil de manera persistente
                                    fun saveProfileImageUri(context: Context, uri: Uri) {
                                        val sharedPreferences = context.getSharedPreferences("profile_prefs", Context.MODE_PRIVATE)
                                        sharedPreferences.edit().putString("profile_image_uri", uri.toString()).apply()
                                    }
                                    
                                    // Funcin para obtener la URI de la imagen de perfil almacenada de manera persistente
                                    fun getProfileImageUri(context: Context): Uri? {
                                        val sharedPreferences = context.getSharedPreferences("profile_prefs", Context.MODE_PRIVATE)
                                        val uriString = sharedPreferences.getString("profile_image_uri", null)
                                        return uriString?.let { Uri.parse(it) }
                                    }
                                    ```
                            - **accounts/**
                                - AccountTransactionsScreen.kt
                                    ```
                                    package com.isis3510.spendiq.views.accounts
                                    
                                    import android.content.Intent
                                    import android.net.Uri
                                    import androidx.compose.foundation.background
                                    import androidx.compose.foundation.clickable
                                    import androidx.compose.foundation.layout.*
                                    import androidx.compose.foundation.lazy.LazyColumn
                                    import androidx.compose.foundation.lazy.items
                                    import androidx.compose.foundation.shape.CircleShape
                                    import androidx.compose.material.icons.Icons
                                    import androidx.compose.material.icons.automirrored.filled.ArrowBack
                                    import androidx.compose.material.icons.filled.KeyboardArrowDown
                                    import androidx.compose.material.icons.filled.KeyboardArrowUp
                                    import androidx.compose.material.icons.filled.LocationOn
                                    import androidx.compose.material.icons.filled.Search
                                    import androidx.compose.material3.*
                                    import androidx.compose.runtime.*
                                    import androidx.compose.ui.Alignment
                                    import androidx.compose.ui.Modifier
                                    import androidx.compose.ui.graphics.Color
                                    import androidx.compose.ui.platform.LocalContext
                                    import androidx.compose.ui.text.font.FontWeight
                                    import androidx.compose.ui.unit.dp
                                    import androidx.compose.ui.unit.sp
                                    import androidx.lifecycle.viewmodel.compose.viewModel
                                    import androidx.navigation.NavController
                                    import com.isis3510.spendiq.model.data.Transaction
                                    import com.isis3510.spendiq.viewmodel.TransactionViewModel
                                    import kotlinx.coroutines.delay
                                    import kotlinx.coroutines.launch
                                    import java.text.NumberFormat
                                    import java.text.SimpleDateFormat
                                    import java.util.*
                                    
                                    /**
                                     * AccountTransactionsScreen composable function
                                     *
                                     * Displays a list of transactions for a specific account. This screen allows users to view,
                                     * search, and filter transactions associated with an account. Users can also access detailed
                                     * views of individual transactions and see location information if available.
                                     *
                                     * Key Features:
                                     * - Transaction Listing: Displays transactions with details such as name, amount, type (income/expense),
                                     *   and indicators for any anomalies related to location or amount.
                                     * - Search Functionality: Allows users to filter transactions by name using a search bar.
                                     * - Date Grouping: Groups transactions by date for better organization and readability.
                                     * - Location Handling: Includes a feature to view the location associated with a transaction using
                                     *   the device's map application.
                                     *
                                     * UI Structure:
                                     * - Scaffold with a TopAppBar that includes the account name and a back navigation button.
                                     * - Search field for filtering transactions.
                                     * - A LazyColumn that displays transactions grouped by date, with the ability to click on each
                                     *   transaction for further details.
                                     *
                                     * Supporting Components:
                                     * - `TransactionItem`: A composable that represents an individual transaction and displays relevant
                                     *   details.
                                     * - `AnomalyIndicator`: Visual feedback indicating any anomalies in the transaction data.
                                     *
                                     * @param navController [NavController] to handle navigation actions within the app.
                                     * @param accountName The name of the account for which transactions are being displayed.
                                     * @param viewModel [TransactionViewModel] to manage and provide transaction data.
                                     */
                                    
                                    @OptIn(ExperimentalMaterial3Api::class)
                                    @Composable
                                    fun AccountTransactionsScreen(
                                        navController: NavController,
                                        accountName: String,
                                        viewModel: TransactionViewModel = viewModel()
                                    ) {
                                        // State for managing search query
                                        var searchQuery by remember { mutableStateOf("") }
                                        // State for collecting transactions and UI state
                                        val transactions by viewModel.transactions.collectAsState()
                                        val uiState by viewModel.uiState.collectAsState()
                                        var isNavigating by remember { mutableStateOf(false) }
                                        val coroutineScope = rememberCoroutineScope()
                                    
                                        // Load transactions for the specified account
                                        LaunchedEffect(accountName) {
                                            viewModel.fetchTransactions(accountName)
                                        }
                                    
                                        // Scaffold layout with TopAppBar
                                        Scaffold(
                                            topBar = {
                                                TopAppBar(
                                                    title = { Text(accountName) },
                                                    navigationIcon = {
                                                        IconButton(onClick = {
                                                            if (!isNavigating) {
                                                                isNavigating = true
                                                                coroutineScope.launch {
                                                                    navController.popBackStack()
                                                                    delay(300)
                                                                    isNavigating = false
                                                                }
                                                            }
                                                        }) {
                                                            Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back")
                                                        }
                                                    }
                                                )
                                            }
                                        ) { innerPadding ->
                                            when (uiState) {
                                                is TransactionViewModel.UiState.Loading -> {
                                                    Box(
                                                        modifier = Modifier.fillMaxSize(),
                                                        contentAlignment = Alignment.Center
                                                    ) {
                                                        CircularProgressIndicator()
                                                    }
                                                }
                                                is TransactionViewModel.UiState.Error -> {
                                                    Box(
                                                        modifier = Modifier.fillMaxSize(),
                                                        contentAlignment = Alignment.Center
                                                    ) {
                                                        Text(
                                                            text = "Error: ${(uiState as TransactionViewModel.UiState.Error).message}",
                                                            color = MaterialTheme.colorScheme.error
                                                        )
                                                    }
                                                }
                                                else -> {
                                                    Column(
                                                        modifier = Modifier
                                                            .fillMaxSize()
                                                            .padding(innerPadding)
                                                    ) {
                                                        // Search Field for filtering transactions
                                                        OutlinedTextField(
                                                            value = searchQuery,
                                                            onValueChange = { searchQuery = it },
                                                            label = { Text("Buscar") },
                                                            leadingIcon = { Icon(Icons.Default.Search, contentDescription = "Search") },
                                                            modifier = Modifier
                                                                .fillMaxWidth()
                                                                .padding(16.dp)
                                                        )
                                    
                                                        // Handle empty transaction list
                                                        if (transactions.isEmpty()) {
                                                            Box(
                                                                modifier = Modifier.fillMaxSize(),
                                                                contentAlignment = Alignment.Center
                                                            ) {
                                                                Text("No hay transacciones an", style = MaterialTheme.typography.bodyLarge)
                                                            }
                                                        } else {
                                                            // LazyColumn to display transactions
                                                            LazyColumn(
                                                                modifier = Modifier.fillMaxSize()
                                                            ) {
                                                                // Filter transactions based on the search query
                                                                val filteredTransactions = transactions.filter {
                                                                    it.transactionName.contains(searchQuery, ignoreCase = true)
                                                                }
                                    
                                                                // Group transactions by normalized date
                                                                val groupedTransactions = filteredTransactions.groupBy { normalizeDate(it.dateTime.toDate()) }
                                                                val sortedDates = groupedTransactions.keys.sortedDescending()
                                    
                                                                // Iterate through grouped dates to display transactions
                                                                sortedDates.forEach { date ->
                                                                    val transactionsForDate = groupedTransactions[date] ?: return@forEach
                                    
                                                                    // Display date header
                                                                    item {
                                                                        Text(
                                                                            text = formatDate(date),
                                                                            modifier = Modifier.padding(start = 16.dp, top = 16.dp, bottom = 8.dp),
                                                                            style = MaterialTheme.typography.labelLarge,
                                                                            color = Color.Gray
                                                                        )
                                                                    }
                                    
                                                                    // Display each transaction for the given date
                                                                    items(transactionsForDate.sortedByDescending { it.dateTime }) { transaction ->
                                                                        TransactionItem(transaction, navController, accountName)
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    
                                    /**
                                     * TransactionItem composable function
                                     *
                                     * Displays the details of a single transaction, including its name, amount, type, and any associated
                                     * anomalies. Provides a clickable interface to navigate to detailed transaction information, and shows
                                     * location information if applicable.
                                     *
                                     * @param transaction [Transaction] the transaction data to display.
                                     * @param navController [NavController] to handle navigation to transaction details.
                                     * @param accountName The name of the account associated with the transaction.
                                     */
                                    @Composable
                                    fun TransactionItem(transaction: Transaction, navController: NavController, accountName: String) {
                                        val context = LocalContext.current
                                    
                                        // Determine background color based on anomalies
                                        val backgroundColor = when {
                                            transaction.locationAnomaly && transaction.amountAnomaly -> Color(0xFFFFE0E0) // Light red
                                            transaction.locationAnomaly || transaction.amountAnomaly -> Color(0xFFFFECB3) // Light orange
                                            else -> Color(0xFFF5F5F5) // Light grey
                                        }
                                    
                                        Card(
                                            modifier = Modifier
                                                .fillMaxWidth()
                                                .padding(horizontal = 16.dp, vertical = 8.dp)
                                                .clickable {
                                                    navController.navigate("transactionDetails/${transaction.accountId}/${transaction.id}")
                                                },
                                            colors = CardDefaults.cardColors(
                                                containerColor = backgroundColor
                                            )
                                        ) {
                                            Column(
                                                modifier = Modifier
                                                    .fillMaxWidth()
                                                    .padding(16.dp)
                                            ) {
                                                Row(
                                                    modifier = Modifier.fillMaxWidth(),
                                                    verticalAlignment = Alignment.CenterVertically
                                                ) {
                                                    // Show an icon based on transaction type
                                                    Icon(
                                                        imageVector = if (transaction.transactionType == "Income") Icons.Default.KeyboardArrowUp
                                                        else Icons.Default.KeyboardArrowDown,
                                                        contentDescription = if (transaction.transactionType == "Income") "Income" else "Expense",
                                                        tint = if (transaction.transactionType == "Income") Color(0xFF2196F3) else Color(0xFFFF0000)
                                                    )
                                                    Spacer(modifier = Modifier.width(16.dp))
                                                    Column(modifier = Modifier.weight(1f)) {
                                                        Text(transaction.transactionName, fontWeight = FontWeight.Bold)
                                                        Text(
                                                            if (transaction.transactionType.equals("Income", ignoreCase = true)) "De" else "Para",
                                                            color = Color.Gray,
                                                            fontSize = 14.sp
                                                        )
                                                    }
                                                    Text(
                                                        formatCurrency(transaction.amount.toDouble()),
                                                        color = if (transaction.transactionType == "Income") Color(0xFF2196F3) else Color(0xFFFF0000),
                                                        fontWeight = FontWeight.Bold
                                                    )
                                                }
                                    
                                                // Anomaly indicators for location and amount
                                                Row(
                                                    modifier = Modifier
                                                        .fillMaxWidth()
                                                        .padding(top = 8.dp),
                                                    horizontalArrangement = Arrangement.spacedBy(16.dp)
                                                ) {
                                                    AnomalyIndicator(
                                                        label = "Ubicacin",
                                                        isAnomaly = transaction.locationAnomaly
                                                    )
                                                    AnomalyIndicator(
                                                        label = "Monto",
                                                        isAnomaly = transaction.amountAnomaly
                                                    )
                                                }
                                    
                                                // Location button to open maps if location is available
                                                if (transaction.location != null) {
                                                    Row(
                                                        verticalAlignment = Alignment.CenterVertically,
                                                        modifier = Modifier
                                                            .clickable {
                                                                val uri = Uri.parse("geo:${transaction.location.latitude},${transaction.location.longitude}?q=${transaction.location.latitude},${transaction.location.longitude}")
                                                                val intent = Intent(Intent.ACTION_VIEW, uri)
                                                                context.startActivity(intent)
                                                            }
                                                            .padding(top = 8.dp)
                                                    ) {
                                                        Icon(
                                                            Icons.Default.LocationOn,
                                                            contentDescription = "Location",
                                                            tint = Color.Gray,
                                                            modifier = Modifier.size(16.dp)
                                                        )
                                                        Spacer(modifier = Modifier.width(4.dp))
                                                        Text(
                                                            "Ver ubicacin",
                                                            color = Color.Gray,
                                                            fontSize = 12.sp
                                                        )
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    
                                    /**
                                     * AnomalyIndicator composable function
                                     *
                                     * Displays a visual indicator for transaction anomalies, such as location or amount anomalies.
                                     *
                                     * @param label String to display next to the anomaly indicator.
                                     * @param isAnomaly Boolean indicating whether the anomaly exists.
                                     */
                                    @Composable
                                    private fun AnomalyIndicator(
                                        label: String,
                                        isAnomaly: Boolean
                                    ) {
                                        Row(
                                            verticalAlignment = Alignment.CenterVertically,
                                            horizontalArrangement = Arrangement.Start
                                        ) {
                                            Box(
                                                modifier = Modifier
                                                    .size(8.dp)
                                                    .background(
                                                        color = if (isAnomaly) Color(0xFFFF0000) else Color(0xFF4CAF50),
                                                        shape = CircleShape
                                                    )
                                            )
                                            Spacer(modifier = Modifier.width(4.dp))
                                            Text(
                                                text = label,
                                                fontSize = 12.sp,
                                                color = Color.Gray
                                            )
                                        }
                                    }
                                    
                                    // Utility functions for date and currency formatting
                                    
                                    private fun normalizeDate(date: Date): Date {
                                        val calendar = Calendar.getInstance()
                                        calendar.time = date
                                        calendar.set(Calendar.HOUR_OF_DAY, 0)
                                        calendar.set(Calendar.MINUTE, 0)
                                        calendar.set(Calendar.SECOND, 0)
                                        calendar.set(Calendar.MILLISECOND, 0)
                                        return calendar.time
                                    }
                                    
                                    private fun formatDate(date: Date): String {
                                        val calendar = Calendar.getInstance()
                                        calendar.time = date
                                    
                                        val today = Calendar.getInstance()
                                        today.set(Calendar.HOUR_OF_DAY, 0)
                                        today.set(Calendar.MINUTE, 0)
                                        today.set(Calendar.SECOND, 0)
                                        today.set(Calendar.MILLISECOND, 0)
                                    
                                        val yesterday = Calendar.getInstance()
                                        yesterday.add(Calendar.DAY_OF_YEAR, -1)
                                        yesterday.set(Calendar.HOUR_OF_DAY, 0)
                                        yesterday.set(Calendar.MINUTE, 0)
                                        yesterday.set(Calendar.SECOND, 0)
                                        yesterday.set(Calendar.MILLISECOND, 0)
                                    
                                        return when {
                                            calendar.time == today.time -> "Hoy"
                                            calendar.time == yesterday.time -> "Ayer"
                                            else -> {
                                                val formatter = SimpleDateFormat("d 'de' MMMM 'de' yyyy", Locale("es", "ES"))
                                                formatter.format(date)
                                            }
                                        }
                                    }
                                    
                                    private fun formatCurrency(amount: Double): String {
                                        val format = NumberFormat.getCurrencyInstance(Locale("es", "CO"))
                                        return format.format(amount)
                                    }
                                    ```
                                - TransactionDetailsScreen.kt
                                    ```
                                    package com.isis3510.spendiq.views.accounts
                                    
                                    import android.app.DatePickerDialog
                                    import android.util.Log
                                    import androidx.compose.foundation.background
                                    import androidx.compose.foundation.layout.*
                                    import androidx.compose.foundation.rememberScrollState
                                    import androidx.compose.foundation.text.KeyboardOptions
                                    import androidx.compose.foundation.verticalScroll
                                    import androidx.compose.material.icons.Icons
                                    import androidx.compose.material.icons.automirrored.filled.ArrowBack
                                    import androidx.compose.material.icons.filled.Delete
                                    import androidx.compose.material.icons.filled.LocationOn
                                    import androidx.compose.material3.*
                                    import androidx.compose.runtime.*
                                    import androidx.compose.ui.Alignment
                                    import androidx.compose.ui.Modifier
                                    import androidx.compose.ui.graphics.Color
                                    import androidx.compose.ui.platform.LocalContext
                                    import androidx.compose.ui.text.font.FontWeight
                                    import androidx.compose.ui.text.input.KeyboardType
                                    import androidx.compose.ui.unit.dp
                                    import androidx.navigation.NavController
                                    import com.google.android.gms.maps.model.CameraPosition
                                    import com.google.android.gms.maps.model.LatLng
                                    import com.google.firebase.Timestamp
                                    import com.google.maps.android.compose.*
                                    import com.isis3510.spendiq.model.data.Location
                                    import com.isis3510.spendiq.model.data.Transaction
                                    import com.isis3510.spendiq.viewmodel.AccountViewModel
                                    import com.isis3510.spendiq.viewmodel.TransactionViewModel
                                    import kotlinx.coroutines.delay
                                    import kotlinx.coroutines.launch
                                    import java.util.*
                                    
                                    /**
                                     * TransactionDetailsScreen composable function
                                     *
                                     * Displays the details of a specific transaction and allows the user to edit or delete it. The screen
                                     * includes fields for transaction name, amount, type, date, and location (optional). A Google Map
                                     * view is provided for users to select or update the transaction location, enhancing geolocation data
                                     * for financial tracking.
                                     *
                                     * Key Features:
                                     * - Transaction Editing: Allows modification of transaction details, including the name, amount,
                                     *   type (income/expense), date, and location.
                                     * - Location Management:
                                     *   - Optional location tracking with Google Maps integration.
                                     *   - Allows enabling or disabling of location tracking.
                                     *   - Interactive map to select or change location.
                                     * - Delete Confirmation: A dialog to confirm deletion of the transaction.
                                     * - Snackbar Feedback: Provides success or error messages for save and delete actions.
                                     *
                                     * UI Structure:
                                     * - Scaffold with a TopAppBar for navigation and actions.
                                     * - Scrollable Column layout containing:
                                     *   - Editable fields for transaction details.
                                     *   - Location options and map view.
                                     *   - Save button to apply changes and delete button in the app bar for deletion.
                                     *
                                     * Supporting Components:
                                     * - `DatePickerDialog` for selecting a transaction date.
                                     * - `AlertDialog` for confirming transaction deletion.
                                     * - Google Maps integration to view and modify the location.
                                     *
                                     * @param navController [NavController] to handle navigation.
                                     * @param accountViewModel [AccountViewModel] to manage account-related data.
                                     * @param transactionViewModel [TransactionViewModel] to handle transaction data.
                                     * @param accountId The ID of the account associated with the transaction.
                                     * @param transactionId The ID of the transaction being viewed or edited.
                                     */
                                    @OptIn(ExperimentalMaterial3Api::class)
                                    @Composable
                                    fun TransactionDetailsScreen(
                                        navController: NavController,
                                        accountViewModel: AccountViewModel,
                                        transactionViewModel: TransactionViewModel,
                                        accountId: String,
                                        transactionId: String
                                    ) {
                                        // Context and CoroutineScope
                                        val context = LocalContext.current
                                        val coroutineScope = rememberCoroutineScope()
                                        val snackbarHostState = remember { SnackbarHostState() }
                                    
                                        // UI States and Variables
                                        val transaction by transactionViewModel.selectedTransaction.collectAsState()
                                        val uiState by transactionViewModel.uiState.collectAsState()
                                        var transactionName by remember { mutableStateOf("") }
                                        var amount by remember { mutableStateOf("") }
                                        var transactionType by remember { mutableStateOf("") }
                                        var selectedDate by remember { mutableStateOf<Timestamp?>(null) }
                                        var isLocationEnabled by remember { mutableStateOf(false) }
                                        var location by remember { mutableStateOf<Location?>(null) }
                                        var showDeleteConfirmation by remember { mutableStateOf(false) }
                                        var expandedTransactionType by remember { mutableStateOf(false) }
                                    
                                        // Google Map Configuration
                                        val defaultLocation = LatLng(4.6097100, -74.0817500) // Default to Bogota
                                        var mapPosition by remember { mutableStateOf(defaultLocation) }
                                        val cameraPositionState = rememberCameraPositionState {
                                            position = CameraPosition.fromLatLngZoom(defaultLocation, 15f)
                                        }
                                    
                                        var isNavigating by remember { mutableStateOf(false) }
                                    
                                        // Load Transaction Data on Screen Start
                                        LaunchedEffect(Unit) {
                                            transactionViewModel.getTransaction(accountId, transactionId)
                                        }
                                    
                                        // Handle UI State
                                        LaunchedEffect(uiState) {
                                            if (uiState is TransactionViewModel.UiState.Error) {
                                                snackbarHostState.showSnackbar((uiState as TransactionViewModel.UiState.Error).message)
                                            }
                                        }
                                    
                                        // Update Local State when Transaction Loads
                                        LaunchedEffect(transaction) {
                                            transaction?.let {
                                                transactionName = it.transactionName
                                                amount = it.amount.toString()
                                                transactionType = it.transactionType
                                                selectedDate = it.dateTime
                                                location = it.location
                                                isLocationEnabled = it.location != null
                                                location?.let { loc ->
                                                    mapPosition = LatLng(loc.latitude, loc.longitude)
                                                    cameraPositionState.position = CameraPosition.fromLatLngZoom(
                                                        LatLng(loc.latitude, loc.longitude), 15f
                                                    )
                                                }
                                            }
                                        }
                                    
                                        // DatePickerDialog for Selecting Transaction Date
                                        val datePickerDialog = DatePickerDialog(
                                            context,
                                            { _, year, month, dayOfMonth ->
                                                val calendar = Calendar.getInstance()
                                                calendar.set(year, month, dayOfMonth)
                                                selectedDate = Timestamp(calendar.time)
                                            },
                                            Calendar.getInstance().get(Calendar.YEAR),
                                            Calendar.getInstance().get(Calendar.MONTH),
                                            Calendar.getInstance().get(Calendar.DAY_OF_MONTH)
                                        )
                                    
                                        // Main Scaffold Layout
                                        Scaffold(
                                            topBar = {
                                                TopAppBar(
                                                    title = { Text("Edit Transaction") },
                                                    navigationIcon = {
                                                        IconButton(onClick = {
                                                            if (!isNavigating) {
                                                                isNavigating = true
                                                                coroutineScope.launch {
                                                                    navController.popBackStack()
                                                                    delay(300)
                                                                    isNavigating = false
                                                                }
                                                            }
                                                        }) {
                                                            Icon(Icons.AutoMirrored.Filled.ArrowBack, "Back")
                                                        }
                                                    },
                                                    actions = {
                                                        IconButton(
                                                            onClick = { showDeleteConfirmation = true },
                                                            enabled = transaction != null
                                                        ) {
                                                            Icon(Icons.Default.Delete, "Delete")
                                                        }
                                                    }
                                                )
                                            },
                                            snackbarHost = { SnackbarHost(snackbarHostState) }
                                        ) { padding ->
                                            Column(
                                                modifier = Modifier
                                                    .fillMaxSize()
                                                    .padding(padding)
                                                    .padding(16.dp)
                                                    .verticalScroll(rememberScrollState())
                                            ) {
                                                if (uiState is TransactionViewModel.UiState.Loading) {
                                                    CircularProgressIndicator(modifier = Modifier.align(Alignment.CenterHorizontally))
                                                } else if (transaction == null) {
                                                    Text(
                                                        text = "Transaction not found",
                                                        color = MaterialTheme.colorScheme.error,
                                                        modifier = Modifier.align(Alignment.CenterHorizontally)
                                                    )
                                                } else {
                                                    // Transaction Name Input
                                                    OutlinedTextField(
                                                        value = transactionName,
                                                        onValueChange = { transactionName = it },
                                                        label = { Text("Transaction Name") },
                                                        modifier = Modifier.fillMaxWidth()
                                                    )
                                    
                                                    Spacer(modifier = Modifier.height(16.dp))
                                    
                                                    // Amount Input Field
                                                    OutlinedTextField(
                                                        value = amount,
                                                        onValueChange = {
                                                            amount = it.filter { char -> char.isDigit() || char == '.' }
                                                        },
                                                        label = { Text("Amount") },
                                                        modifier = Modifier.fillMaxWidth(),
                                                        keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number)
                                                    )
                                    
                                                    Spacer(modifier = Modifier.height(16.dp))
                                    
                                                    // Transaction Type Dropdown Menu
                                                    ExposedDropdownMenuBox(
                                                        expanded = expandedTransactionType,
                                                        onExpandedChange = { expandedTransactionType = !expandedTransactionType }
                                                    ) {
                                                        TextField(
                                                            value = transactionType,
                                                            onValueChange = { },
                                                            readOnly = true,
                                                            label = { Text("Type") },
                                                            trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expandedTransactionType) },
                                                            modifier = Modifier.menuAnchor().fillMaxWidth()
                                                        )
                                                        ExposedDropdownMenu(
                                                            expanded = expandedTransactionType,
                                                            onDismissRequest = { expandedTransactionType = false }
                                                        ) {
                                                            DropdownMenuItem(
                                                                text = { Text("Income") },
                                                                onClick = {
                                                                    transactionType = "Income"
                                                                    expandedTransactionType = false
                                                                }
                                                            )
                                                            DropdownMenuItem(
                                                                text = { Text("Expense") },
                                                                onClick = {
                                                                    transactionType = "Expense"
                                                                    expandedTransactionType = false
                                                                }
                                                            )
                                                        }
                                                    }
                                    
                                                    Spacer(modifier = Modifier.height(16.dp))
                                    
                                                    // Date Selector Button
                                                    OutlinedButton(
                                                        onClick = { datePickerDialog.show() },
                                                        modifier = Modifier.fillMaxWidth()
                                                    ) {
                                                        Text(selectedDate?.toDate()?.toString() ?: "Select Date")
                                                    }
                                    
                                                    Spacer(modifier = Modifier.height(16.dp))
                                    
                                                    // Location Toggle with Map Display
                                                    Row(
                                                        modifier = Modifier.fillMaxWidth(),
                                                        verticalAlignment = Alignment.CenterVertically
                                                    ) {
                                                        Icon(
                                                            Icons.Default.LocationOn,
                                                            contentDescription = "Location",
                                                            tint = if (isLocationEnabled) MaterialTheme.colorScheme.primary else Color.Gray
                                                        )
                                                        Spacer(modifier = Modifier.width(8.dp))
                                                        Text(
                                                            "Include Location",
                                                            style = MaterialTheme.typography.bodyLarge.copy(
                                                                fontWeight = FontWeight.Medium
                                                            )
                                                        )
                                                        Spacer(modifier = Modifier.weight(1f))
                                                        Switch(
                                                            checked = isLocationEnabled,
                                                            onCheckedChange = { enabled ->
                                                                isLocationEnabled = enabled
                                                                if (enabled && location == null) {
                                                                    location = Location(defaultLocation.latitude, defaultLocation.longitude)
                                                                    mapPosition = defaultLocation
                                                                }
                                                            }
                                                        )
                                                    }
                                    
                                                    Spacer(modifier = Modifier.height(16.dp))
                                    
                                                    // Google Map for Selecting Location
                                                    Box(
                                                        modifier = Modifier
                                                            .fillMaxWidth()
                                                            .height(300.dp)
                                                    ) {
                                                        GoogleMap(
                                                            modifier = Modifier.fillMaxSize(),
                                                            cameraPositionState = cameraPositionState,
                                                            properties = MapProperties(isMyLocationEnabled = false),
                                                            onMapClick = { latLng ->
                                                                if (isLocationEnabled) {
                                                                    mapPosition = latLng
                                                                    location = Location(latLng.latitude, latLng.longitude)
                                                                }
                                                            }
                                                        ) {
                                                            if (location != null) {
                                                                Marker(
                                                                    state = MarkerState(position = mapPosition),
                                                                    title = "Transaction Location"
                                                                )
                                                            }
                                                        }
                                    
                                                        // Overlay if Location Disabled
                                                        if (!isLocationEnabled) {
                                                            Box(
                                                                modifier = Modifier
                                                                    .fillMaxSize()
                                                                    .background(MaterialTheme.colorScheme.surface.copy(alpha = 0.7f)),
                                                                contentAlignment = Alignment.Center
                                                            ) {
                                                                Text(
                                                                    "Location Disabled",
                                                                    style = MaterialTheme.typography.titleMedium,
                                                                    color = MaterialTheme.colorScheme.onSurface
                                                                )
                                                            }
                                                        }
                                                    }
                                    
                                                    Spacer(modifier = Modifier.height(24.dp))
                                    
                                                    // Save Changes Button
                                                    Button(
                                                        onClick = {
                                                            transaction?.let { currentTransaction ->
                                                                val updatedTransaction = Transaction(
                                                                    id = currentTransaction.id,
                                                                    accountId = currentTransaction.accountId,
                                                                    transactionName = transactionName,
                                                                    amount = (amount.toDoubleOrNull() ?: 0.0).toLong(),
                                                                    dateTime = selectedDate ?: Timestamp.now(),
                                                                    transactionType = transactionType,
                                                                    location = if (isLocationEnabled) location else null
                                                                )
                                                                coroutineScope.launch {
                                                                    try {
                                                                        transactionViewModel.updateTransaction(
                                                                            currentTransaction.accountId,
                                                                            currentTransaction,
                                                                            updatedTransaction
                                                                        )
                                                                        snackbarHostState.showSnackbar("Transaction updated successfully")
                                                                        navController.popBackStack()
                                                                    } catch (e: Exception) {
                                                                        snackbarHostState.showSnackbar("Failed to update transaction: ${e.message}")
                                                                        Log.e("TransactionUpdate", "Error updating transaction", e)
                                                                    }
                                                                }
                                                            }
                                                        },
                                                        modifier = Modifier.fillMaxWidth(),
                                                        enabled = transaction != null
                                                    ) {
                                                        Text("Save Changes")
                                                    }
                                                }
                                            }
                                    
                                            // Delete Confirmation Dialog
                                            if (showDeleteConfirmation) {
                                                AlertDialog(
                                                    onDismissRequest = { showDeleteConfirmation = false },
                                                    title = { Text("Delete Transaction") },
                                                    text = { Text("Are you sure you want to delete this transaction? This action cannot be undone.") },
                                                    confirmButton = {
                                                        Button(
                                                            onClick = {
                                                                transaction?.let {
                                                                    coroutineScope.launch {
                                                                        try {
                                                                            transactionViewModel.deleteTransaction(accountId, it)
                                                                            snackbarHostState.showSnackbar("Transaction deleted successfully")
                                                                            navController.popBackStack()
                                                                        } catch (e: Exception) {
                                                                            snackbarHostState.showSnackbar("Failed to delete transaction: ${e.message}")
                                                                            Log.e("TransactionDelete", "Error deleting transaction", e)
                                                                        }
                                                                    }
                                                                    showDeleteConfirmation = false
                                                                }
                                                            },
                                                            colors = ButtonDefaults.buttonColors(
                                                                containerColor = MaterialTheme.colorScheme.error
                                                            )
                                                        ) {
                                                            Text("Delete")
                                                        }
                                                    },
                                                    dismissButton = {
                                                        TextButton(onClick = { showDeleteConfirmation = false }) {
                                                            Text("Cancel")
                                                        }
                                                    }
                                                )
                                            }
                                        }
                                    }
                                    ```
                                - AccountsScreen.kt
                                    ```
                                    package com.isis3510.spendiq.views.accounts
                                    
                                    import androidx.compose.foundation.background
                                    import androidx.compose.foundation.clickable
                                    import androidx.compose.foundation.layout.*
                                    import androidx.compose.foundation.lazy.LazyColumn
                                    import androidx.compose.foundation.lazy.items
                                    import androidx.compose.material3.*
                                    import androidx.compose.runtime.*
                                    import androidx.compose.ui.Alignment
                                    import androidx.compose.ui.Modifier
                                    import androidx.compose.ui.graphics.Color
                                    import androidx.compose.ui.text.font.FontWeight
                                    import androidx.compose.ui.unit.dp
                                    import androidx.compose.ui.unit.sp
                                    import androidx.navigation.NavController
                                    import com.isis3510.spendiq.model.data.Account
                                    import com.isis3510.spendiq.views.common.BottomNavigation
                                    import com.isis3510.spendiq.views.transaction.AddTransactionModal
                                    import com.isis3510.spendiq.viewmodel.AccountViewModel
                                    import com.isis3510.spendiq.viewmodel.TransactionViewModel
                                    
                                    /**
                                     * AccountsScreen composable function
                                     *
                                     * Displays a list of user accounts and provides functionality to edit or delete accounts.
                                     * Users can view their existing accounts, create new ones, or delete existing ones.
                                     * The screen also includes navigation to transaction details for each account.
                                     *
                                     * Key Features:
                                     * - Account Listing: Displays the current accounts with details such as account name, type, and balance.
                                     * - Search Functionality: Allows users to search for specific accounts.
                                     * - Modal Dialogs: Provides interfaces for creating and deleting accounts.
                                     * - Integration with ViewModel: Fetches account data and manages UI state through the provided ViewModel.
                                     *
                                     * UI Structure:
                                     * - Scaffold with a BottomNavigation for navigation between sections of the app.
                                     * - LazyColumn for displaying a list of accounts.
                                     * - Buttons for editing accounts and adding transactions.
                                     * - Modal dialog for editing accounts with options for creation and deletion.
                                     *
                                     * Supporting Components:
                                     * - `AccountItem`: A composable for displaying individual account details.
                                     * - `EditAccountModal`: A composable modal for managing account editing, including creation and deletion.
                                     *
                                     * @param navController [NavController] to navigate between screens.
                                     * @param accountViewModel [AccountViewModel] for managing account-related data.
                                     * @param transactionViewModel [TransactionViewModel] for managing transactions.
                                     */
                                    @Composable
                                    fun AccountsScreen(
                                        navController: NavController,
                                        accountViewModel: AccountViewModel,
                                        transactionViewModel: TransactionViewModel
                                    ) {
                                        // Collects accounts and UI state from the AccountViewModel
                                        val accounts by accountViewModel.accounts.collectAsState()
                                        val uiState by accountViewModel.uiState.collectAsState()
                                    
                                        // State variables to manage modal visibility
                                        var showEditModal by remember { mutableStateOf(false) }
                                        var showAddTransactionModal by remember { mutableStateOf(false) }
                                    
                                        // Fetch accounts when the screen is loaded
                                        LaunchedEffect(Unit) {
                                            accountViewModel.fetchAccounts()
                                        }
                                    
                                        // Scaffold layout with bottom navigation
                                        Scaffold(
                                            bottomBar = {
                                                BottomNavigation(
                                                    navController = navController,
                                                    transactionViewModel = transactionViewModel,
                                                    accountViewModel = accountViewModel
                                                )
                                            }
                                        ) { innerPadding ->
                                            // Column layout for the main content
                                            Column(
                                                modifier = Modifier
                                                    .fillMaxSize()
                                                    .padding(innerPadding)
                                                    .padding(16.dp)
                                            ) {
                                                Text(
                                                    "Accounts",
                                                    fontSize = 24.sp,
                                                    fontWeight = FontWeight.Bold
                                                )
                                                Text(
                                                    "These are your current accounts",
                                                    fontSize = 14.sp,
                                                    color = Color.Gray
                                                )
                                                Spacer(modifier = Modifier.height(16.dp))
                                    
                                                // Display loading indicator or accounts based on the UI state
                                                when (uiState) {
                                                    is AccountViewModel.UiState.Loading -> {
                                                        CircularProgressIndicator(modifier = Modifier.align(Alignment.CenterHorizontally))
                                                    }
                                                    is AccountViewModel.UiState.Success -> {
                                                        LazyColumn(
                                                            verticalArrangement = Arrangement.spacedBy(8.dp)
                                                        ) {
                                                            items(accounts) { account ->
                                                                AccountItem(account, navController)
                                                            }
                                                        }
                                                    }
                                                    is AccountViewModel.UiState.Error -> {
                                                        Text(
                                                            text = (uiState as AccountViewModel.UiState.Error).message,
                                                            color = Color.Red
                                                        )
                                                    }
                                                    else -> {} // Idle state, do nothing
                                                }
                                    
                                                Spacer(modifier = Modifier.height(16.dp))
                                                Button(
                                                    onClick = { showEditModal = true },
                                                    modifier = Modifier.fillMaxWidth()
                                                ) {
                                                    Text("Edit Accounts")
                                                }
                                            }
                                        }
                                    
                                        // Show Edit Account Modal when requested
                                        if (showEditModal) {
                                            EditAccountModal(
                                                existingAccounts = accounts,
                                                onDismiss = { showEditModal = false },
                                                onCreateAccount = { accountType ->
                                                    accountViewModel.createAccount(accountType)
                                                },
                                                onDeleteAccount = { accountType ->
                                                    accountViewModel.deleteAccount(accountType)
                                                }
                                            )
                                        }
                                    
                                        // Show Add Transaction Modal when requested
                                        if (showAddTransactionModal) {
                                            AddTransactionModal(
                                                accountViewModel = accountViewModel,
                                                transactionViewModel = transactionViewModel,
                                                onDismiss = { showAddTransactionModal = false },
                                                onTransactionAdded = {
                                                    showAddTransactionModal = false
                                                    accountViewModel.fetchAccounts()
                                                }
                                            )
                                        }
                                    }
                                    
                                    /**
                                     * AccountItem composable function
                                     *
                                     * Displays the details of an individual account, including its name, type, and balance.
                                     * Users can click on the item to navigate to a detailed view of transactions related to that account.
                                     *
                                     * @param account [Account] the account data to display.
                                     * @param navController [NavController] to navigate to transaction details for the account.
                                     */
                                    @Composable
                                    fun AccountItem(account: Account, navController: NavController) {
                                        Card(
                                            modifier = Modifier
                                                .fillMaxWidth()
                                                .padding(vertical = 8.dp)
                                                .clickable { navController.navigate("accountTransactions/${account.name}") }
                                        ) {
                                            Box(
                                                modifier = Modifier
                                                    .fillMaxWidth()
                                                    .height(80.dp)
                                                    .background(account.color)
                                                    .padding(16.dp)
                                            ) {
                                                Column {
                                                    Text(
                                                        text = account.name,
                                                        color = Color.White,
                                                        fontWeight = FontWeight.Bold
                                                    )
                                                    Text(
                                                        text = account.type,
                                                        color = Color.White.copy(alpha = 0.7f)
                                                    )
                                                }
                                                Text(
                                                    text = "$ ${account.amount}",
                                                    color = Color.White,
                                                    fontWeight = FontWeight.Bold,
                                                    modifier = Modifier.align(Alignment.CenterEnd)
                                                )
                                            }
                                        }
                                    }
                                    
                                    /**
                                     * EditAccountModal composable function
                                     *
                                     * Provides a modal dialog for editing existing accounts or creating new ones.
                                     * Allows users to select account types and choose to delete existing accounts.
                                     *
                                     * @param existingAccounts List of [Account] currently available.
                                     * @param onDismiss Function to call when the modal is dismissed.
                                     * @param onCreateAccount Function to call to create a new account.
                                     * @param onDeleteAccount Function to call to delete an existing account.
                                     */
                                    @OptIn(ExperimentalMaterial3Api::class)
                                    @Composable
                                    fun EditAccountModal(
                                        existingAccounts: List<Account>,
                                        onDismiss: () -> Unit,
                                        onCreateAccount: (String) -> Unit,
                                        onDeleteAccount: (String) -> Unit
                                    ) {
                                        var selectedAccountType by remember { mutableStateOf("") }
                                        var selectedAction by remember { mutableStateOf("") }
                                        var expandedAccountType by remember { mutableStateOf(false) }
                                        var expandedAction by remember { mutableStateOf(false) }
                                        var showDeleteConfirmation by remember { mutableStateOf(false) }
                                    
                                        // Filter available account types
                                        val availableAccountTypes = listOf("Nu", "Bancolombia", "Nequi")
                                            .filter { accountType -> existingAccounts.none { it.name == accountType } }
                                    
                                        // Define actions based on available account types
                                        val actions = if (availableAccountTypes.isEmpty()) listOf("Delete") else listOf("Create", "Delete")
                                    
                                        ModalBottomSheet(onDismissRequest = onDismiss) {
                                            Column(
                                                modifier = Modifier
                                                    .fillMaxWidth()
                                                    .padding(16.dp)
                                            ) {
                                                Text("Edit Accounts", style = MaterialTheme.typography.headlineSmall)
                                                Spacer(modifier = Modifier.height(16.dp))
                                    
                                                // Dropdown for selecting action (Create/Delete)
                                                ExposedDropdownMenuBox(
                                                    expanded = expandedAction,
                                                    onExpandedChange = { expandedAction = !expandedAction }
                                                ) {
                                                    TextField(
                                                        value = selectedAction,
                                                        onValueChange = {},
                                                        readOnly = true,
                                                        label = { Text("Action") },
                                                        trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = expandedAction) },
                                                        modifier = Modifier.menuAnchor().fillMaxWidth()
                                                    )
                                                    ExposedDropdownMenu(
                                                        expanded = expandedAction,
                                                        onDismissRequest = { expandedAction = false }
                                                    ) {
                                                        actions.forEach { action ->
                                                            DropdownMenuItem(
                                                                text = { Text(action) },
                                                                onClick = {
                                                                    selectedAction = action
                                                                    expandedAction = false
                                                                    selectedAccountType = ""
                                                                }
                                                            )
                                                        }
                                                    }
                                                }
                                    
                                                Spacer(modifier = Modifier.height(8.dp))
                                    
                                                // Dropdown for selecting account type based on the selected action
                                                if (selectedAction.isNotEmpty()) {
                                                    val applicableAccountTypes = if (selectedAction == "Create") availableAccountTypes else existingAccounts.map { it.name }
                                    
                                                    ExposedDropdownMenuBox(
                                                        expanded = expandedAccountType,
                                                        onExpandedChange = { expandedAccountType = !expandedAccountType }
                                                    ) {
                                                        TextField(
                                                            value = selectedAccountType,
                                                            onValueChange = {},
                                                            readOnly = true,
                                                            label = { Text("Account Type") },
                                                            trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = expandedAccountType) },
                                                            modifier = Modifier.menuAnchor().fillMaxWidth()
                                                        )
                                                        ExposedDropdownMenu(
                                                            expanded = expandedAccountType,
                                                            onDismissRequest = { expandedAccountType = false }
                                                        ) {
                                                            applicableAccountTypes.forEach { accountType ->
                                                                DropdownMenuItem(
                                                                    text = { Text(accountType) },
                                                                    onClick = {
                                                                        selectedAccountType = accountType
                                                                        expandedAccountType = false
                                                                    }
                                                                )
                                                            }
                                                        }
                                                    }
                                                }
                                    
                                                Spacer(modifier = Modifier.height(16.dp))
                                    
                                                // Button to confirm the selected action
                                                Button(
                                                    onClick = {
                                                        if (selectedAction == "Delete") {
                                                            showDeleteConfirmation = true
                                                        } else {
                                                            onCreateAccount(selectedAccountType)
                                                            onDismiss()
                                                        }
                                                    },
                                                    enabled = selectedAccountType.isNotEmpty(),
                                                    modifier = Modifier.fillMaxWidth()
                                                ) {
                                                    Text(selectedAction)
                                                }
                                            }
                                        }
                                    
                                        // Confirmation dialog for account deletion
                                        if (showDeleteConfirmation) {
                                            AlertDialog(
                                                onDismissRequest = { showDeleteConfirmation = false },
                                                title = { Text("Delete Account") },
                                                text = { Text("Are you sure you want to delete the account?") },
                                                confirmButton = {
                                                    TextButton(
                                                        onClick = {
                                                            onDeleteAccount(selectedAccountType)
                                                            showDeleteConfirmation = false
                                                            onDismiss()
                                                        }
                                                    ) {
                                                        Text("Yes")
                                                    }
                                                },
                                                dismissButton = {
                                                    TextButton(
                                                        onClick = { showDeleteConfirmation = false }
                                                    ) {
                                                        Text("No")
                                                    }
                                                }
                                            )
                                        }
                                    }
                                    ```
                            - **theme/**
                                - Color.kt
                                    ```
                                    package com.isis3510.spendiq.views.theme
                                    
                                    import androidx.compose.ui.graphics.Color
                                    
                                    val Purple80 = Color(0xFFD0BCFF)
                                    val PurpleGrey80 = Color(0xFFCCC2DC)
                                    val Pink80 = Color(0xFFEFB8C8)
                                    
                                    val Purple40 = Color(0xFF6650a4)
                                    val PurpleGrey40 = Color(0xFF625b71)
                                    val Pink40 = Color(0xFF7D5260)                                    ```
                                - Theme.kt
                                    ```
                                    package com.isis3510.spendiq.views.theme
                                    
                                    import android.os.Build
                                    import androidx.compose.foundation.isSystemInDarkTheme
                                    import androidx.compose.material3.MaterialTheme
                                    import androidx.compose.material3.darkColorScheme
                                    import androidx.compose.material3.dynamicDarkColorScheme
                                    import androidx.compose.material3.dynamicLightColorScheme
                                    import androidx.compose.material3.lightColorScheme
                                    import androidx.compose.runtime.Composable
                                    import androidx.compose.ui.graphics.Color
                                    import androidx.compose.ui.platform.LocalContext
                                    
                                    private val DarkColorScheme = darkColorScheme(
                                        primary = Purple80,
                                        onPrimary = Color.White, // Blanco para texto en modo oscuro
                                        secondary = PurpleGrey80,
                                        tertiary = Pink80
                                    )
                                    
                                    private val LightColorScheme = lightColorScheme(
                                        primary = Purple40,
                                        onPrimary = Color.Black, // Negro para texto en modo claro
                                        secondary = PurpleGrey40,
                                        tertiary = Pink40
                                    
                                        /* Otros colores predeterminados para sobreescribir
                                        background = Color(0xFFFFFBFE),
                                        surface = Color(0xFFFFFBFE),
                                        onSecondary = Color.White,
                                        onTertiary = Color.White,
                                        onBackground = Color(0xFF1C1B1F),
                                        onSurface = Color(0xFF1C1B1F),
                                        */
                                    )
                                    
                                    @Composable
                                    fun SpendiQTheme(
                                        darkTheme: Boolean = isSystemInDarkTheme(),
                                        // Dynamic color is available on Android 12+
                                        dynamicColor: Boolean = true,
                                        content: @Composable () -> Unit
                                    ) {
                                        val context = LocalContext.current
                                        val baseColorScheme = when {
                                            dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
                                                if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
                                            }
                                            darkTheme -> DarkColorScheme
                                            else -> LightColorScheme
                                        }
                                    
                                        // Sobrescribir onPrimary despus de aplicar Dynamic Color
                                        val colorScheme = baseColorScheme.copy(
                                            onPrimary = if (darkTheme) Color.White else Color.Black
                                        )
                                    
                                        MaterialTheme(
                                            colorScheme = colorScheme,
                                            typography = Typography,
                                            content = content
                                        )
                                    }
                                    ```
                                - Type.kt
                                    ```
                                    package com.isis3510.spendiq.views.theme
                                    
                                    import androidx.compose.material3.Typography
                                    import androidx.compose.ui.text.TextStyle
                                    import androidx.compose.ui.text.font.FontFamily
                                    import androidx.compose.ui.text.font.FontWeight
                                    import androidx.compose.ui.unit.sp
                                    
                                    // Set of Material typography styles to start with
                                    val Typography = Typography(
                                        bodyLarge = TextStyle(
                                            fontFamily = FontFamily.Default,
                                            fontWeight = FontWeight.Normal,
                                            fontSize = 16.sp,
                                            lineHeight = 24.sp,
                                            letterSpacing = 0.5.sp
                                        )
                                        /* Other default text styles to override
                                        titleLarge = TextStyle(
                                            fontFamily = FontFamily.Default,
                                            fontWeight = FontWeight.Normal,
                                            fontSize = 22.sp,
                                            lineHeight = 28.sp,
                                            letterSpacing = 0.sp
                                        ),
                                        labelSmall = TextStyle(
                                            fontFamily = FontFamily.Default,
                                            fontWeight = FontWeight.Medium,
                                            fontSize = 11.sp,
                                            lineHeight = 16.sp,
                                            letterSpacing = 0.5.sp
                                        )
                                        */
                                    )                                    ```
                            - **main/**
                                - MainContent.kt
                                    ```
                                        package com.isis3510.spendiq.views.main
                                    
                                    import android.os.Build
                                    import androidx.annotation.RequiresApi
                                    import androidx.compose.animation.core.EaseInOutCubic
                                    import androidx.compose.animation.core.tween
                                    import androidx.compose.foundation.Image
                                    import androidx.compose.foundation.clickable
                                    import androidx.compose.foundation.layout.*
                                    import androidx.compose.foundation.lazy.LazyColumn
                                    import androidx.compose.foundation.lazy.items
                                    import androidx.compose.foundation.text.KeyboardOptions
                                    import androidx.compose.material.icons.Icons
                                    import androidx.compose.material.icons.filled.KeyboardArrowDown
                                    import androidx.compose.material.icons.filled.KeyboardArrowUp
                                    import androidx.compose.material3.*
                                    import androidx.compose.runtime.*
                                    import androidx.compose.ui.Alignment
                                    import androidx.compose.ui.Modifier
                                    import androidx.compose.ui.graphics.Color
                                    import androidx.compose.ui.graphics.SolidColor
                                    import androidx.compose.ui.platform.LocalContext
                                    import androidx.compose.ui.res.painterResource
                                    import androidx.compose.ui.text.font.FontWeight
                                    import androidx.compose.ui.text.input.KeyboardType
                                    import androidx.compose.ui.unit.dp
                                    import androidx.compose.ui.unit.sp
                                    import androidx.navigation.NavController
                                    import coil.compose.rememberImagePainter
                                    import com.isis3510.spendiq.model.data.Account
                                    import com.isis3510.spendiq.model.data.Transaction
                                    import com.isis3510.spendiq.model.data.Offer
                                    import com.isis3510.spendiq.views.common.BottomNavigation
                                    import com.isis3510.spendiq.viewmodel.AccountViewModel
                                    import com.isis3510.spendiq.viewmodel.AuthViewModel
                                    import com.isis3510.spendiq.viewmodel.OffersViewModel
                                    import com.google.firebase.Timestamp
                                    import com.isis3510.spendiq.R
                                    import com.isis3510.spendiq.viewmodel.TransactionViewModel
                                    import com.isis3510.spendiq.views.common.CreatePieChart
                                    import ir.ehsannarmani.compose_charts.LineChart
                                    import ir.ehsannarmani.compose_charts.models.AnimationMode
                                    import ir.ehsannarmani.compose_charts.models.DotProperties
                                    import ir.ehsannarmani.compose_charts.models.DrawStyle
                                    import ir.ehsannarmani.compose_charts.models.LabelProperties
                                    import ir.ehsannarmani.compose_charts.models.Line
                                    import ir.ehsannarmani.compose_charts.models.ZeroLineProperties
                                    import java.text.SimpleDateFormat
                                    import java.util.*
                                    import java.text.NumberFormat
                                    
                                    
                                    @RequiresApi(Build.VERSION_CODES.O)
                                    @Composable
                                    fun MainContent(
                                        navController: NavController,
                                        authViewModel: AuthViewModel,
                                        accountViewModel: AccountViewModel,
                                        promoViewModel: OffersViewModel,
                                        transactionViewModel: TransactionViewModel,
                                    ) {
                                        val accounts by accountViewModel.accounts.collectAsState()
                                        val promos by promoViewModel.offers.collectAsState()
                                        val currentMoney by accountViewModel.currentMoney.collectAsState()
                                        var showAddTransactionModal by remember { mutableStateOf(false) }
                                        val uiState by transactionViewModel.uiState.collectAsState()
                                        val transactions by transactionViewModel.transactions.collectAsState()
                                        var isMoneyVisible by remember { mutableStateOf(true) }
                                        val (totalIncome, totalExpenses) = remember(transactions) {
                                            transactionViewModel.getIncomeAndExpenses()
                                        }
                                        val currencyFormatter = NumberFormat.getCurrencyInstance(Locale.getDefault())
                                    
                                        LaunchedEffect(Unit) {
                                            accountViewModel.fetchAccounts()
                                            promoViewModel.fetchOffers()
                                            transactionViewModel.fetchAllTransactions()
                                        }
                                    
                                    
                                        Scaffold(
                                            bottomBar = {
                                                BottomNavigation(
                                                    navController = navController,
                                                    transactionViewModel,
                                                    accountViewModel
                                                )
                                            }
                                        ) { innerPadding ->
                                            LazyColumn(
                                                modifier = Modifier
                                                    .fillMaxSize()
                                                    .padding(innerPadding)
                                                    .padding(16.dp),
                                                horizontalAlignment = Alignment.Start,
                                                verticalArrangement = Arrangement.Top
                                            ) {
                                                item {
                                                    Spacer(modifier = Modifier.height(24.dp))
                                    
                                                    Text(
                                                        text = SimpleDateFormat("EEE, d MMM", Locale.getDefault()).format(Date()),
                                                        style = MaterialTheme.typography.bodySmall.copy(fontSize = 14.sp)
                                                    )
                                                    Text(
                                                        text = "Summary",
                                                        style = MaterialTheme.typography.headlineMedium.copy(fontWeight = FontWeight.Medium)
                                                    )
                                                    Spacer(modifier = Modifier.height(1.dp))
                                                    Text(
                                                        text = "Take a look at your finances",
                                                        style = MaterialTheme.typography.bodyMedium.copy(fontSize = 18.sp)
                                                    )
                                    
                                                    Spacer(modifier = Modifier.height(30.dp))
                                    
                                                    Text(
                                                        text = "Current available money",
                                                        style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.Medium)
                                                    )
                                    
                                                    Row(
                                                        verticalAlignment = Alignment.CenterVertically,
                                                        horizontalArrangement = Arrangement.Start,
                                                        modifier = Modifier.padding(vertical = 8.dp)
                                                    ) {
                                                        Text(
                                                            text = if (isMoneyVisible) currencyFormatter.format(currentMoney) else "******",
                                                            style = MaterialTheme.typography.headlineLarge.copy(fontWeight = FontWeight.Bold)
                                                        )
                                                        Spacer(modifier = Modifier.width(16.dp))
                                                        IconButton(
                                                            onClick = { isMoneyVisible = !isMoneyVisible }
                                                        ) {
                                                            Icon(
                                                                painter = painterResource(id = if (isMoneyVisible) R.drawable.round_visibility_24 else R.drawable.baseline_visibility_off_24),
                                                                contentDescription = if (isMoneyVisible) "Hide money" else "Show money"
                                                            )
                                                        }
                                                    }
                                                    Spacer(modifier = Modifier.height(16.dp))
                                                }
                                    
                                                item {
                                                    Text(
                                                        text = "Accounts",
                                                        style = MaterialTheme.typography.headlineMedium.copy(fontWeight = FontWeight.Medium)
                                                    )
                                                    Spacer(modifier = Modifier.height(8.dp))
                                                }
                                    
                                                items(accounts) { account ->
                                                    AccountItem(account, navController)
                                                    Spacer(modifier = Modifier.height(8.dp))
                                                }
                                    
                                                item {
                                                    Spacer(modifier = Modifier.height(16.dp))
                                                    Text("User Balance Over Last 30 Days", style = MaterialTheme.typography.headlineMedium)
                                                    Spacer(modifier = Modifier.height(16.dp))
                                    
                                                    // Muestra un indicador de carga si la UI est en estado de carga
                                                    if (uiState is TransactionViewModel.UiState.Loading) {
                                                        CircularProgressIndicator()
                                                    } else {
                                                        if (totalIncome > 0 || totalExpenses > 0) {
                                                            val dailyTransactions = transactionViewModel.getIncomeAndExpensesLast30Days()
                                    
                                                            val movements = dailyTransactions.map { it.amount }
                                                            val moveLabels = dailyTransactions.map { it.day }
                                    
                                                            // Crear el grfico de lneas
                                                            LineChart(
                                                                modifier = Modifier
                                                                    .height(300.dp)
                                                                    .fillMaxSize().padding(horizontal = 22.dp),
                                                                data = remember {
                                                                    listOf(
                                                                        Line(
                                                                            label = "Movements",
                                                                            values = movements,
                                                                            color = SolidColor(Color(0xffb3cb54)),
                                                                            firstGradientFillColor = Color(0xFF94B719).copy(alpha = .5f),
                                                                            secondGradientFillColor = Color.Transparent,
                                                                            strokeAnimationSpec = tween(2000, easing = EaseInOutCubic),
                                                                            drawStyle = DrawStyle.Stroke(width = 2.dp),
                                                                            dotProperties = DotProperties(
                                                                                enabled = true,
                                                                                color = SolidColor(Color.White),
                                                                                strokeWidth = 2.dp,
                                                                                radius = 3.5.dp,
                                                                                strokeColor = SolidColor(Color(0xFF94B719)),
                                                                            )
                                                                        )
                                                                    )
                                                                },
                                                                labelProperties = LabelProperties(
                                                                    enabled = true,
                                                                    textStyle = MaterialTheme.typography.labelSmall,
                                                                    padding = 16.dp,
                                                                    labels = moveLabels ),
                                                                curvedEdges = false,
                                                                zeroLineProperties = ZeroLineProperties(
                                                                    enabled = true,
                                                                    color = SolidColor(Color(0xffc33ba5)),
                                                                    thickness = 1.5.dp
                                                                ),
                                                                animationMode = AnimationMode.Together(delayBuilder = {
                                                                    it * 500L
                                                                }),
                                                            )
                                                        } else {
                                                            Text("You don't have any transactions.")
                                                        }
                                                    }
                                    
                                                    Spacer(modifier = Modifier.height(16.dp))
                                                    Text(
                                                        text = "Save with these promotions",
                                                        style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.Medium)
                                                    )
                                                    Spacer(modifier = Modifier.height(8.dp))
                                                }
                                    
                                                items(promos.take(3)) { promo ->
                                                    PromoItem(promo) {}
                                                    Spacer(modifier = Modifier.height(8.dp))
                                                }
                                    
                                                item {
                                                    Button(
                                                        onClick = { navController.navigate("promos") },
                                                        modifier = Modifier.fillMaxWidth()
                                                    ) {
                                                        Text("See More Promotions")
                                                    }
                                                }
                                            }
                                    
                                            if (showAddTransactionModal) {
                                                AddTransactionModal(
                                                    accountViewModel = accountViewModel,
                                                    transactionViewModel,
                                                    accounts = accounts,
                                                    onDismiss = { showAddTransactionModal = false },
                                                    onTransactionAdded = {
                                                        showAddTransactionModal = false
                                                        accountViewModel.fetchAccounts()
                                                    }
                                                )
                                            }
                                        }
                                    }
                                    
                                    @Composable
                                    fun AccountItem(account: Account, navController: NavController) {
                                        Card(
                                            modifier = Modifier
                                                .fillMaxWidth()
                                                .clickable { navController.navigate("accountTransactions/${account.name}") },
                                            colors = CardDefaults.cardColors(containerColor = account.color)
                                        ) {
                                            Column(modifier = Modifier.padding(16.dp)) {
                                                Text(
                                                    text = account.name,
                                                    color = androidx.compose.ui.graphics.Color.White,
                                                    fontWeight = FontWeight.Bold
                                                )
                                                Spacer(modifier = Modifier.height(4.dp))
                                                Text(
                                                    text = account.type,
                                                    color = androidx.compose.ui.graphics.Color.White.copy(alpha = 0.7f)
                                                )
                                                Spacer(modifier = Modifier.height(8.dp))
                                                Text(
                                                    text = "$ ${account.amount}",
                                                    color = androidx.compose.ui.graphics.Color.White,
                                                    fontWeight = FontWeight.Bold
                                                )
                                            }
                                        }
                                    }
                                    
                                    @Composable
                                    fun PromoItem(promo: Offer, onClick: () -> Unit) {
                                        Card(
                                            modifier = Modifier
                                                .fillMaxWidth()
                                                .clickable(onClick = onClick),
                                            elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
                                        ) {
                                            Column(modifier = Modifier.padding(16.dp)) {
                                                promo.placeName?.let { Text(it, fontSize = 18.sp, fontWeight = FontWeight.Bold) }
                                                Spacer(modifier = Modifier.height(4.dp))
                                                promo.offerDescription?.let { Text(it, fontSize = 14.sp) }
                                                Spacer(modifier = Modifier.height(4.dp))
                                                Text(
                                                    "Recommended: ${promo.recommendationReason}",
                                                    fontSize = 12.sp,
                                                    color = androidx.compose.ui.graphics.Color.Gray
                                                )
                                                Spacer(modifier = Modifier.height(4.dp))
                                                promo.shopImage?.let {
                                                    Image(
                                                        painter = rememberImagePainter(it),
                                                        contentDescription = "Shop Image",
                                                        modifier = Modifier
                                                            .fillMaxWidth()
                                                            .height(150.dp)
                                                    )
                                                }
                                            }
                                        }
                                    }
                                    
                                    @OptIn(ExperimentalMaterial3Api::class)
                                    @Composable
                                    fun AddTransactionModal(
                                        accountViewModel: AccountViewModel,
                                        transactionViewModel: TransactionViewModel,
                                        accounts: List<Account>,
                                        onDismiss: () -> Unit,
                                        onTransactionAdded: () -> Unit
                                    ) {
                                        var amount by remember { mutableStateOf("") }
                                        var transactionName by remember { mutableStateOf("") }
                                        var selectedDate by remember { mutableStateOf(Timestamp.now()) }
                                        var selectedTransactionType by remember { mutableStateOf("Expense") }
                                        var expandedTransactionType by remember { mutableStateOf(false) }
                                        var selectedAccountType by remember { mutableStateOf("Nu") }
                                        var expandedAccountType by remember { mutableStateOf(false) }
                                    
                                        val context = LocalContext.current
                                        val calendar = Calendar.getInstance()
                                    
                                        val datePickerDialog = android.app.DatePickerDialog(
                                            context,
                                            { _, year, month, dayOfMonth ->
                                                calendar.set(year, month, dayOfMonth)
                                                selectedDate = Timestamp(calendar.time)
                                            },
                                            calendar.get(Calendar.YEAR),
                                            calendar.get(Calendar.MONTH),
                                            calendar.get(Calendar.DAY_OF_MONTH)
                                        )
                                    
                                        ModalBottomSheet(
                                            onDismissRequest = onDismiss
                                        ) {
                                            Column(
                                                modifier = Modifier
                                                    .fillMaxWidth()
                                                    .padding(16.dp)
                                            ) {
                                                Text("Add Transaction", style = MaterialTheme.typography.headlineSmall)
                                                Spacer(modifier = Modifier.height(16.dp))
                                    
                                                OutlinedTextField(
                                                    value = amount,
                                                    onValueChange = { amount = it.filter { char -> char.isDigit() } },
                                                    label = { Text("Amount") },
                                                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
                                                    modifier = Modifier.fillMaxWidth()
                                                )
                                    
                                                Spacer(modifier = Modifier.height(8.dp))
                                    
                                                OutlinedTextField(
                                                    value = transactionName,
                                                    onValueChange = { transactionName = it },
                                                    label = { Text("Transaction Name") },
                                                    modifier = Modifier.fillMaxWidth()
                                                )
                                    
                                                Spacer(modifier = Modifier.height(8.dp))
                                    
                                                Button(onClick = { datePickerDialog.show() }) {
                                                    Text("Select Date: ${SimpleDateFormat("yyyy-MM-dd", Locale.getDefault()).format(selectedDate.toDate())}")
                                                }
                                    
                                                Spacer(modifier = Modifier.height(8.dp))
                                    
                                                ExposedDropdownMenuBox(
                                                    expanded = expandedTransactionType,
                                                    onExpandedChange = { expandedTransactionType = !expandedTransactionType }
                                                ) {
                                                    TextField(
                                                        value = selectedTransactionType,
                                                        onValueChange = {},
                                                        readOnly = true,
                                                        trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = expandedTransactionType) },
                                                        modifier = Modifier.menuAnchor().fillMaxWidth()
                                                    )
                                                    ExposedDropdownMenu(
                                                        expanded = expandedTransactionType,
                                                        onDismissRequest = { expandedTransactionType = false }
                                                    ) {
                                                        DropdownMenuItem(
                                                            text = { Text("Income") },
                                                            onClick = {
                                                                selectedTransactionType = "Income"
                                                                expandedTransactionType = false
                                                            }
                                                        )
                                                        DropdownMenuItem(
                                                            text = { Text("Expense") },
                                                            onClick = {
                                                                selectedTransactionType = "Expense"
                                                                expandedTransactionType = false
                                                            }
                                                        )
                                                    }
                                                }
                                    
                                                Spacer(modifier = Modifier.height(8.dp))
                                    
                                                ExposedDropdownMenuBox(
                                                    expanded = expandedAccountType,
                                                    onExpandedChange = { expandedAccountType = !expandedAccountType }
                                                ) {
                                                    TextField(
                                                        value = selectedAccountType,
                                                        onValueChange = {},
                                                        readOnly = true,
                                                        trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = expandedAccountType) },
                                                        modifier = Modifier.menuAnchor().fillMaxWidth()
                                                    )
                                                    ExposedDropdownMenu(
                                                        expanded = expandedAccountType,
                                                        onDismissRequest = { expandedAccountType = false }
                                                    ) {
                                                        accounts.forEach { account ->
                                                            DropdownMenuItem(
                                                                text = { Text(account.name) },
                                                                onClick = {
                                                                    selectedAccountType = account.name
                                                                    expandedAccountType = false
                                                                }
                                                            )
                                                        }
                                                    }
                                                }
                                    
                                                Spacer(modifier = Modifier.height(16.dp))
                                    
                                                Button(
                                                    onClick = {
                                                        val transaction = Transaction(
                                                            id = "",
                                                            accountId = selectedAccountType,
                                                            transactionName = transactionName,
                                                            amount = amount.toLongOrNull() ?: 0L,
                                                            dateTime = selectedDate,
                                                            transactionType = selectedTransactionType,
                                                            location = null
                                                        )
                                                        transactionViewModel.addTransactionWithAccountCheck(transaction)
                                                        onTransactionAdded()
                                                        onDismiss()
                                                    },
                                                    modifier = Modifier.fillMaxWidth()
                                                ) {
                                                    Text("Add Transaction")
                                                }
                                            }
                                        }
                                    }
                                    ```
                        - **services/**
                            - NotificationListener.kt
                                ```
                                package com.isis3510.spendiq.services
                                
                                import android.app.NotificationChannel
                                import android.app.NotificationManager
                                import android.content.Context
                                import android.os.Build
                                import android.service.notification.NotificationListenerService
                                import android.service.notification.StatusBarNotification
                                import androidx.core.app.NotificationCompat
                                import com.google.firebase.Timestamp
                                import com.google.firebase.auth.FirebaseAuth
                                import com.google.firebase.firestore.FirebaseFirestore
                                import com.isis3510.spendiq.R
                                import kotlinx.coroutines.*
                                import kotlinx.coroutines.tasks.await
                                
                                /**
                                 * NotificationListener is a service that listens for notifications from other apps.
                                 * It processes notifications related to transactions and updates the user's account accordingly.
                                 */
                                class NotificationListener : NotificationListenerService() {
                                
                                    private val firestore = FirebaseFirestore.getInstance() // Firestore instance for database operations
                                    private lateinit var locationService: LocationService // Service to handle location-related tasks
                                    private val coroutineScope = CoroutineScope(Dispatchers.IO + SupervisorJob()) // Coroutine scope for background tasks
                                
                                    override fun onCreate() {
                                        super.onCreate()
                                        locationService = LocationService(this) // Initialize location service
                                    }
                                
                                    override fun onDestroy() {
                                        super.onDestroy()
                                        coroutineScope.cancel() // Cancel all coroutines when the service is destroyed
                                    }
                                
                                    /**
                                     * This method is called when a notification is posted.
                                     * It checks the notification's title and text, and processes transactions accordingly.
                                     */
                                    override fun onNotificationPosted(sbn: StatusBarNotification?) {
                                        super.onNotificationPosted(sbn)
                                
                                        sbn?.let {
                                            val notification = sbn.notification
                                            val extras = notification.extras
                                
                                            val title = extras.getString("android.title", "No title") ?: "No title"
                                            val text = extras.getCharSequence("android.text", "No text").toString()
                                
                                            // Skip processing if the notification content is hidden
                                            if (text.contains("content hidden", ignoreCase = true)) return
                                
                                            // Process the notification based on its title
                                            when {
                                                title.startsWith("Compra aprobada por") -> {
                                                    coroutineScope.launch { processExpenseTransaction(text) } // Process as an expense transaction
                                                }
                                                title == "Nu" -> {
                                                    coroutineScope.launch { processIncomeTransaction(text) } // Process as an income transaction
                                                }
                                
                                                else -> {}
                                            }
                                        }
                                    }
                                
                                    /**
                                     * Processes incoming transaction notifications related to income.
                                     * Extracts relevant details and adds the transaction to the user's account.
                                     */
                                    private suspend fun processIncomeTransaction(text: String) {
                                        val userId = getCurrentUserId() ?: return // Get the current user's ID
                                
                                        val nuAccount = getNuAccount(userId) // Get or create Nu account
                                        if (nuAccount == null) createNuAccount(userId)
                                
                                        // Regex to extract company name and amount from notification text
                                        val regex = Regex("([\\w\\s]+) te envio \\$([\\d,.]+) con motivo de ([\\w\\s]+)")
                                        val matchResult = regex.find(text)
                                
                                        matchResult?.let {
                                            val company = matchResult.groupValues[1] // Extract company name
                                            var amountString = matchResult.groupValues[2].replace(".", "") // Clean amount string
                                
                                            // Handle comma in amount string
                                            if (amountString.contains(",")) {
                                                amountString = amountString.split(",")[0]
                                            }
                                
                                            val amount = amountString.toLong() // Parse amount to Long
                                            val currentTimestamp = Timestamp.now() // Get current timestamp
                                
                                            // Retrieve location before proceeding with the transaction
                                            val location = locationService.getCurrentLocation()
                                
                                            // Check if the transaction already exists
                                            if (!transactionExists(userId, company, amount, currentTimestamp, "Income")) {
                                                addTransaction(userId, amount, company, "Income", location, automatic = true) // Add transaction
                                                updateNuAccountBalance(userId, amount) // Update account balance
                                                showNotification("Income Recorded", "Income of $$amount from $company has been recorded.") // Show notification
                                            }
                                        }
                                    }
                                
                                    /**
                                     * Processes outgoing transaction notifications related to expenses.
                                     * Extracts relevant details and adds the transaction to the user's account.
                                     */
                                    private suspend fun processExpenseTransaction(text: String) {
                                        val userId = getCurrentUserId() ?: return // Get the current user's ID
                                
                                        val nuAccount = getNuAccount(userId) // Get or create Nu account
                                        if (nuAccount == null) createNuAccount(userId)
                                
                                        // Regex to extract company name and amount from notification text
                                        val regex = Regex("Tu compra en ([\\w\\s]+) por \\$([\\d,.]+) con tu tarjeta terminada en ([\\d]+)")
                                        val matchResult = regex.find(text)
                                
                                        matchResult?.let {
                                            val company = matchResult.groupValues[1] // Extract company name
                                            var amountString = matchResult.groupValues[2].replace(".", "") // Clean amount string
                                
                                            // Handle comma in amount string
                                            if (amountString.contains(",")) {
                                                amountString = amountString.split(",")[0]
                                            }
                                
                                            val amount = amountString.toLong() // Parse amount to Long
                                            val currentTimestamp = Timestamp.now() // Get current timestamp
                                
                                            // Retrieve location before proceeding with the transaction
                                            val location = locationService.getCurrentLocation()
                                
                                            // Check if the transaction already exists
                                            if (!transactionExists(userId, company, amount, currentTimestamp, "Expense")) {
                                                addTransaction(userId, amount, company, "Expense", location, automatic = true) // Add transaction
                                                updateNuAccountBalance(userId, -amount) // Update account balance
                                                showNotification("Expense Recorded", "Expense of $$amount to $company has been recorded.") // Show notification
                                            }
                                        }
                                    }
                                
                                    /**
                                     * Checks if a transaction already exists for the given parameters to avoid duplicates.
                                     *
                                     * @return True if the transaction exists, otherwise false.
                                     */
                                    private suspend fun transactionExists(userId: String, transactionName: String, amount: Long, timestamp: Timestamp, transactionType: String): Boolean {
                                        return try {
                                            val startTime = Timestamp(timestamp.seconds - 60, timestamp.nanoseconds) // Set a time window of 60 seconds before
                                            val endTime = Timestamp(timestamp.seconds + 60, timestamp.nanoseconds) // Set a time window of 60 seconds after
                                
                                            val snapshot = firestore.collection("accounts")
                                                .whereEqualTo("name", "Nu")
                                                .whereEqualTo("user_id", userId)
                                                .get()
                                                .await()
                                
                                            if (snapshot.documents.isNotEmpty()) {
                                                val accountId = snapshot.documents[0].id // Get account ID
                                                val transactionSnapshot = firestore.collection("accounts")
                                                    .document(accountId)
                                                    .collection("transactions")
                                                    .whereEqualTo("transactionName", transactionName)
                                                    .whereEqualTo("amount", amount)
                                                    .whereEqualTo("transactionType", transactionType)
                                                    .whereGreaterThan("dateTime", startTime)
                                                    .whereLessThan("dateTime", endTime)
                                                    .get()
                                                    .await()
                                
                                                transactionSnapshot.documents.isNotEmpty() // Return true if a transaction exists
                                            } else {
                                                false // No account found
                                            }
                                        } catch (e: Exception) {
                                            false // Return false in case of error
                                        }
                                    }
                                
                                    /**
                                     * Retrieves the Nu account for the current user.
                                     *
                                     * @return A map containing the account data, or null if the account does not exist.
                                     */
                                    private suspend fun getNuAccount(userId: String): Map<String, Any>? {
                                        return try {
                                            val snapshot = firestore.collection("accounts")
                                                .whereEqualTo("name", "Nu")
                                                .whereEqualTo("user_id", userId)
                                                .get()
                                                .await()
                                
                                            if (snapshot.documents.isNotEmpty()) {
                                                snapshot.documents[0].data // Return account data
                                            } else {
                                                null // No account found
                                            }
                                        } catch (e: Exception) {
                                            null // Return null in case of error
                                        }
                                    }
                                
                                    /**
                                     * Creates a new Nu account for the user.
                                     */
                                    private suspend fun createNuAccount(userId: String) {
                                        try {
                                            firestore.collection("accounts").add(
                                                mapOf(
                                                    "amount" to 0L, // Initial amount
                                                    "name" to "Nu", // Account name
                                                    "user_id" to userId // User ID
                                                )
                                            ).await() // Await completion
                                        } catch (e: Exception) {
                                            // Handle error
                                        }
                                    }
                                
                                    /**
                                     * Adds a transaction to the user's account.
                                     */
                                    private suspend fun addTransaction(userId: String, amount: Long, transactionName: String, transactionType: String, location: android.location.Location?, automatic: Boolean) {
                                        try {
                                            val accountSnapshot = firestore.collection("accounts")
                                                .whereEqualTo("name", "Nu")
                                                .whereEqualTo("user_id", userId)
                                                .get()
                                                .await()
                                
                                            if (accountSnapshot.documents.isNotEmpty()) {
                                                val accountId = accountSnapshot.documents[0].id // Get account ID
                                                val transaction = hashMapOf(
                                                    "amount" to amount, // Transaction amount
                                                    "dateTime" to Timestamp.now(), // Current timestamp
                                                    "accountID" to accountId, // Associated account ID
                                                    "transactionName" to transactionName, // Name of the transaction
                                                    "transactionType" to transactionType, // Type of transaction
                                                    "automatic" to automatic, // Flag indicating if the transaction is automatic
                                                    "location" to if (location != null) {
                                                        hashMapOf(
                                                            "latitude" to location.latitude,
                                                            "longitude" to location.longitude
                                                        ) // Location coordinates
                                                    } else null
                                                )
                                
                                                firestore.collection("accounts")
                                                    .document(accountId)
                                                    .collection("transactions")
                                                    .add(transaction) // Add transaction to Firestore
                                                    .await()
                                            } else {
                                                // Handle error
                                            }
                                        } catch (e: Exception) {
                                            // Handle error
                                        }
                                    }
                                
                                    /**
                                     * Updates the Nu account balance after a transaction.
                                     */
                                    private suspend fun updateNuAccountBalance(userId: String, amountDelta: Long) {
                                        try {
                                            val accountSnapshot = firestore.collection("accounts")
                                                .whereEqualTo("name", "Nu")
                                                .whereEqualTo("user_id", userId)
                                                .get()
                                                .await()
                                
                                            if (accountSnapshot.documents.isNotEmpty()) {
                                                val accountId = accountSnapshot.documents[0].id
                                                val currentAmount = accountSnapshot.documents[0].getLong("amount") ?: 0L // Get current amount
                                                val newAmount = currentAmount + amountDelta // Update balance
                                
                                                firestore.collection("accounts")
                                                    .document(accountId)
                                                    .update("amount", newAmount) // Update the account amount
                                                    .await()
                                            } else {
                                                // Handle error
                                            }
                                        } catch (e: Exception) {
                                            // Handle error
                                        }
                                    }
                                
                                    /**
                                     * This method is called when a notification is removed.
                                     */
                                    override fun onNotificationRemoved(sbn: StatusBarNotification?) {
                                        super.onNotificationRemoved(sbn)
                                    }
                                
                                    /**
                                     * Retrieves the current user's ID.
                                     *
                                     * @return The user's ID as a String, or null if not authenticated.
                                     */
                                    private fun getCurrentUserId(): String? {
                                        val user = FirebaseAuth.getInstance().currentUser
                                        return user?.uid // Return user ID or null
                                    }
                                
                                    /**
                                     * Displays a notification to the user.
                                     *
                                     * @param title The title of the notification.
                                     * @param content The content/message of the notification.
                                     */
                                    private fun showNotification(title: String, content: String) {
                                        val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
                                        val channelId = "SpendiQ_Channel"
                                        val channelName = "SpendiQ Notifications"
                                
                                        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                                            val channel = NotificationChannel(channelId, channelName, NotificationManager.IMPORTANCE_DEFAULT)
                                            notificationManager.createNotificationChannel(channel) // Create notification channel for API 26+
                                        }
                                
                                        val notification = NotificationCompat.Builder(this, channelId)
                                            .setContentTitle(title)
                                            .setContentText(content)
                                            .setSmallIcon(R.drawable.notification)
                                            .setAutoCancel(true) // Automatically remove the notification when tapped
                                            .build()
                                
                                        notificationManager.notify(System.currentTimeMillis().toInt(), notification) // Show notification
                                    }
                                }
                                ```
                            - AnomalyApiService.kt
                                ```
                                package com.isis3510.spendiq.services
                                
                                import retrofit2.Retrofit
                                import retrofit2.converter.gson.GsonConverterFactory
                                import retrofit2.http.POST
                                import retrofit2.http.Path
                                import okhttp3.OkHttpClient
                                import java.util.concurrent.TimeUnit
                                
                                // Interface defining the API service for analyzing transactions
                                interface AnomalyApiService {
                                    /**
                                     * Sends a request to analyze a completed transaction for anomalies.
                                     *
                                     * @param userId The ID of the user for whom the transaction is being analyzed.
                                     * @param transactionId The ID of the transaction that is being analyzed.
                                     */
                                    @POST("api/analyze-transaction-complete/{user_id}/{transaction_id}")
                                    suspend fun analyzeTransaction(
                                        @Path("user_id") userId: String,
                                        @Path("transaction_id") transactionId: String
                                    )
                                
                                    companion object {
                                        // Base URL of the API
                                        private const val BASE_URL = "http://148.113.204.223:8000/"
                                
                                        /**
                                         * Creates an instance of the AnomalyApiService with the necessary configurations.
                                         *
                                         * @return An instance of AnomalyApiService for making API calls.
                                         */
                                        fun create(): AnomalyApiService {
                                            // Build the OkHttpClient with custom timeout settings
                                            val client = OkHttpClient.Builder()
                                                .connectTimeout(30, TimeUnit.SECONDS) // Connection timeout
                                                .readTimeout(30, TimeUnit.SECONDS)    // Read timeout
                                                .writeTimeout(30, TimeUnit.SECONDS)   // Write timeout
                                                .build()
                                
                                            // Create a Retrofit instance with the specified base URL and client
                                            return Retrofit.Builder()
                                                .baseUrl(BASE_URL) // Set the base URL for the API
                                                .client(client) // Attach the OkHttpClient instance
                                                .addConverterFactory(GsonConverterFactory.create()) // Set the converter for JSON
                                                .build() // Build the Retrofit instance
                                                .create(AnomalyApiService::class.java) // Create the API service interface
                                        }
                                    }
                                }
                                ```
                            - AuthenticationService.kt
                                ```
                                package com.isis3510.spendiq.services
                                
                                import com.google.firebase.auth.FirebaseAuth
                                import kotlinx.coroutines.tasks.await
                                import kotlinx.coroutines.flow.Flow
                                import kotlinx.coroutines.flow.flow
                                
                                // Protocol defining the authentication service operations
                                interface AuthenticationServiceProtocol {
                                    /**
                                     * Logs in a user with the given email and password.
                                     * @param email The email of the user.
                                     * @param password The password of the user.
                                     * @return A Flow that emits true if the login is successful, false otherwise.
                                     */
                                    fun login(email: String, password: String): Flow<Boolean>
                                
                                    /**
                                     * Signs up a new user with the given email and password.
                                     * @param email The email of the new user.
                                     * @param password The password of the new user.
                                     * @return A Flow that emits true if the sign-up is successful, false otherwise.
                                     */
                                    fun signUp(email: String, password: String): Flow<Boolean>
                                }
                                
                                // Implementation of the authentication service using Firebase Authentication
                                class AuthenticationService : AuthenticationServiceProtocol {
                                    private val auth: FirebaseAuth = FirebaseAuth.getInstance() // Firebase authentication instance
                                
                                    /**
                                     * Logs in a user with the provided email and password.
                                     * Uses Firebase Authentication to sign in the user.
                                     * @param email The user's email.
                                     * @param password The user's password.
                                     * @return A Flow that emits true if login is successful, or false if it fails.
                                     */
                                    override fun login(email: String, password: String): Flow<Boolean> = flow {
                                        try {
                                            // Attempt to sign in with the provided email and password
                                            auth.signInWithEmailAndPassword(email, password).await()
                                            emit(true) // Emit true if sign in is successful
                                        } catch (e: Exception) {
                                            emit(false) // Emit false if there is an error
                                        }
                                    }
                                
                                    /**
                                     * Signs up a new user using the provided email and password.
                                     * Utilizes Firebase Authentication to create the user.
                                     * @param email The new user's email.
                                     * @param password The new user's password.
                                     * @return A Flow that emits true if sign up is successful, or false if it fails.
                                     */
                                    override fun signUp(email: String, password: String): Flow<Boolean> = flow {
                                        try {
                                            // Attempt to create a new user with the provided email and password
                                            auth.createUserWithEmailAndPassword(email, password).await()
                                            emit(true) // Emit true if sign up is successful
                                        } catch (e: Exception) {
                                            emit(false) // Emit false if there is an error
                                        }
                                    }
                                }
                                ```
                            - LocationService.kt
                                ```
                                package com.isis3510.spendiq.services
                                
                                import android.Manifest
                                import android.content.Context
                                import android.content.pm.PackageManager
                                import android.location.Location
                                import android.os.Looper
                                import androidx.core.app.ActivityCompat
                                import com.google.android.gms.location.*
                                import kotlinx.coroutines.suspendCancellableCoroutine
                                import kotlin.coroutines.resume
                                
                                /**
                                 * LocationService is a class that provides methods to retrieve the current location of the device.
                                 * It utilizes the FusedLocationProviderClient to access location services efficiently.
                                 *
                                 * @param context The context of the application, used to access system services.
                                 */
                                class LocationService(private val context: Context) {
                                    private val fusedLocationClient: FusedLocationProviderClient = LocationServices.getFusedLocationProviderClient(context)
                                
                                    /**
                                     * Retrieves the current location of the device.
                                     *
                                     * This method first checks if location permissions are granted. If they are not, it returns null.
                                     * If permissions are granted, it attempts to get the last known location. If the last known
                                     * location is null, it requests a single location update.
                                     *
                                     * @return The current location as a [Location] object, or null if permissions are not granted or an error occurs.
                                     */
                                    suspend fun getCurrentLocation(): Location? {
                                        // Check for location permissions
                                        if (ActivityCompat.checkSelfPermission(
                                                context,
                                                Manifest.permission.ACCESS_FINE_LOCATION
                                            ) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(
                                                context,
                                                Manifest.permission.ACCESS_COARSE_LOCATION
                                            ) != PackageManager.PERMISSION_GRANTED
                                        ) {
                                            return null // Return null if permissions are not granted
                                        }
                                
                                        return suspendCancellableCoroutine { continuation ->
                                            // Attempt to get the last known location
                                            fusedLocationClient.lastLocation
                                                .addOnSuccessListener { location ->
                                                    if (location != null) {
                                                        continuation.resume(location) // Resume with the last known location
                                                    } else {
                                                        // If last known location is null, request a single location update
                                                        val locationRequest = LocationRequest.create().apply {
                                                            priority = LocationRequest.PRIORITY_HIGH_ACCURACY // Set high accuracy for the location request
                                                            numUpdates = 1 // Set the number of updates to 1
                                                        }
                                                        // Define a location callback to handle the location result
                                                        val locationCallback = object : LocationCallback() {
                                                            override fun onLocationResult(locationResult: LocationResult) {
                                                                fusedLocationClient.removeLocationUpdates(this) // Stop location updates
                                                                continuation.resume(locationResult.lastLocation) // Resume with the new location
                                                            }
                                                        }
                                                        // Request location updates
                                                        fusedLocationClient.requestLocationUpdates(
                                                            locationRequest,
                                                            locationCallback,
                                                            Looper.getMainLooper() // Use the main looper for the callback
                                                        )
                                                    }
                                                }
                                                .addOnFailureListener { exception ->
                                                    continuation.resume(null) // Resume with null on failure
                                                }
                                
                                            // Clean up: Remove location updates if the coroutine is cancelled
                                            continuation.invokeOnCancellation {
                                                fusedLocationClient.removeLocationUpdates(object : LocationCallback() {})
                                            }
                                        }
                                    }
                                }
                                ```
                            - LocationBasedOfferService.kt
                                ```
                                package com.isis3510.spendiq.services
                                
                                import android.Manifest
                                import android.app.NotificationChannel
                                import android.app.NotificationManager
                                import android.content.Context
                                import android.content.pm.PackageManager
                                import android.os.Build
                                import android.os.Looper
                                import androidx.core.app.ActivityCompat
                                import androidx.core.app.NotificationCompat
                                import com.google.android.gms.location.*
                                import com.isis3510.spendiq.R
                                import com.isis3510.spendiq.model.data.Offer
                                import kotlinx.coroutines.CoroutineScope
                                import kotlinx.coroutines.Dispatchers
                                import kotlinx.coroutines.launch
                                import kotlin.math.*
                                
                                // This service listens for location updates and sends notifications for nearby offers.
                                class LocationBasedOfferService(private val context: Context) {
                                    private val fusedLocationClient: FusedLocationProviderClient = LocationServices.getFusedLocationProviderClient(context)
                                    private val notificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
                                    private val channelId = "OfferNotificationChannel" // Channel ID for notifications
                                    private val scope = CoroutineScope(Dispatchers.IO) // Coroutine scope for background tasks
                                    private var activeOffers = listOf<Offer>() // List of offers to monitor
                                
                                    // Track the last notification time and the last notified offer ID
                                    private var lastNotificationTime: Long = 0
                                    private var lastNotifiedOfferId: String? = null
                                    private val NOTIFICATION_COOLDOWN = 3 * 60 * 1000 // Cooldown period of 15 minutes
                                    private val MAX_NOTIFICATION_DISTANCE = 1000.0 // Maximum distance for notifications in meters
                                
                                    // Callback to receive location updates
                                    private val locationCallback = object : LocationCallback() {
                                        override fun onLocationResult(locationResult: LocationResult) {
                                            locationResult.lastLocation?.let { currentLocation ->
                                                checkNearbyOffers(currentLocation.latitude, currentLocation.longitude)
                                            }
                                        }
                                    }
                                
                                    init {
                                        createNotificationChannel() // Create the notification channel on initialization
                                    }
                                
                                    /**
                                     * Starts monitoring for nearby offers by setting up location updates.
                                     * @param offers List of offers to monitor for proximity.
                                     */
                                    fun startMonitoring(offers: List<Offer>) {
                                        if (!hasLocationPermission()) {
                                            return // Exit if location permission is not granted
                                        }
                                
                                        activeOffers = offers // Update the list of active offers
                                
                                        // Create a location request for high accuracy updates
                                        val locationRequest = LocationRequest.create().apply {
                                            priority = LocationRequest.PRIORITY_HIGH_ACCURACY // Use high accuracy for location updates
                                            interval = 60000 // Request location updates every minute
                                            fastestInterval = 30000 // Fastest update interval
                                        }
                                
                                        try {
                                            // Request location updates with the specified location request and callback
                                            fusedLocationClient.requestLocationUpdates(
                                                locationRequest,
                                                locationCallback,
                                                Looper.getMainLooper() // Use the main looper for callbacks
                                            )
                                        } catch (e: SecurityException) {
                                            // Handle the exception if permissions are missing
                                        }
                                    }
                                
                                    /**
                                     * Stops monitoring for offers by removing location updates.
                                     */
                                    fun stopMonitoring() {
                                        fusedLocationClient.removeLocationUpdates(locationCallback) // Remove location updates
                                        activeOffers = emptyList() // Clear the list of active offers
                                    }
                                
                                    /**
                                     * Checks for offers that are nearby the current location.
                                     * @param currentLat Current latitude of the device.
                                     * @param currentLon Current longitude of the device.
                                     */
                                    private fun checkNearbyOffers(currentLat: Double, currentLon: Double) {
                                        scope.launch {
                                            val currentTime = System.currentTimeMillis() // Get the current time
                                
                                            // Ensure enough time has passed since the last notification
                                            if (currentTime - lastNotificationTime < NOTIFICATION_COOLDOWN) {
                                                return@launch
                                            }
                                
                                            // Find the closest offer within the specified range
                                            val closestOffer = activeOffers
                                                .filter { offer ->
                                                    offer.id != null &&
                                                            offer.latitude != null &&
                                                            offer.longitude != null &&
                                                            offer.id != lastNotifiedOfferId // Exclude the last notified offer
                                                }
                                                .map { offer ->
                                                    Pair(offer, calculateDistance(
                                                        currentLat, currentLon,
                                                        offer.latitude!!, offer.longitude!!
                                                    ))
                                                }
                                                .filter { (_, distance) -> distance <= MAX_NOTIFICATION_DISTANCE } // Filter by maximum distance
                                                .minByOrNull { (_, distance) -> distance } // Find the closest offer
                                
                                            closestOffer?.let { (offer, distance) ->
                                                sendOfferNotification(offer, distance.toInt()) // Send notification for the offer
                                                lastNotificationTime = currentTime // Update the last notification time
                                                lastNotifiedOfferId = offer.id // Update the last notified offer ID
                                            }
                                        }
                                    }
                                
                                    /**
                                     * Calculates the distance between two geographical points using the Haversine formula.
                                     * @param lat1 Latitude of the first point.
                                     * @param lon1 Longitude of the first point.
                                     * @param lat2 Latitude of the second point.
                                     * @param lon2 Longitude of the second point.
                                     * @return The distance in meters.
                                     */
                                    private fun calculateDistance(lat1: Double, lon1: Double, lat2: Double, lon2: Double): Double {
                                        val r = 6371e3 // Earth's radius in meters
                                        val 1 = lat1 * Math.PI / 180
                                        val 2 = lat2 * Math.PI / 180
                                        val  = (lat2 - lat1) * Math.PI / 180
                                        val  = (lon2 - lon1) * Math.PI / 180
                                
                                        // Haversine formula
                                        val a = sin( / 2) * sin( / 2) +
                                                cos(1) * cos(2) *
                                                sin( / 2) * sin( / 2)
                                        val c = 2 * atan2(sqrt(a), sqrt(1 - a))
                                
                                        return r * c // Return the distance
                                    }
                                
                                    /**
                                     * Sends a notification to the user about a nearby offer.
                                     * @param offer The offer details to include in the notification.
                                     * @param distance The distance to the offer.
                                     */
                                    private fun sendOfferNotification(offer: Offer, distance: Int) {
                                        val distanceText = when {
                                            distance < 100 -> "less than 100 meters"
                                            distance < 1000 -> "${(distance / 100) * 100} meters"
                                            else -> "${distance / 1000.0} km"
                                        }
                                
                                        // Build and send the notification
                                        val notification = NotificationCompat.Builder(context, channelId)
                                            .setContentTitle("Special Offer Nearby!")
                                            .setContentText("${offer.placeName} (${distanceText} away): ${offer.offerDescription}")
                                            .setStyle(NotificationCompat.BigTextStyle()
                                                .bigText("${offer.placeName} (${distanceText} away): ${offer.offerDescription}\n${offer.recommendationReason ?: ""}")
                                            )
                                            .setSmallIcon(R.drawable.notification) // Icon for the notification
                                            .setPriority(NotificationCompat.PRIORITY_DEFAULT)
                                            .setAutoCancel(true) // Dismiss the notification when clicked
                                            .build()
                                
                                        notificationManager.notify(OFFER_NOTIFICATION_ID, notification) // Notify using the ID
                                    }
                                
                                    /**
                                     * Creates a notification channel for API 26 and above.
                                     */
                                    private fun createNotificationChannel() {
                                        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                                            val name = "Nearby Offers" // Name of the notification channel
                                            val descriptionText = "Notifications for nearby special offers" // Description of the channel
                                            val importance = NotificationManager.IMPORTANCE_DEFAULT // Importance level
                                            val channel = NotificationChannel(channelId, name, importance).apply {
                                                description = descriptionText // Set the description
                                            }
                                            notificationManager.createNotificationChannel(channel) // Create the channel
                                        }
                                    }
                                
                                    /**
                                     * Checks if the application has location permissions.
                                     * @return True if location permissions are granted, false otherwise.
                                     */
                                    private fun hasLocationPermission(): Boolean {
                                        return ActivityCompat.checkSelfPermission(
                                            context,
                                            Manifest.permission.ACCESS_FINE_LOCATION
                                        ) == PackageManager.PERMISSION_GRANTED // Check for fine location permission
                                    }
                                
                                    companion object {
                                        private const val OFFER_NOTIFICATION_ID = 1001 // Notification ID for offer notifications
                                    }
                                }
                                ```
        - ic_launcher-playstore.png
            ```
            Error reading file: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte
